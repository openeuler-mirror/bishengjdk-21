//
// Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
// Copyright (c) 2015, 2023, Loongson Technology. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License version 2 only, as
// published by the Free Software Foundation.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// You should have received a copy of the GNU General Public License version
// 2 along with this work; if not, write to the Free Software Foundation,
// Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
//
// Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
// or visit www.oracle.com if you need additional information or have any
// questions.
//
//

// GodSon3 Architecture Description File

//----------REGISTER DEFINITION BLOCK------------------------------------------
// This information is used by the matcher and the register allocator to
// describe individual registers and classes of registers within the target
// architecture.

// format:
// reg_def name (call convention, c-call convention, ideal type, encoding);
//     call convention :
//      NS  = No-Save
//      SOC = Save-On-Call
//      SOE = Save-On-Entry
//      AS  = Always-Save
//    ideal type :
//      see opto/opcodes.hpp for more info
// reg_class name (reg, ...);
// alloc_class name (reg, ...);
register %{

// General Registers
// Integer Registers
  reg_def R0    ( NS,  NS,  Op_RegI,   0, R0->as_VMReg());
  reg_def R0_H  ( NS,  NS,  Op_RegI,   0, R0->as_VMReg()->next());
  reg_def RA    ( NS,  NS,  Op_RegI,   1, RA->as_VMReg());
  reg_def RA_H  ( NS,  NS,  Op_RegI,   1, RA->as_VMReg()->next());
  reg_def TP    ( NS,  NS,  Op_RegI,   2, TP->as_VMReg());
  reg_def TP_H  ( NS,  NS,  Op_RegI,   2, TP->as_VMReg()->next());
  reg_def SP    ( NS,  NS,  Op_RegI,   3, SP->as_VMReg());
  reg_def SP_H  ( NS,  NS,  Op_RegI,   3, SP->as_VMReg()->next());
  reg_def A0    (SOC, SOC,  Op_RegI,   4, A0->as_VMReg());
  reg_def A0_H  (SOC, SOC,  Op_RegI,   4, A0->as_VMReg()->next());
  reg_def A1    (SOC, SOC,  Op_RegI,   5, A1->as_VMReg());
  reg_def A1_H  (SOC, SOC,  Op_RegI,   5, A1->as_VMReg()->next());
  reg_def A2    (SOC, SOC,  Op_RegI,   6, A2->as_VMReg());
  reg_def A2_H  (SOC, SOC,  Op_RegI,   6, A2->as_VMReg()->next());
  reg_def A3    (SOC, SOC,  Op_RegI,   7, A3->as_VMReg());
  reg_def A3_H  (SOC, SOC,  Op_RegI,   7, A3->as_VMReg()->next());
  reg_def A4    (SOC, SOC,  Op_RegI,   8, A4->as_VMReg());
  reg_def A4_H  (SOC, SOC,  Op_RegI,   8, A4->as_VMReg()->next());
  reg_def A5    (SOC, SOC,  Op_RegI,   9, A5->as_VMReg());
  reg_def A5_H  (SOC, SOC,  Op_RegI,   9, A5->as_VMReg()->next());
  reg_def A6    (SOC, SOC,  Op_RegI,  10, A6->as_VMReg());
  reg_def A6_H  (SOC, SOC,  Op_RegI,  10, A6->as_VMReg()->next());
  reg_def A7    (SOC, SOC,  Op_RegI,  11, A7->as_VMReg());
  reg_def A7_H  (SOC, SOC,  Op_RegI,  11, A7->as_VMReg()->next());
  reg_def T0    (SOC, SOC,  Op_RegI,  12, T0->as_VMReg());
  reg_def T0_H  (SOC, SOC,  Op_RegI,  12, T0->as_VMReg()->next());
  reg_def T1    (SOC, SOC,  Op_RegI,  13, T1->as_VMReg());
  reg_def T1_H  (SOC, SOC,  Op_RegI,  13, T1->as_VMReg()->next());
  reg_def T2    (SOC, SOC,  Op_RegI,  14, T2->as_VMReg());
  reg_def T2_H  (SOC, SOC,  Op_RegI,  14, T2->as_VMReg()->next());
  reg_def T3    (SOC, SOC,  Op_RegI,  15, T3->as_VMReg());
  reg_def T3_H  (SOC, SOC,  Op_RegI,  15, T3->as_VMReg()->next());
  reg_def T4    (SOC, SOC,  Op_RegI,  16, T4->as_VMReg());
  reg_def T4_H  (SOC, SOC,  Op_RegI,  16, T4->as_VMReg()->next());
  reg_def T5    (SOC, SOC,  Op_RegI,  17, T5->as_VMReg());
  reg_def T5_H  (SOC, SOC,  Op_RegI,  17, T5->as_VMReg()->next());
  reg_def T6    (SOC, SOC,  Op_RegI,  18, T6->as_VMReg());
  reg_def T6_H  (SOC, SOC,  Op_RegI,  18, T6->as_VMReg()->next());
  reg_def T7    (SOC, SOC,  Op_RegI,  19, T7->as_VMReg());
  reg_def T7_H  (SOC, SOC,  Op_RegI,  19, T7->as_VMReg()->next());
  reg_def T8    (SOC, SOC,  Op_RegI,  20, T8->as_VMReg());
  reg_def T8_H  (SOC, SOC,  Op_RegI,  20, T8->as_VMReg()->next());
  reg_def RX    ( NS,  NS,  Op_RegI,  21, RX->as_VMReg());
  reg_def RX_H  ( NS,  NS,  Op_RegI,  21, RX->as_VMReg()->next());
  reg_def FP    ( NS,  NS,  Op_RegI,  22, FP->as_VMReg());
  reg_def FP_H  ( NS,  NS,  Op_RegI,  22, FP->as_VMReg()->next());
  reg_def S0    (SOC, SOE,  Op_RegI,  23, S0->as_VMReg());
  reg_def S0_H  (SOC, SOE,  Op_RegI,  23, S0->as_VMReg()->next());
  reg_def S1    (SOC, SOE,  Op_RegI,  24, S1->as_VMReg());
  reg_def S1_H  (SOC, SOE,  Op_RegI,  24, S1->as_VMReg()->next());
  reg_def S2    (SOC, SOE,  Op_RegI,  25, S2->as_VMReg());
  reg_def S2_H  (SOC, SOE,  Op_RegI,  25, S2->as_VMReg()->next());
  reg_def S3    (SOC, SOE,  Op_RegI,  26, S3->as_VMReg());
  reg_def S3_H  (SOC, SOE,  Op_RegI,  26, S3->as_VMReg()->next());
  reg_def S4    (SOC, SOE,  Op_RegI,  27, S4->as_VMReg());
  reg_def S4_H  (SOC, SOE,  Op_RegI,  27, S4->as_VMReg()->next());
  reg_def S5    (SOC, SOE,  Op_RegI,  28, S5->as_VMReg());
  reg_def S5_H  (SOC, SOE,  Op_RegI,  28, S5->as_VMReg()->next());
  reg_def S6    (SOC, SOE,  Op_RegI,  29, S6->as_VMReg());
  reg_def S6_H  (SOC, SOE,  Op_RegI,  29, S6->as_VMReg()->next());
  reg_def S7    (SOC, SOE,  Op_RegI,  30, S7->as_VMReg());
  reg_def S7_H  (SOC, SOE,  Op_RegI,  30, S7->as_VMReg()->next());
  reg_def S8    (SOC, SOE,  Op_RegI,  31, S8->as_VMReg());
  reg_def S8_H  (SOC, SOE,  Op_RegI,  31, S8->as_VMReg()->next());


// Floating/Vector registers.
  reg_def F0    ( SOC, SOC, Op_RegF, 0, F0->as_VMReg()          );
  reg_def F0_H  ( SOC, SOC, Op_RegF, 0, F0->as_VMReg()->next()  );
  reg_def F0_J  ( SOC, SOC, Op_RegF, 0, F0->as_VMReg()->next(2) );
  reg_def F0_K  ( SOC, SOC, Op_RegF, 0, F0->as_VMReg()->next(3) );
  reg_def F0_L  ( SOC, SOC, Op_RegF, 0, F0->as_VMReg()->next(4) );
  reg_def F0_M  ( SOC, SOC, Op_RegF, 0, F0->as_VMReg()->next(5) );
  reg_def F0_N  ( SOC, SOC, Op_RegF, 0, F0->as_VMReg()->next(6) );
  reg_def F0_O  ( SOC, SOC, Op_RegF, 0, F0->as_VMReg()->next(7) );

  reg_def F1    ( SOC, SOC, Op_RegF, 1, F1->as_VMReg()          );
  reg_def F1_H  ( SOC, SOC, Op_RegF, 1, F1->as_VMReg()->next()  );
  reg_def F1_J  ( SOC, SOC, Op_RegF, 1, F1->as_VMReg()->next(2) );
  reg_def F1_K  ( SOC, SOC, Op_RegF, 1, F1->as_VMReg()->next(3) );
  reg_def F1_L  ( SOC, SOC, Op_RegF, 1, F1->as_VMReg()->next(4) );
  reg_def F1_M  ( SOC, SOC, Op_RegF, 1, F1->as_VMReg()->next(5) );
  reg_def F1_N  ( SOC, SOC, Op_RegF, 1, F1->as_VMReg()->next(6) );
  reg_def F1_O  ( SOC, SOC, Op_RegF, 1, F1->as_VMReg()->next(7) );

  reg_def F2    ( SOC, SOC, Op_RegF, 2, F2->as_VMReg()          );
  reg_def F2_H  ( SOC, SOC, Op_RegF, 2, F2->as_VMReg()->next()  );
  reg_def F2_J  ( SOC, SOC, Op_RegF, 2, F2->as_VMReg()->next(2) );
  reg_def F2_K  ( SOC, SOC, Op_RegF, 2, F2->as_VMReg()->next(3) );
  reg_def F2_L  ( SOC, SOC, Op_RegF, 2, F2->as_VMReg()->next(4) );
  reg_def F2_M  ( SOC, SOC, Op_RegF, 2, F2->as_VMReg()->next(5) );
  reg_def F2_N  ( SOC, SOC, Op_RegF, 2, F2->as_VMReg()->next(6) );
  reg_def F2_O  ( SOC, SOC, Op_RegF, 2, F2->as_VMReg()->next(7) );

  reg_def F3    ( SOC, SOC, Op_RegF, 3, F3->as_VMReg()          );
  reg_def F3_H  ( SOC, SOC, Op_RegF, 3, F3->as_VMReg()->next()  );
  reg_def F3_J  ( SOC, SOC, Op_RegF, 3, F3->as_VMReg()->next(2) );
  reg_def F3_K  ( SOC, SOC, Op_RegF, 3, F3->as_VMReg()->next(3) );
  reg_def F3_L  ( SOC, SOC, Op_RegF, 3, F3->as_VMReg()->next(4) );
  reg_def F3_M  ( SOC, SOC, Op_RegF, 3, F3->as_VMReg()->next(5) );
  reg_def F3_N  ( SOC, SOC, Op_RegF, 3, F3->as_VMReg()->next(6) );
  reg_def F3_O  ( SOC, SOC, Op_RegF, 3, F3->as_VMReg()->next(7) );

  reg_def F4    ( SOC, SOC, Op_RegF, 4, F4->as_VMReg()          );
  reg_def F4_H  ( SOC, SOC, Op_RegF, 4, F4->as_VMReg()->next()  );
  reg_def F4_J  ( SOC, SOC, Op_RegF, 4, F4->as_VMReg()->next(2) );
  reg_def F4_K  ( SOC, SOC, Op_RegF, 4, F4->as_VMReg()->next(3) );
  reg_def F4_L  ( SOC, SOC, Op_RegF, 4, F4->as_VMReg()->next(4) );
  reg_def F4_M  ( SOC, SOC, Op_RegF, 4, F4->as_VMReg()->next(5) );
  reg_def F4_N  ( SOC, SOC, Op_RegF, 4, F4->as_VMReg()->next(6) );
  reg_def F4_O  ( SOC, SOC, Op_RegF, 4, F4->as_VMReg()->next(7) );

  reg_def F5    ( SOC, SOC, Op_RegF, 5, F5->as_VMReg()          );
  reg_def F5_H  ( SOC, SOC, Op_RegF, 5, F5->as_VMReg()->next()  );
  reg_def F5_J  ( SOC, SOC, Op_RegF, 5, F5->as_VMReg()->next(2) );
  reg_def F5_K  ( SOC, SOC, Op_RegF, 5, F5->as_VMReg()->next(3) );
  reg_def F5_L  ( SOC, SOC, Op_RegF, 5, F5->as_VMReg()->next(4) );
  reg_def F5_M  ( SOC, SOC, Op_RegF, 5, F5->as_VMReg()->next(5) );
  reg_def F5_N  ( SOC, SOC, Op_RegF, 5, F5->as_VMReg()->next(6) );
  reg_def F5_O  ( SOC, SOC, Op_RegF, 5, F5->as_VMReg()->next(7) );

  reg_def F6    ( SOC, SOC, Op_RegF, 6, F6->as_VMReg()          );
  reg_def F6_H  ( SOC, SOC, Op_RegF, 6, F6->as_VMReg()->next()  );
  reg_def F6_J  ( SOC, SOC, Op_RegF, 6, F6->as_VMReg()->next(2) );
  reg_def F6_K  ( SOC, SOC, Op_RegF, 6, F6->as_VMReg()->next(3) );
  reg_def F6_L  ( SOC, SOC, Op_RegF, 6, F6->as_VMReg()->next(4) );
  reg_def F6_M  ( SOC, SOC, Op_RegF, 6, F6->as_VMReg()->next(5) );
  reg_def F6_N  ( SOC, SOC, Op_RegF, 6, F6->as_VMReg()->next(6) );
  reg_def F6_O  ( SOC, SOC, Op_RegF, 6, F6->as_VMReg()->next(7) );

  reg_def F7    ( SOC, SOC, Op_RegF, 7, F7->as_VMReg()          );
  reg_def F7_H  ( SOC, SOC, Op_RegF, 7, F7->as_VMReg()->next()  );
  reg_def F7_J  ( SOC, SOC, Op_RegF, 7, F7->as_VMReg()->next(2) );
  reg_def F7_K  ( SOC, SOC, Op_RegF, 7, F7->as_VMReg()->next(3) );
  reg_def F7_L  ( SOC, SOC, Op_RegF, 7, F7->as_VMReg()->next(4) );
  reg_def F7_M  ( SOC, SOC, Op_RegF, 7, F7->as_VMReg()->next(5) );
  reg_def F7_N  ( SOC, SOC, Op_RegF, 7, F7->as_VMReg()->next(6) );
  reg_def F7_O  ( SOC, SOC, Op_RegF, 7, F7->as_VMReg()->next(7) );

  reg_def F8    ( SOC, SOC, Op_RegF, 8, F8->as_VMReg()          );
  reg_def F8_H  ( SOC, SOC, Op_RegF, 8, F8->as_VMReg()->next()  );
  reg_def F8_J  ( SOC, SOC, Op_RegF, 8, F8->as_VMReg()->next(2) );
  reg_def F8_K  ( SOC, SOC, Op_RegF, 8, F8->as_VMReg()->next(3) );
  reg_def F8_L  ( SOC, SOC, Op_RegF, 8, F8->as_VMReg()->next(4) );
  reg_def F8_M  ( SOC, SOC, Op_RegF, 8, F8->as_VMReg()->next(5) );
  reg_def F8_N  ( SOC, SOC, Op_RegF, 8, F8->as_VMReg()->next(6) );
  reg_def F8_O  ( SOC, SOC, Op_RegF, 8, F8->as_VMReg()->next(7) );

  reg_def F9    ( SOC, SOC, Op_RegF, 9, F9->as_VMReg()          );
  reg_def F9_H  ( SOC, SOC, Op_RegF, 9, F9->as_VMReg()->next()  );
  reg_def F9_J  ( SOC, SOC, Op_RegF, 9, F9->as_VMReg()->next(2) );
  reg_def F9_K  ( SOC, SOC, Op_RegF, 9, F9->as_VMReg()->next(3) );
  reg_def F9_L  ( SOC, SOC, Op_RegF, 9, F9->as_VMReg()->next(4) );
  reg_def F9_M  ( SOC, SOC, Op_RegF, 9, F9->as_VMReg()->next(5) );
  reg_def F9_N  ( SOC, SOC, Op_RegF, 9, F9->as_VMReg()->next(6) );
  reg_def F9_O  ( SOC, SOC, Op_RegF, 9, F9->as_VMReg()->next(7) );

  reg_def F10   ( SOC, SOC, Op_RegF, 10, F10->as_VMReg()          );
  reg_def F10_H ( SOC, SOC, Op_RegF, 10, F10->as_VMReg()->next()  );
  reg_def F10_J ( SOC, SOC, Op_RegF, 10, F10->as_VMReg()->next(2) );
  reg_def F10_K ( SOC, SOC, Op_RegF, 10, F10->as_VMReg()->next(3) );
  reg_def F10_L ( SOC, SOC, Op_RegF, 10, F10->as_VMReg()->next(4) );
  reg_def F10_M ( SOC, SOC, Op_RegF, 10, F10->as_VMReg()->next(5) );
  reg_def F10_N ( SOC, SOC, Op_RegF, 10, F10->as_VMReg()->next(6) );
  reg_def F10_O ( SOC, SOC, Op_RegF, 10, F10->as_VMReg()->next(7) );

  reg_def F11   ( SOC, SOC, Op_RegF, 11, F11->as_VMReg()          );
  reg_def F11_H ( SOC, SOC, Op_RegF, 11, F11->as_VMReg()->next()  );
  reg_def F11_J ( SOC, SOC, Op_RegF, 11, F11->as_VMReg()->next(2) );
  reg_def F11_K ( SOC, SOC, Op_RegF, 11, F11->as_VMReg()->next(3) );
  reg_def F11_L ( SOC, SOC, Op_RegF, 11, F11->as_VMReg()->next(4) );
  reg_def F11_M ( SOC, SOC, Op_RegF, 11, F11->as_VMReg()->next(5) );
  reg_def F11_N ( SOC, SOC, Op_RegF, 11, F11->as_VMReg()->next(6) );
  reg_def F11_O ( SOC, SOC, Op_RegF, 11, F11->as_VMReg()->next(7) );

  reg_def F12   ( SOC, SOC, Op_RegF, 12, F12->as_VMReg()          );
  reg_def F12_H ( SOC, SOC, Op_RegF, 12, F12->as_VMReg()->next()  );
  reg_def F12_J ( SOC, SOC, Op_RegF, 12, F12->as_VMReg()->next(2) );
  reg_def F12_K ( SOC, SOC, Op_RegF, 12, F12->as_VMReg()->next(3) );
  reg_def F12_L ( SOC, SOC, Op_RegF, 12, F12->as_VMReg()->next(4) );
  reg_def F12_M ( SOC, SOC, Op_RegF, 12, F12->as_VMReg()->next(5) );
  reg_def F12_N ( SOC, SOC, Op_RegF, 12, F12->as_VMReg()->next(6) );
  reg_def F12_O ( SOC, SOC, Op_RegF, 12, F12->as_VMReg()->next(7) );

  reg_def F13   ( SOC, SOC, Op_RegF, 13, F13->as_VMReg()          );
  reg_def F13_H ( SOC, SOC, Op_RegF, 13, F13->as_VMReg()->next()  );
  reg_def F13_J ( SOC, SOC, Op_RegF, 13, F13->as_VMReg()->next(2) );
  reg_def F13_K ( SOC, SOC, Op_RegF, 13, F13->as_VMReg()->next(3) );
  reg_def F13_L ( SOC, SOC, Op_RegF, 13, F13->as_VMReg()->next(4) );
  reg_def F13_M ( SOC, SOC, Op_RegF, 13, F13->as_VMReg()->next(5) );
  reg_def F13_N ( SOC, SOC, Op_RegF, 13, F13->as_VMReg()->next(6) );
  reg_def F13_O ( SOC, SOC, Op_RegF, 13, F13->as_VMReg()->next(7) );

  reg_def F14   ( SOC, SOC, Op_RegF, 14, F14->as_VMReg()          );
  reg_def F14_H ( SOC, SOC, Op_RegF, 14, F14->as_VMReg()->next()  );
  reg_def F14_J ( SOC, SOC, Op_RegF, 14, F14->as_VMReg()->next(2) );
  reg_def F14_K ( SOC, SOC, Op_RegF, 14, F14->as_VMReg()->next(3) );
  reg_def F14_L ( SOC, SOC, Op_RegF, 14, F14->as_VMReg()->next(4) );
  reg_def F14_M ( SOC, SOC, Op_RegF, 14, F14->as_VMReg()->next(5) );
  reg_def F14_N ( SOC, SOC, Op_RegF, 14, F14->as_VMReg()->next(6) );
  reg_def F14_O ( SOC, SOC, Op_RegF, 14, F14->as_VMReg()->next(7) );

  reg_def F15   ( SOC, SOC, Op_RegF, 15, F15->as_VMReg()          );
  reg_def F15_H ( SOC, SOC, Op_RegF, 15, F15->as_VMReg()->next()  );
  reg_def F15_J ( SOC, SOC, Op_RegF, 15, F15->as_VMReg()->next(2) );
  reg_def F15_K ( SOC, SOC, Op_RegF, 15, F15->as_VMReg()->next(3) );
  reg_def F15_L ( SOC, SOC, Op_RegF, 15, F15->as_VMReg()->next(4) );
  reg_def F15_M ( SOC, SOC, Op_RegF, 15, F15->as_VMReg()->next(5) );
  reg_def F15_N ( SOC, SOC, Op_RegF, 15, F15->as_VMReg()->next(6) );
  reg_def F15_O ( SOC, SOC, Op_RegF, 15, F15->as_VMReg()->next(7) );

  reg_def F16   ( SOC, SOC, Op_RegF, 16, F16->as_VMReg()          );
  reg_def F16_H ( SOC, SOC, Op_RegF, 16, F16->as_VMReg()->next()  );
  reg_def F16_J ( SOC, SOC, Op_RegF, 16, F16->as_VMReg()->next(2) );
  reg_def F16_K ( SOC, SOC, Op_RegF, 16, F16->as_VMReg()->next(3) );
  reg_def F16_L ( SOC, SOC, Op_RegF, 16, F16->as_VMReg()->next(4) );
  reg_def F16_M ( SOC, SOC, Op_RegF, 16, F16->as_VMReg()->next(5) );
  reg_def F16_N ( SOC, SOC, Op_RegF, 16, F16->as_VMReg()->next(6) );
  reg_def F16_O ( SOC, SOC, Op_RegF, 16, F16->as_VMReg()->next(7) );

  reg_def F17   ( SOC, SOC, Op_RegF, 17, F17->as_VMReg()          );
  reg_def F17_H ( SOC, SOC, Op_RegF, 17, F17->as_VMReg()->next()  );
  reg_def F17_J ( SOC, SOC, Op_RegF, 17, F17->as_VMReg()->next(2) );
  reg_def F17_K ( SOC, SOC, Op_RegF, 17, F17->as_VMReg()->next(3) );
  reg_def F17_L ( SOC, SOC, Op_RegF, 17, F17->as_VMReg()->next(4) );
  reg_def F17_M ( SOC, SOC, Op_RegF, 17, F17->as_VMReg()->next(5) );
  reg_def F17_N ( SOC, SOC, Op_RegF, 17, F17->as_VMReg()->next(6) );
  reg_def F17_O ( SOC, SOC, Op_RegF, 17, F17->as_VMReg()->next(7) );

  reg_def F18   ( SOC, SOC, Op_RegF, 18, F18->as_VMReg()          );
  reg_def F18_H ( SOC, SOC, Op_RegF, 18, F18->as_VMReg()->next()  );
  reg_def F18_J ( SOC, SOC, Op_RegF, 18, F18->as_VMReg()->next(2) );
  reg_def F18_K ( SOC, SOC, Op_RegF, 18, F18->as_VMReg()->next(3) );
  reg_def F18_L ( SOC, SOC, Op_RegF, 18, F18->as_VMReg()->next(4) );
  reg_def F18_M ( SOC, SOC, Op_RegF, 18, F18->as_VMReg()->next(5) );
  reg_def F18_N ( SOC, SOC, Op_RegF, 18, F18->as_VMReg()->next(6) );
  reg_def F18_O ( SOC, SOC, Op_RegF, 18, F18->as_VMReg()->next(7) );

  reg_def F19   ( SOC, SOC, Op_RegF, 19, F19->as_VMReg()          );
  reg_def F19_H ( SOC, SOC, Op_RegF, 19, F19->as_VMReg()->next()  );
  reg_def F19_J ( SOC, SOC, Op_RegF, 19, F19->as_VMReg()->next(2) );
  reg_def F19_K ( SOC, SOC, Op_RegF, 19, F19->as_VMReg()->next(3) );
  reg_def F19_L ( SOC, SOC, Op_RegF, 19, F19->as_VMReg()->next(4) );
  reg_def F19_M ( SOC, SOC, Op_RegF, 19, F19->as_VMReg()->next(5) );
  reg_def F19_N ( SOC, SOC, Op_RegF, 19, F19->as_VMReg()->next(6) );
  reg_def F19_O ( SOC, SOC, Op_RegF, 19, F19->as_VMReg()->next(7) );

  reg_def F20   ( SOC, SOC, Op_RegF, 20, F20->as_VMReg()          );
  reg_def F20_H ( SOC, SOC, Op_RegF, 20, F20->as_VMReg()->next()  );
  reg_def F20_J ( SOC, SOC, Op_RegF, 20, F20->as_VMReg()->next(2) );
  reg_def F20_K ( SOC, SOC, Op_RegF, 20, F20->as_VMReg()->next(3) );
  reg_def F20_L ( SOC, SOC, Op_RegF, 20, F20->as_VMReg()->next(4) );
  reg_def F20_M ( SOC, SOC, Op_RegF, 20, F20->as_VMReg()->next(5) );
  reg_def F20_N ( SOC, SOC, Op_RegF, 20, F20->as_VMReg()->next(6) );
  reg_def F20_O ( SOC, SOC, Op_RegF, 20, F20->as_VMReg()->next(7) );

  reg_def F21   ( SOC, SOC, Op_RegF, 21, F21->as_VMReg()          );
  reg_def F21_H ( SOC, SOC, Op_RegF, 21, F21->as_VMReg()->next()  );
  reg_def F21_J ( SOC, SOC, Op_RegF, 21, F21->as_VMReg()->next(2) );
  reg_def F21_K ( SOC, SOC, Op_RegF, 21, F21->as_VMReg()->next(3) );
  reg_def F21_L ( SOC, SOC, Op_RegF, 21, F21->as_VMReg()->next(4) );
  reg_def F21_M ( SOC, SOC, Op_RegF, 21, F21->as_VMReg()->next(5) );
  reg_def F21_N ( SOC, SOC, Op_RegF, 21, F21->as_VMReg()->next(6) );
  reg_def F21_O ( SOC, SOC, Op_RegF, 21, F21->as_VMReg()->next(7) );

  reg_def F22   ( SOC, SOC, Op_RegF, 22, F22->as_VMReg()          );
  reg_def F22_H ( SOC, SOC, Op_RegF, 22, F22->as_VMReg()->next()  );
  reg_def F22_J ( SOC, SOC, Op_RegF, 22, F22->as_VMReg()->next(2) );
  reg_def F22_K ( SOC, SOC, Op_RegF, 22, F22->as_VMReg()->next(3) );
  reg_def F22_L ( SOC, SOC, Op_RegF, 22, F22->as_VMReg()->next(4) );
  reg_def F22_M ( SOC, SOC, Op_RegF, 22, F22->as_VMReg()->next(5) );
  reg_def F22_N ( SOC, SOC, Op_RegF, 22, F22->as_VMReg()->next(6) );
  reg_def F22_O ( SOC, SOC, Op_RegF, 22, F22->as_VMReg()->next(7) );

  reg_def F23   ( SOC, SOC, Op_RegF, 23, F23->as_VMReg()          );
  reg_def F23_H ( SOC, SOC, Op_RegF, 23, F23->as_VMReg()->next()  );
  reg_def F23_J ( SOC, SOC, Op_RegF, 23, F23->as_VMReg()->next(2) );
  reg_def F23_K ( SOC, SOC, Op_RegF, 23, F23->as_VMReg()->next(3) );
  reg_def F23_L ( SOC, SOC, Op_RegF, 23, F23->as_VMReg()->next(4) );
  reg_def F23_M ( SOC, SOC, Op_RegF, 23, F23->as_VMReg()->next(5) );
  reg_def F23_N ( SOC, SOC, Op_RegF, 23, F23->as_VMReg()->next(6) );
  reg_def F23_O ( SOC, SOC, Op_RegF, 23, F23->as_VMReg()->next(7) );

  reg_def F24   ( SOC, SOE, Op_RegF, 24, F24->as_VMReg()          );
  reg_def F24_H ( SOC, SOE, Op_RegF, 24, F24->as_VMReg()->next()  );
  reg_def F24_J ( SOC, SOC, Op_RegF, 24, F24->as_VMReg()->next(2) );
  reg_def F24_K ( SOC, SOC, Op_RegF, 24, F24->as_VMReg()->next(3) );
  reg_def F24_L ( SOC, SOC, Op_RegF, 24, F24->as_VMReg()->next(4) );
  reg_def F24_M ( SOC, SOC, Op_RegF, 24, F24->as_VMReg()->next(5) );
  reg_def F24_N ( SOC, SOC, Op_RegF, 24, F24->as_VMReg()->next(6) );
  reg_def F24_O ( SOC, SOC, Op_RegF, 24, F24->as_VMReg()->next(7) );

  reg_def F25   ( SOC, SOE, Op_RegF, 25, F25->as_VMReg()          );
  reg_def F25_H ( SOC, SOE, Op_RegF, 25, F25->as_VMReg()->next()  );
  reg_def F25_J ( SOC, SOC, Op_RegF, 25, F25->as_VMReg()->next(2) );
  reg_def F25_K ( SOC, SOC, Op_RegF, 25, F25->as_VMReg()->next(3) );
  reg_def F25_L ( SOC, SOC, Op_RegF, 25, F25->as_VMReg()->next(4) );
  reg_def F25_M ( SOC, SOC, Op_RegF, 25, F25->as_VMReg()->next(5) );
  reg_def F25_N ( SOC, SOC, Op_RegF, 25, F25->as_VMReg()->next(6) );
  reg_def F25_O ( SOC, SOC, Op_RegF, 25, F25->as_VMReg()->next(7) );

  reg_def F26   ( SOC, SOE, Op_RegF, 26, F26->as_VMReg()          );
  reg_def F26_H ( SOC, SOE, Op_RegF, 26, F26->as_VMReg()->next()  );
  reg_def F26_J ( SOC, SOC, Op_RegF, 26, F26->as_VMReg()->next(2) );
  reg_def F26_K ( SOC, SOC, Op_RegF, 26, F26->as_VMReg()->next(3) );
  reg_def F26_L ( SOC, SOC, Op_RegF, 26, F26->as_VMReg()->next(4) );
  reg_def F26_M ( SOC, SOC, Op_RegF, 26, F26->as_VMReg()->next(5) );
  reg_def F26_N ( SOC, SOC, Op_RegF, 26, F26->as_VMReg()->next(6) );
  reg_def F26_O ( SOC, SOC, Op_RegF, 26, F26->as_VMReg()->next(7) );

  reg_def F27   ( SOC, SOE, Op_RegF, 27, F27->as_VMReg()          );
  reg_def F27_H ( SOC, SOE, Op_RegF, 27, F27->as_VMReg()->next()  );
  reg_def F27_J ( SOC, SOC, Op_RegF, 27, F27->as_VMReg()->next(2) );
  reg_def F27_K ( SOC, SOC, Op_RegF, 27, F27->as_VMReg()->next(3) );
  reg_def F27_L ( SOC, SOC, Op_RegF, 27, F27->as_VMReg()->next(4) );
  reg_def F27_M ( SOC, SOC, Op_RegF, 27, F27->as_VMReg()->next(5) );
  reg_def F27_N ( SOC, SOC, Op_RegF, 27, F27->as_VMReg()->next(6) );
  reg_def F27_O ( SOC, SOC, Op_RegF, 27, F27->as_VMReg()->next(7) );

  reg_def F28   ( SOC, SOE, Op_RegF, 28, F28->as_VMReg()          );
  reg_def F28_H ( SOC, SOE, Op_RegF, 28, F28->as_VMReg()->next()  );
  reg_def F28_J ( SOC, SOC, Op_RegF, 28, F28->as_VMReg()->next(2) );
  reg_def F28_K ( SOC, SOC, Op_RegF, 28, F28->as_VMReg()->next(3) );
  reg_def F28_L ( SOC, SOC, Op_RegF, 28, F28->as_VMReg()->next(4) );
  reg_def F28_M ( SOC, SOC, Op_RegF, 28, F28->as_VMReg()->next(5) );
  reg_def F28_N ( SOC, SOC, Op_RegF, 28, F28->as_VMReg()->next(6) );
  reg_def F28_O ( SOC, SOC, Op_RegF, 28, F28->as_VMReg()->next(7) );

  reg_def F29   ( SOC, SOE, Op_RegF, 29, F29->as_VMReg()          );
  reg_def F29_H ( SOC, SOE, Op_RegF, 29, F29->as_VMReg()->next()  );
  reg_def F29_J ( SOC, SOC, Op_RegF, 29, F29->as_VMReg()->next(2) );
  reg_def F29_K ( SOC, SOC, Op_RegF, 29, F29->as_VMReg()->next(3) );
  reg_def F29_L ( SOC, SOC, Op_RegF, 29, F29->as_VMReg()->next(4) );
  reg_def F29_M ( SOC, SOC, Op_RegF, 29, F29->as_VMReg()->next(5) );
  reg_def F29_N ( SOC, SOC, Op_RegF, 29, F29->as_VMReg()->next(6) );
  reg_def F29_O ( SOC, SOC, Op_RegF, 29, F29->as_VMReg()->next(7) );

  reg_def F30   ( SOC, SOE, Op_RegF, 30, F30->as_VMReg()          );
  reg_def F30_H ( SOC, SOE, Op_RegF, 30, F30->as_VMReg()->next()  );
  reg_def F30_J ( SOC, SOC, Op_RegF, 30, F30->as_VMReg()->next(2) );
  reg_def F30_K ( SOC, SOC, Op_RegF, 30, F30->as_VMReg()->next(3) );
  reg_def F30_L ( SOC, SOC, Op_RegF, 30, F30->as_VMReg()->next(4) );
  reg_def F30_M ( SOC, SOC, Op_RegF, 30, F30->as_VMReg()->next(5) );
  reg_def F30_N ( SOC, SOC, Op_RegF, 30, F30->as_VMReg()->next(6) );
  reg_def F30_O ( SOC, SOC, Op_RegF, 30, F30->as_VMReg()->next(7) );

  reg_def F31   ( SOC, SOE, Op_RegF, 31, F31->as_VMReg()          );
  reg_def F31_H ( SOC, SOE, Op_RegF, 31, F31->as_VMReg()->next()  );
  reg_def F31_J ( SOC, SOC, Op_RegF, 31, F31->as_VMReg()->next(2) );
  reg_def F31_K ( SOC, SOC, Op_RegF, 31, F31->as_VMReg()->next(3) );
  reg_def F31_L ( SOC, SOC, Op_RegF, 31, F31->as_VMReg()->next(4) );
  reg_def F31_M ( SOC, SOC, Op_RegF, 31, F31->as_VMReg()->next(5) );
  reg_def F31_N ( SOC, SOC, Op_RegF, 31, F31->as_VMReg()->next(6) );
  reg_def F31_O ( SOC, SOC, Op_RegF, 31, F31->as_VMReg()->next(7) );


// ----------------------------
// Special Registers
//S6 is used for get_thread(S6)
//S5 is used for heapbase of compressed oop
alloc_class chunk0(
                     // volatiles
                     T0, T0_H,
                     T1, T1_H,
                     T2, T2_H,
                     T3, T3_H,
                     T4, T4_H,
                     T5, T5_H,
                     T6, T6_H,
                     T8, T8_H,

                     // args
                     A7, A7_H,
                     A6, A6_H,
                     A5, A5_H,
                     A4, A4_H,
                     A3, A3_H,
                     A2, A2_H,
                     A1, A1_H,
                     A0, A0_H,

                     // non-volatiles
                     S0, S0_H,
                     S1, S1_H,
                     S2, S2_H,
                     S3, S3_H,
                     S4, S4_H,
                     S5, S5_H,
                     S6, S6_H,
                     S7, S7_H,
                     S8, S8_H

                     // non-allocatable registers
                     RA, RA_H,
                     SP, SP_H, // stack_pointer
                     FP, FP_H, // frame_pointer
                     T7, T7_H, // rscratch
                     TP, TP_H,
                     RX, RX_H,
                     R0, R0_H,
                 );

// F23 is scratch reg
alloc_class chunk1(

                     // no save
                     F8, F8_H, F8_J, F8_K, F8_L, F8_M, F8_N, F8_O,
                     F9, F9_H, F9_J, F9_K, F9_L, F9_M, F9_N, F9_O,
                     F10, F10_H, F10_J, F10_K, F10_L, F10_M, F10_N, F10_O,
                     F11, F11_H, F11_J, F11_K, F11_L, F11_M, F11_N, F11_O,
                     F12, F12_H, F12_J, F12_K, F12_L, F12_M, F12_N, F12_O,
                     F13, F13_H, F13_J, F13_K, F13_L, F13_M, F13_N, F13_O,
                     F14, F14_H, F14_J, F14_K, F14_L, F14_M, F14_N, F14_O,
                     F15, F15_H, F15_J, F15_K, F15_L, F15_M, F15_N, F15_O,
                     F16, F16_H, F16_J, F16_K, F16_L, F16_M, F16_N, F16_O,
                     F17, F17_H, F17_J, F17_K, F17_L, F17_M, F17_N, F17_O,
                     F18, F18_H, F18_J, F18_K, F18_L, F18_M, F18_N, F18_O,
                     F19, F19_H, F19_J, F19_K, F19_L, F19_M, F19_N, F19_O,
                     F20, F20_H, F20_J, F20_K, F20_L, F20_M, F20_N, F20_O,
                     F21, F21_H, F21_J, F21_K, F21_L, F21_M, F21_N, F21_O,
                     F22, F22_H, F22_J, F22_K, F22_L, F22_M, F22_N, F22_O,

                     // arg registers
                     F0, F0_H, F0_J, F0_K, F0_L, F0_M, F0_N, F0_O,
                     F1, F1_H, F1_J, F1_K, F1_L, F1_M, F1_N, F1_O,
                     F2, F2_H, F2_J, F2_K, F2_L, F2_M, F2_N, F2_O,
                     F3, F3_H, F3_J, F3_K, F3_L, F3_M, F3_N, F3_O,
                     F4, F4_H, F4_J, F4_K, F4_L, F4_M, F4_N, F4_O,
                     F5, F5_H, F5_J, F5_K, F5_L, F5_M, F5_N, F5_O,
                     F6, F6_H, F6_J, F6_K, F6_L, F6_M, F6_N, F6_O,
                     F7, F7_H, F7_J, F7_K, F7_L, F7_M, F7_N, F7_O,

                     // non-volatiles
                     F24, F24_H, F24_J, F24_K, F24_L, F24_M, F24_N, F24_O,
                     F25, F25_H, F25_J, F25_K, F25_L, F25_M, F25_N, F25_O,
                     F26, F26_H, F26_J, F26_K, F26_L, F26_M, F26_N, F26_O,
                     F27, F27_H, F27_J, F27_K, F27_L, F27_M, F27_N, F27_O,
                     F28, F28_H, F28_J, F28_K, F28_L, F28_M, F28_N, F28_O,
                     F29, F29_H, F29_J, F29_K, F29_L, F29_M, F29_N, F29_O,
                     F30, F30_H, F30_J, F30_K, F30_L, F30_M, F30_N, F30_O,
                     F31, F31_H, F31_J, F31_K, F31_L, F31_M, F31_N, F31_O,

                     // non-allocatable registers
                     F23, F23_H, F23_J, F23_K, F23_L, F23_M, F23_N, F23_O,
                  );

reg_class s_reg( S0, S1, S2, S3, S4, S5, S6, S7 );
reg_class s0_reg( S0 );
reg_class s1_reg( S1 );
reg_class s2_reg( S2 );
reg_class s3_reg( S3 );
reg_class s4_reg( S4 );
reg_class s5_reg( S5 );
reg_class s6_reg( S6 );
reg_class s7_reg( S7 );

reg_class t_reg( T0, T1, T2, T3, T8, T4 );
reg_class t0_reg( T0 );
reg_class t1_reg( T1 );
reg_class t2_reg( T2 );
reg_class t3_reg( T3 );
reg_class t8_reg( T8 );
reg_class t4_reg( T4 );

reg_class a_reg( A0, A1, A2, A3, A4, A5, A6, A7 );
reg_class a0_reg( A0 );
reg_class a1_reg( A1 );
reg_class a2_reg( A2 );
reg_class a3_reg( A3 );
reg_class a4_reg( A4 );
reg_class a5_reg( A5 );
reg_class a6_reg( A6 );
reg_class a7_reg( A7 );

// TODO: LA
//reg_class v0_reg( A0 );
//reg_class v1_reg( A1 );

reg_class sp_reg( SP, SP_H );
reg_class fp_reg( FP, FP_H );

reg_class v0_long_reg( A0, A0_H );
reg_class v1_long_reg( A1, A1_H );
reg_class a0_long_reg( A0, A0_H );
reg_class a1_long_reg( A1, A1_H );
reg_class a2_long_reg( A2, A2_H );
reg_class a3_long_reg( A3, A3_H );
reg_class a4_long_reg( A4, A4_H );
reg_class a5_long_reg( A5, A5_H );
reg_class a6_long_reg( A6, A6_H );
reg_class a7_long_reg( A7, A7_H );
reg_class t0_long_reg( T0, T0_H );
reg_class t1_long_reg( T1, T1_H );
reg_class t2_long_reg( T2, T2_H );
reg_class t3_long_reg( T3, T3_H );
reg_class t8_long_reg( T8, T8_H );
reg_class t4_long_reg( T4, T4_H );
reg_class s0_long_reg( S0, S0_H );
reg_class s1_long_reg( S1, S1_H );
reg_class s2_long_reg( S2, S2_H );
reg_class s3_long_reg( S3, S3_H );
reg_class s4_long_reg( S4, S4_H );
reg_class s5_long_reg( S5, S5_H );
reg_class s6_long_reg( S6, S6_H );
reg_class s7_long_reg( S7, S7_H );

reg_class all_reg32(
                     S8,
                     S7,
                     S5, /* S5_heapbase */
                  /* S6, S6 TREG     */
                     S4,
                     S3,
                     S2,
                     S1,
                     S0,
                     T8,
                  /* T7,  AT */
                     T6,
                     T5,
                     T4,
                     T3,
                     T2,
                     T1,
                     T0,
                     A7,
                     A6,
                     A5,
                     A4,
                     A3,
                     A2,
                     A1,
                     A0,
                     FP );

reg_class int_reg %{
  return _ANY_REG32_mask;
%}

reg_class p_reg %{
  return _PTR_REG_mask;
%}

reg_class no_CR_reg %{
  return _NO_CR_REG_mask;
%}

reg_class p_has_s6_reg %{
  return _PTR_HAS_S6_REG_mask;
%}

reg_class all_reg(
                    S8, S8_H,
                    S7, S7_H,
                 /* S6, S6_H,  S6 TREG     */
                    S5, S5_H, /* S5_heapbase */
                    S4, S4_H,
                    S3, S3_H,
                    S2, S2_H,
                    S1, S1_H,
                    S0, S0_H,
                    T8, T8_H,
                 /* T7, T7_H,  AT */
                    T6, T6_H,
                    T5, T5_H,
                    T4, T4_H,
                    T3, T3_H,
                    T2, T2_H,
                    T1, T1_H,
                    T0, T0_H,
                    A7, A7_H,
                    A6, A6_H,
                    A5, A5_H,
                    A4, A4_H,
                    A3, A3_H,
                    A2, A2_H,
                    A1, A1_H,
                    A0, A0_H,
                    FP, FP_H
                  );


reg_class long_reg %{
  return _ANY_REG_mask;
%}

// Floating point registers.
// F31 are not used as temporary registers in D2I
reg_class flt_reg( F0, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22, F24, F25, F26, F27, F28, F29, F30, F31);

reg_class dbl_reg( F0, F0_H,
                   F1, F1_H,
                   F2, F2_H,
                   F3, F3_H,
                   F4, F4_H,
                   F5, F5_H,
                   F6, F6_H,
                   F7, F7_H,
                   F8, F8_H,
                   F9, F9_H,
                   F10, F10_H,
                   F11, F11_H,
                   F12, F12_H,
                   F13, F13_H,
                   F14, F14_H,
                   F15, F15_H,
                   F16, F16_H,
                   F17, F17_H,
                   F18, F18_H,
                   F19, F19_H,
                   F20, F20_H,
                   F21, F21_H,
                   F22, F22_H,
                   F24, F24_H,
                   F25, F25_H,
                   F26, F26_H,
                   F27, F27_H,
                   F28, F28_H,
                   F29, F29_H,
                   F30, F30_H,
                   F31, F31_H);

// Class for all 128bit vector registers
reg_class vectorx_reg(  F0, F0_H, F0_J, F0_K,
                        F1, F1_H, F1_J, F1_K,
                        F2, F2_H, F2_J, F2_K,
                        F3, F3_H, F3_J, F3_K,
                        F4, F4_H, F4_J, F4_K,
                        F5, F5_H, F5_J, F5_K,
                        F6, F6_H, F6_J, F6_K,
                        F7, F7_H, F7_J, F7_K,
                        F8, F8_H, F8_J, F8_K,
                        F9, F9_H, F9_J, F9_K,
                        F10, F10_H, F10_J, F10_K,
                        F11, F11_H, F11_J, F11_K,
                        F12, F12_H, F12_J, F12_K,
                        F13, F13_H, F13_J, F13_K,
                        F14, F14_H, F14_J, F14_K,
                        F15, F15_H, F15_J, F15_K,
                        F16, F16_H, F16_J, F16_K,
                        F17, F17_H, F17_J, F17_K,
                        F18, F18_H, F18_J, F18_K,
                        F19, F19_H, F19_J, F19_K,
                        F20, F20_H, F20_J, F20_K,
                        F21, F21_H, F21_J, F21_K,
                        F22, F22_H, F22_J, F22_K,
                        F24, F24_H, F24_J, F24_K,
                        F25, F25_H, F25_J, F25_K,
                        F26, F26_H, F26_J, F26_K,
                        F27, F27_H, F27_J, F27_K,
                        F28, F28_H, F28_J, F28_K,
                        F29, F29_H, F29_J, F29_K,
                        F30, F30_H, F30_J, F30_K,
                        F31, F31_H, F31_J, F31_K);

// Class for all 256bit vector registers
reg_class vectory_reg(  F0, F0_H, F0_J, F0_K, F0_L, F0_M, F0_N, F0_O,
                        F1, F1_H, F1_J, F1_K, F1_L, F1_M, F1_N, F1_O,
                        F2, F2_H, F2_J, F2_K, F2_L, F2_M, F2_N, F2_O,
                        F3, F3_H, F3_J, F3_K, F3_L, F3_M, F3_N, F3_O,
                        F4, F4_H, F4_J, F4_K, F4_L, F4_M, F4_N, F4_O,
                        F5, F5_H, F5_J, F5_K, F5_L, F5_M, F5_N, F5_O,
                        F6, F6_H, F6_J, F6_K, F6_L, F6_M, F6_N, F6_O,
                        F7, F7_H, F7_J, F7_K, F7_L, F7_M, F7_N, F7_O,
                        F8, F8_H, F8_J, F8_K, F8_L, F8_M, F8_N, F8_O,
                        F9, F9_H, F9_J, F9_K, F9_L, F9_M, F9_N, F9_O,
                        F10, F10_H, F10_J, F10_K, F10_L, F10_M, F10_N, F10_O,
                        F11, F11_H, F11_J, F11_K, F11_L, F11_M, F11_N, F11_O,
                        F12, F12_H, F12_J, F12_K, F12_L, F12_M, F12_N, F12_O,
                        F13, F13_H, F13_J, F13_K, F13_L, F13_M, F13_N, F13_O,
                        F14, F14_H, F14_J, F14_K, F14_L, F14_M, F14_N, F14_O,
                        F15, F15_H, F15_J, F15_K, F15_L, F15_M, F15_N, F15_O,
                        F16, F16_H, F16_J, F16_K, F16_L, F16_M, F16_N, F16_O,
                        F17, F17_H, F17_J, F17_K, F17_L, F17_M, F17_N, F17_O,
                        F18, F18_H, F18_J, F18_K, F18_L, F18_M, F18_N, F18_O,
                        F19, F19_H, F19_J, F19_K, F19_L, F19_M, F19_N, F19_O,
                        F20, F20_H, F20_J, F20_K, F20_L, F20_M, F20_N, F20_O,
                        F21, F21_H, F21_J, F21_K, F21_L, F21_M, F21_N, F21_O,
                        F22, F22_H, F22_J, F22_K, F22_L, F22_M, F22_N, F22_O,
                        F24, F24_H, F24_J, F24_K, F24_L, F24_M, F24_N, F24_O,
                        F25, F25_H, F25_J, F25_K, F25_L, F25_M, F25_N, F25_O,
                        F26, F26_H, F26_J, F26_K, F26_L, F26_M, F26_N, F26_O,
                        F27, F27_H, F27_J, F27_K, F27_L, F27_M, F27_N, F27_O,
                        F28, F28_H, F28_J, F28_K, F28_L, F28_M, F28_N, F28_O,
                        F29, F29_H, F29_J, F29_K, F29_L, F29_M, F29_N, F29_O,
                        F30, F30_H, F30_J, F30_K, F30_L, F30_M, F30_N, F30_O,
                        F31, F31_H, F31_J, F31_K, F31_L, F31_M, F31_N, F31_O);

// TODO: LA
//reg_class flt_arg0( F0 );
//reg_class dbl_arg0( F0, F0_H );
//reg_class dbl_arg1( F1, F1_H );

%}

//----------DEFINITION BLOCK---------------------------------------------------
// Define name --> value mappings to inform the ADLC of an integer valued name
// Current support includes integer values in the range [0, 0x7FFFFFFF]
// Format:
//        int_def  <name>         ( <int_value>, <expression>);
// Generated Code in ad_<arch>.hpp
//        #define  <name>   (<expression>)
//        // value == <int_value>
// Generated code in ad_<arch>.cpp adlc_verification()
//        assert( <name> == <int_value>, "Expect (<expression>) to equal <int_value>");
//
definitions %{
  int_def DEFAULT_COST      (    100,     100);
  int_def HUGE_COST         (1000000, 1000000);

  // Memory refs are twice as expensive as run-of-the-mill.
  int_def MEMORY_REF_COST   (    200, DEFAULT_COST * 2);

  // Branches are even more expensive.
  int_def BRANCH_COST       (    300, DEFAULT_COST * 3);
  // we use jr instruction to construct call, so more expensive
  int_def CALL_COST         (    500, DEFAULT_COST * 5);
/*
        int_def EQUAL             (   1, 1  );
        int_def NOT_EQUAL         (   2, 2  );
        int_def GREATER           (   3, 3  );
        int_def GREATER_EQUAL     (   4, 4  );
        int_def LESS              (   5, 5  );
        int_def LESS_EQUAL        (   6, 6  );
*/
%}



//----------SOURCE BLOCK-------------------------------------------------------
// This is a block of C++ code which provides values, functions, and
// definitions necessary in the rest of the architecture description

source_hpp %{
// Header information of the source block.
// Method declarations/definitions which are used outside
// the ad-scope can conveniently be defined here.
//
// To keep related declarations/definitions/uses close together,
// we switch between source %{ }% and source_hpp %{ }% freely as needed.

#include "asm/macroAssembler.hpp"
#include "gc/shared/barrierSetAssembler.hpp"
#include "gc/shared/cardTable.hpp"
#include "gc/shared/cardTableBarrierSet.hpp"
#include "gc/shared/collectedHeap.hpp"
#include "opto/addnode.hpp"
#include "opto/convertnode.hpp"
#include "runtime/objectMonitor.hpp"

extern RegMask _ANY_REG32_mask;
extern RegMask _ANY_REG_mask;
extern RegMask _PTR_REG_mask;
extern RegMask _NO_CR_REG_mask;
extern RegMask _PTR_HAS_S6_REG_mask;

class CallStubImpl {

  //--------------------------------------------------------------
  //---<  Used for optimization in Compile::shorten_branches  >---
  //--------------------------------------------------------------

 public:
  // Size of call trampoline stub.
  static uint size_call_trampoline() {
    return 0; // no call trampolines on this platform
  }

  // number of relocations needed by a call trampoline stub
  static uint reloc_call_trampoline() {
    return 0; // no call trampolines on this platform
  }
};

class HandlerImpl {

 public:

  static int emit_exception_handler(CodeBuffer &cbuf);
  static int emit_deopt_handler(CodeBuffer& cbuf);

  static uint size_exception_handler() {
    // NativeCall instruction size is the same as NativeJump.
    // exception handler starts out as jump and can be patched to
    // a call be deoptimization.  (4932387)
    // Note that this value is also credited (in output.cpp) to
    // the size of the code section.
    int size = NativeFarCall::instruction_size;
    const uintx m = 16 - 1;
    return mask_bits(size + m, ~m);
    //return round_to(size, 16);
  }

  static uint size_deopt_handler() {
    int size = NativeFarCall::instruction_size;
    const uintx m = 16 - 1;
    return mask_bits(size + m, ~m);
    //return round_to(size, 16);
  }
};

class Node::PD {
public:
  enum NodeFlags {
    _last_flag = Node::_last_flag
  };
};

bool is_CAS(int opcode);
bool use_AMO(int opcode);

bool unnecessary_acquire(const Node *barrier);
bool unnecessary_release(const Node *barrier);
bool unnecessary_volatile(const Node *barrier);
bool needs_releasing_store(const Node *store);

%} // end source_hpp

source %{

#define   NO_INDEX    0
#define   RELOC_IMM64    Assembler::imm_operand
#define   RELOC_DISP32   Assembler::disp32_operand

#define V0_num    A0_num
#define V0_H_num  A0_H_num

#define __ _masm.

RegMask _ANY_REG32_mask;
RegMask _ANY_REG_mask;
RegMask _PTR_REG_mask;
RegMask _NO_CR_REG_mask;
RegMask _PTR_HAS_S6_REG_mask;

void reg_mask_init() {
  _ANY_REG32_mask = _ALL_REG32_mask;
  _ANY_REG_mask = _ALL_REG_mask;
  _PTR_REG_mask = _ALL_REG_mask;
  _PTR_HAS_S6_REG_mask = _ALL_REG_mask;

  if (UseCompressedOops && (CompressedOops::ptrs_base() != nullptr)) {
    _ANY_REG32_mask.Remove(OptoReg::as_OptoReg(r28->as_VMReg()));
    _ANY_REG_mask.SUBTRACT(_S5_LONG_REG_mask);
    _PTR_REG_mask.SUBTRACT(_S5_LONG_REG_mask);
  }

  // FP(r22) is not allocatable when PreserveFramePointer is on
  if (PreserveFramePointer) {
    _ANY_REG32_mask.Remove(OptoReg::as_OptoReg(r22->as_VMReg()));
    _ANY_REG_mask.SUBTRACT(_FP_REG_mask);
    _PTR_REG_mask.SUBTRACT(_FP_REG_mask);
  }

#if INCLUDE_ZGC || INCLUDE_SHENANDOAHGC
  if (UseZGC || UseShenandoahGC) {
    _ANY_REG32_mask.Remove(OptoReg::as_OptoReg(r16->as_VMReg()));
    _ANY_REG_mask.SUBTRACT(_T4_LONG_REG_mask);
    _PTR_REG_mask.SUBTRACT(_T4_LONG_REG_mask);
  }
#endif

  _NO_CR_REG_mask = _PTR_REG_mask;
  _NO_CR_REG_mask.SUBTRACT(_T0_LONG_REG_mask);

  _PTR_HAS_S6_REG_mask.OR(_S6_LONG_REG_mask);
}

void PhaseOutput::pd_perform_mach_node_analysis() {
}

int MachNode::pd_alignment_required() const {
  return 1;
}

int MachNode::compute_padding(int current_offset) const {
  return 0;
}

// Emit exception handler code.
// Stuff framesize into a register and call a VM stub routine.
int HandlerImpl::emit_exception_handler(CodeBuffer& cbuf) {
  // Note that the code buffer's insts_mark is always relative to insts.
  // That's why we must use the macroassembler to generate a handler.
  C2_MacroAssembler _masm(&cbuf);
  address base = __ start_a_stub(size_exception_handler());
  if (base == nullptr) {
    ciEnv::current()->record_failure("CodeCache is full");
    return 0;  // CodeBuffer::expand failed
  }

  int offset = __ offset();

  __ block_comment("; emit_exception_handler");

  cbuf.set_insts_mark();
  __ relocate(relocInfo::runtime_call_type);
  __ patchable_jump((address)OptoRuntime::exception_blob()->entry_point());
  assert(__ offset() - offset <= (int) size_exception_handler(), "overflow");
  __ end_a_stub();
  return offset;
}

// Emit deopt handler code.
int HandlerImpl::emit_deopt_handler(CodeBuffer& cbuf) {
  // Note that the code buffer's insts_mark is always relative to insts.
  // That's why we must use the macroassembler to generate a handler.
  C2_MacroAssembler _masm(&cbuf);
  address base = __ start_a_stub(size_deopt_handler());
  if (base == nullptr) {
    ciEnv::current()->record_failure("CodeCache is full");
    return 0;  // CodeBuffer::expand failed
  }

  int offset = __ offset();

  __ block_comment("; emit_deopt_handler");

  cbuf.set_insts_mark();
  __ relocate(relocInfo::runtime_call_type);
  __ patchable_call(SharedRuntime::deopt_blob()->unpack());
  assert(__ offset() - offset <= (int) size_deopt_handler(), "overflow");
  __ end_a_stub();
  return offset;
}


const bool Matcher::match_rule_supported(int opcode) {
  if (!has_match_rule(opcode))
    return false;

  switch (opcode) {
    case Op_RoundDoubleMode:
    case Op_ConvF2HF:
    case Op_ConvHF2F:
    case Op_StrInflatedCopy:
    case Op_StrCompressedCopy:
    case Op_EncodeISOArray:
      if (!UseLSX)
        return false;
    case Op_PopCountI:
    case Op_PopCountL:
      return UsePopCountInstruction;
    case Op_CompareAndSwapB:
    case Op_CompareAndSwapS:
    case Op_CompareAndExchangeB:
    case Op_CompareAndExchangeS:
    case Op_WeakCompareAndSwapB:
    case Op_WeakCompareAndSwapS:
      if (!UseAMCAS)
        return false;
    case Op_GetAndSetB:
    case Op_GetAndSetS:
    case Op_GetAndAddB:
    case Op_GetAndAddS:
      if (!UseAMBH)
        return false;
    default:
      break;
  }

  return true;  // Per default match rules are supported.
}

const bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {
  return match_rule_supported_vector(opcode, vlen, bt);
}

const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {
  if (!match_rule_supported(opcode) || !vector_size_supported(bt, vlen))
    return false;

  switch (opcode) {
    case Op_RotateRightV:
    case Op_RotateLeftV:
      if (bt != T_INT && bt != T_LONG) {
        return false;
      }
      break;
    case Op_MaxReductionV:
    case Op_MinReductionV:
      if (bt == T_FLOAT || bt == T_DOUBLE) {
        return false;
      }
      break;
    case Op_VectorLoadShuffle:
      if (vlen < 4 || !UseLASX)
        return false;
      break;
    case Op_VectorCastB2X:
    case Op_VectorCastS2X:
    case Op_VectorCastI2X:
    case Op_VectorCastL2X:
    case Op_VectorCastF2X:
    case Op_VectorCastD2X:
    case Op_VectorLoadMask:
    case Op_VectorMaskCast:
      if (!UseLASX)
        return false;
      break;
    case Op_VectorTest:
      if (vlen * type2aelembytes(bt) < 16)
        return false;
      break;
    default:
      break;
  }

  return true;
}

const bool Matcher::match_rule_supported_vector_masked(int opcode, int vlen, BasicType bt) {
  return false;
}

// Vector calling convention not yet implemented.
const bool Matcher::supports_vector_calling_convention(void) {
  return false;
}

OptoRegPair Matcher::vector_return_value(uint ideal_reg) {
  Unimplemented();
  return OptoRegPair(0, 0);
}

bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
  const int safety_zone = 3 * BytesPerInstWord;
  int offs = offset - br_size + 4;
  // To be conservative on LoongArch
  // branch node should be end with:
  //   branch inst
  offs = (offs < 0 ? offs - safety_zone : offs + safety_zone) >> 2;
  switch (rule) {
    case jmpDir_long_rule:
    case jmpDir_short_rule:
      return Assembler::is_simm(offs, 26);
    case jmpCon_flags_long_rule:
    case jmpCon_flags_short_rule:
    case branchConP_0_long_rule:
    case branchConP_0_short_rule:
    case branchConN2P_0_long_rule:
    case branchConN2P_0_short_rule:
    case cmpN_null_branch_long_rule:
    case cmpN_null_branch_short_rule:
    case branchConF_reg_reg_long_rule:
    case branchConF_reg_reg_short_rule:
    case branchConD_reg_reg_long_rule:
    case branchConD_reg_reg_short_rule:
    case partialSubtypeCheckVsZero_long_rule:
    case partialSubtypeCheckVsZero_short_rule:
      return Assembler::is_simm(offs, 21);
    default:
      return Assembler::is_simm(offs, 16);
  }
  return false;
}

MachOper* Matcher::pd_specialize_generic_vector_operand(MachOper* generic_opnd, uint ideal_reg, bool is_temp) {
  assert(Matcher::is_generic_vector(generic_opnd), "not generic");
  switch (ideal_reg) {
    case Op_VecS: return new vecSOper();
    case Op_VecD: return new vecDOper();
    case Op_VecX: return new vecXOper();
    case Op_VecY: return new vecYOper();
  }
  ShouldNotReachHere();
  return nullptr;
}

bool Matcher::is_reg2reg_move(MachNode* m) {
  return false;
}

bool Matcher::is_generic_vector(MachOper* opnd)  {
  return opnd->opcode() == VREG;
}

const bool Matcher::vector_needs_partial_operations(Node* node, const TypeVect* vt) {
  return false;
}

const RegMask* Matcher::predicate_reg_mask(void) {
  return nullptr;
}

const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {
  return nullptr;
}

const int Matcher::scalable_vector_reg_size(const BasicType bt) {
  return -1;
}

const int Matcher::superword_max_vector_size(const BasicType bt) {
  return Matcher::max_vector_size(bt);
}

// Vector ideal reg
const uint Matcher::vector_ideal_reg(int size) {
  switch(size) {
    case  4: return Op_VecS;
    case  8: return Op_VecD;
    case 16: return Op_VecX;
    case 32: return Op_VecY;
  }
  ShouldNotReachHere();
  return 0;
}

// Should the matcher clone input 'm' of node 'n'?
bool Matcher::pd_clone_node(Node* n, Node* m, Matcher::MStack& mstack) {
  if (is_vshift_con_pattern(n, m)) { // ShiftV src (ShiftCntV con)
    mstack.push(m, Visit);           // m = ShiftCntV
    return true;
  }
  return false;
}

// Should the Matcher clone shifts on addressing modes, expecting them
// to be subsumed into complex addressing expressions or compute them
// into registers?
bool Matcher::pd_clone_address_expressions(AddPNode* m, Matcher::MStack& mstack, VectorSet& address_visited) {
  return clone_base_plus_offset_address(m, mstack, address_visited);
}

// Max vector size in bytes. 0 if not supported.
const int Matcher::vector_width_in_bytes(BasicType bt) {
  int size = (int)MaxVectorSize;
  if (size < 2*type2aelembytes(bt)) size = 0;
  // But never < 4
  if (size < 4) size = 0;
  return size;
}

// Limits on vector size (number of elements) loaded into vector.
const int Matcher::max_vector_size(const BasicType bt) {
  assert(is_java_primitive(bt), "only primitive type vectors");
  return vector_width_in_bytes(bt)/type2aelembytes(bt);
}

const int Matcher::min_vector_size(const BasicType bt) {
  int max_size = max_vector_size(bt);
  int size     = 0;

  if (UseLSX) size = 4;
  size = size / type2aelembytes(bt);
  if (size < 2) size = 2;
  return MIN2(size,max_size);
}

// Register for DIVI projection of divmodI
RegMask Matcher::divI_proj_mask() {
  return T1_REG_mask();
}

// Register for MODI projection of divmodI
RegMask Matcher::modI_proj_mask() {
  return T2_REG_mask();
}

// Register for DIVL projection of divmodL
RegMask Matcher::divL_proj_mask() {
  return T1_LONG_REG_mask();
}

RegMask Matcher::modL_proj_mask() {
  return T2_LONG_REG_mask();
}
// Return whether or not this register is ever used as an argument.  This
// function is used on startup to build the trampoline stubs in generateOptoStub.
// Registers not mentioned will be killed by the VM call in the trampoline, and
// arguments in those registers not be available to the callee.
bool Matcher::can_be_java_arg( int reg ) {
  // Refer to: [sharedRuntime_loongarch_64.cpp] SharedRuntime::java_calling_convention()
  if (    reg == T0_num || reg == T0_H_num
       || reg == A0_num || reg == A0_H_num
       || reg == A1_num || reg == A1_H_num
       || reg == A2_num || reg == A2_H_num
       || reg == A3_num || reg == A3_H_num
       || reg == A4_num || reg == A4_H_num
       || reg == A5_num || reg == A5_H_num
       || reg == A6_num || reg == A6_H_num
       || reg == A7_num || reg == A7_H_num )
    return true;

  if (    reg == F0_num || reg == F0_H_num
       || reg == F1_num || reg == F1_H_num
       || reg == F2_num || reg == F2_H_num
       || reg == F3_num || reg == F3_H_num
       || reg == F4_num || reg == F4_H_num
       || reg == F5_num || reg == F5_H_num
       || reg == F6_num || reg == F6_H_num
       || reg == F7_num || reg == F7_H_num )
    return true;

  return false;
}

bool Matcher::is_spillable_arg( int reg ) {
  return can_be_java_arg(reg);
}

uint Matcher::int_pressure_limit()
{
  uint default_intpresssure = _ANY_REG32_mask.Size() - 1;

  if (!PreserveFramePointer) {
    default_intpresssure--;
  }
  return (INTPRESSURE == -1) ? default_intpresssure : INTPRESSURE;
}

uint Matcher::float_pressure_limit()
{
  return (FLOATPRESSURE == -1) ? _FLT_REG_mask.Size() : FLOATPRESSURE;
}

bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
  return false;
}

const RegMask Matcher::method_handle_invoke_SP_save_mask() {
  return FP_REG_mask();
}

int CallStaticJavaDirectNode::compute_padding(int current_offset) const {
  const uintx m = alignment_required() - 1;
  return mask_bits(current_offset + m, ~m) - current_offset;
}

int CallDynamicJavaDirectNode::compute_padding(int current_offset) const {
  const uintx m = alignment_required() - 1;
  return mask_bits(current_offset + m, ~m) - current_offset;
}

int CallLeafNoFPDirectNode::compute_padding(int current_offset) const {
  const uintx m = alignment_required() - 1;
  return mask_bits(current_offset + m, ~m) - current_offset;
}

int CallLeafDirectNode::compute_padding(int current_offset) const {
  const uintx m = alignment_required() - 1;
  return mask_bits(current_offset + m, ~m) - current_offset;
}

int CallRuntimeDirectNode::compute_padding(int current_offset) const {
  const uintx m = alignment_required() - 1;
  return mask_bits(current_offset + m, ~m) - current_offset;
}

#ifndef PRODUCT
void MachBreakpointNode::format( PhaseRegAlloc *, outputStream* st ) const {
  st->print("BRK");
}
#endif

void MachBreakpointNode::emit(CodeBuffer &cbuf, PhaseRegAlloc* ra_) const {
  C2_MacroAssembler _masm(&cbuf);
  __ brk(5);
}

uint MachBreakpointNode::size(PhaseRegAlloc* ra_) const {
  return MachNode::size(ra_);
}



// !!!!! Special hack to get all type of calls to specify the byte offset
//       from the start of the call to the point where the return address
//       will point.
int MachCallStaticJavaNode::ret_addr_offset() {
  // bl
  return NativeCall::instruction_size;
}

int MachCallDynamicJavaNode::ret_addr_offset() {
  // lu12i_w IC_Klass,
  // ori IC_Klass,
  // lu32i_d IC_Klass
  // lu52i_d IC_Klass

  // bl
  return NativeMovConstReg::instruction_size + NativeCall::instruction_size;
}

//=============================================================================

// Figure out which register class each belongs in: rc_int, rc_float, rc_stack
enum RC { rc_bad, rc_int, rc_float, rc_stack };
static enum RC rc_class( OptoReg::Name reg ) {
  if( !OptoReg::is_valid(reg)  ) return rc_bad;
  if (OptoReg::is_stack(reg)) return rc_stack;
  VMReg r = OptoReg::as_VMReg(reg);
  if (r->is_Register()) return rc_int;
  assert(r->is_FloatRegister(), "must be");
  return rc_float;
}

// Helper methods for MachSpillCopyNode::implementation().
static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
                          int src_hi, int dst_hi, uint ireg, outputStream* st) {
  int size = 0;
  if (cbuf) {
    MacroAssembler _masm(cbuf);
    int offset = __ offset();
    switch (ireg) {
      case Op_VecS:
        __ fmov_s(as_FloatRegister(Matcher::_regEncode[dst_lo]), as_FloatRegister(Matcher::_regEncode[src_lo]));
        break;
      case Op_VecD:
        __ fmov_d(as_FloatRegister(Matcher::_regEncode[dst_lo]), as_FloatRegister(Matcher::_regEncode[src_lo]));
        break;
      case Op_VecX:
        __ vori_b(as_FloatRegister(Matcher::_regEncode[dst_lo]), as_FloatRegister(Matcher::_regEncode[src_lo]), 0);
        break;
      case Op_VecY:
        __ xvori_b(as_FloatRegister(Matcher::_regEncode[dst_lo]), as_FloatRegister(Matcher::_regEncode[src_lo]), 0);
        break;
      default:
        ShouldNotReachHere();
    }
#ifndef PRODUCT
  } else if (!do_size) {
    switch (ireg) {
      case Op_VecS:
        st->print("fmov.s    %s, %s\t# spill", Matcher::regName[dst_lo], Matcher::regName[src_lo]);
        break;
      case Op_VecD:
        st->print("fmov.d    %s, %s\t# spill", Matcher::regName[dst_lo], Matcher::regName[src_lo]);
        break;
      case Op_VecX:
        st->print("vori.b    %s, %s, 0\t# spill", Matcher::regName[dst_lo], Matcher::regName[src_lo]);
        break;
      case Op_VecY:
        st->print("xvori.b    %s, %s, 0\t# spill", Matcher::regName[dst_lo], Matcher::regName[src_lo]);
        break;
      default:
        ShouldNotReachHere();
    }
#endif
  }
  size += 4;
  return size;
}

static int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,
                            int stack_offset, int reg, uint ireg, outputStream* st) {
  int size = 0;
  if (cbuf) {
    MacroAssembler _masm(cbuf);
    int offset = __ offset();
    if (is_load) {
      switch (ireg) {
        case Op_VecS:
          __ fld_s(as_FloatRegister(Matcher::_regEncode[reg]), SP, stack_offset);
          break;
        case Op_VecD:
          __ fld_d(as_FloatRegister(Matcher::_regEncode[reg]), SP, stack_offset);
          break;
        case Op_VecX:
          __ vld(as_FloatRegister(Matcher::_regEncode[reg]), SP, stack_offset);
          break;
        case Op_VecY:
          __ xvld(as_FloatRegister(Matcher::_regEncode[reg]), SP, stack_offset);
          break;
        default:
          ShouldNotReachHere();
      }
    } else { // store
      switch (ireg) {
        case Op_VecS:
          __ fst_s(as_FloatRegister(Matcher::_regEncode[reg]), SP, stack_offset);
          break;
        case Op_VecD:
          __ fst_d(as_FloatRegister(Matcher::_regEncode[reg]), SP, stack_offset);
          break;
        case Op_VecX:
          __ vst(as_FloatRegister(Matcher::_regEncode[reg]), SP, stack_offset);
          break;
        case Op_VecY:
          __ xvst(as_FloatRegister(Matcher::_regEncode[reg]), SP, stack_offset);
          break;
        default:
          ShouldNotReachHere();
      }
    }
#ifndef PRODUCT
  } else if (!do_size) {
    if (is_load) {
      switch (ireg) {
        case Op_VecS:
          st->print("fld.s    %s, [SP + %d]\t# spill", Matcher::regName[reg], stack_offset);
          break;
        case Op_VecD:
          st->print("fld.d    %s, [SP + %d]\t# spill", Matcher::regName[reg], stack_offset);
          break;
        case Op_VecX:
          st->print("vld    %s, [SP + %d]\t# spill", Matcher::regName[reg], stack_offset);
          break;
        case Op_VecY:
          st->print("xvld    %s, [SP + %d]\t# spill", Matcher::regName[reg], stack_offset);
          break;
        default:
          ShouldNotReachHere();
      }
    } else { // store
      switch (ireg) {
        case Op_VecS:
          st->print("fst.s    %s, [SP + %d]\t# spill", Matcher::regName[reg], stack_offset);
          break;
        case Op_VecD:
          st->print("fst.d    %s, [SP + %d]\t# spill", Matcher::regName[reg], stack_offset);
          break;
        case Op_VecX:
          st->print("vst    %s, [SP + %d]\t# spill", Matcher::regName[reg], stack_offset);
          break;
        case Op_VecY:
          st->print("xvst    %s, [SP + %d]\t# spill", Matcher::regName[reg], stack_offset);
          break;
        default:
          ShouldNotReachHere();
      }
    }
#endif
  }
  size += 4;
  return size;
}

static int vec_stack_to_stack_helper(CodeBuffer *cbuf, int src_offset,
                                      int dst_offset, uint ireg, outputStream* st) {
  int size = 0;
  if (cbuf) {
    MacroAssembler _masm(cbuf);
    switch (ireg) {
      case Op_VecS:
        __ fld_s(F23, SP, src_offset);
        __ fst_s(F23, SP, dst_offset);
        break;
      case Op_VecD:
        __ fld_d(F23, SP, src_offset);
        __ fst_d(F23, SP, dst_offset);
        break;
      case Op_VecX:
        __ vld(F23, SP, src_offset);
        __ vst(F23, SP, dst_offset);
        break;
      case Op_VecY:
        __ xvld(F23, SP, src_offset);
        __ xvst(F23, SP, dst_offset);
        break;
      default:
        ShouldNotReachHere();
    }
#ifndef PRODUCT
  } else {
    switch (ireg) {
      case Op_VecS:
        st->print("fld.s f23, %d(sp)\n\t"
                  "fst.s f23, %d(sp)\t# 32-bit mem-mem spill",
                  src_offset, dst_offset);
        break;
      case Op_VecD:
        st->print("fld.d f23, %d(sp)\n\t"
                  "fst.d f23, %d(sp)\t# 64-bit mem-mem spill",
                  src_offset, dst_offset);
        break;
      case Op_VecX:
        st->print("vld f23, %d(sp)\n\t"
                  "vst f23, %d(sp)\t# 128-bit mem-mem spill",
                  src_offset, dst_offset);
        break;
      case Op_VecY:
        st->print("xvld f23, %d(sp)\n\t"
                  "xvst f23, %d(sp)\t# 256-bit mem-mem spill",
                  src_offset, dst_offset);
        break;
      default:
        ShouldNotReachHere();
    }
#endif
  }
  size += 8;
  return size;
}

uint MachSpillCopyNode::implementation( CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream* st ) const {
  // Get registers to move
  OptoReg::Name src_second = ra_->get_reg_second(in(1));
  OptoReg::Name src_first = ra_->get_reg_first(in(1));
  OptoReg::Name dst_second = ra_->get_reg_second(this );
  OptoReg::Name dst_first = ra_->get_reg_first(this );

  enum RC src_second_rc = rc_class(src_second);
  enum RC src_first_rc = rc_class(src_first);
  enum RC dst_second_rc = rc_class(dst_second);
  enum RC dst_first_rc = rc_class(dst_first);

  assert(OptoReg::is_valid(src_first) && OptoReg::is_valid(dst_first), "must move at least 1 register" );

  // Generate spill code!

  if( src_first == dst_first && src_second == dst_second )
    return 0;            // Self copy, no move

  if (bottom_type()->isa_vect() != nullptr) {
    uint ireg = ideal_reg();
    assert((src_first_rc != rc_int && dst_first_rc != rc_int), "sanity");
    if (src_first_rc == rc_stack && dst_first_rc == rc_stack) {
      // mem -> mem
      int src_offset = ra_->reg2offset(src_first);
      int dst_offset = ra_->reg2offset(dst_first);
      vec_stack_to_stack_helper(cbuf, src_offset, dst_offset, ireg, st);
    } else if (src_first_rc == rc_float && dst_first_rc == rc_float) {
      vec_mov_helper(cbuf, do_size, src_first, dst_first, src_second, dst_second, ireg, st);
    } else if (src_first_rc == rc_float && dst_first_rc == rc_stack) {
      int stack_offset = ra_->reg2offset(dst_first);
      vec_spill_helper(cbuf, do_size, false, stack_offset, src_first, ireg, st);
    } else if (src_first_rc == rc_stack && dst_first_rc == rc_float) {
      int stack_offset = ra_->reg2offset(src_first);
      vec_spill_helper(cbuf, do_size, true,  stack_offset, dst_first, ireg, st);
    } else {
      ShouldNotReachHere();
    }
    return 0;
  }

  if (src_first_rc == rc_stack) {
    // mem ->
    if (dst_first_rc == rc_stack) {
      // mem -> mem
      assert(src_second != dst_first, "overlap");
      if ((src_first & 1) == 0 && src_first + 1 == src_second &&
          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {
        // 64-bit
        int src_offset = ra_->reg2offset(src_first);
        int dst_offset = ra_->reg2offset(dst_first);
        if (cbuf) {
          C2_MacroAssembler _masm(cbuf);
          __ ld_d(AT, Address(SP, src_offset));
          __ st_d(AT, Address(SP, dst_offset));
#ifndef PRODUCT
        } else {
          st->print("\tld_d    AT, [SP + #%d]\t# 64-bit mem-mem spill 1\n\t"
                    "st_d    AT, [SP + #%d]",
                    src_offset, dst_offset);
#endif
        }
      } else {
        // 32-bit
        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), "no transform");
        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), "no transform");
        // No pushl/popl, so:
        int src_offset = ra_->reg2offset(src_first);
        int dst_offset = ra_->reg2offset(dst_first);
        if (cbuf) {
          C2_MacroAssembler _masm(cbuf);
          __ ld_w(AT, Address(SP, src_offset));
          __ st_w(AT, Address(SP, dst_offset));
#ifndef PRODUCT
        } else {
          st->print("\tld_w    AT, [SP + #%d] spill 2\n\t"
                    "st_w    AT, [SP + #%d]\n\t",
                    src_offset, dst_offset);
#endif
        }
      }
      return 0;
    } else if (dst_first_rc == rc_int) {
      // mem -> gpr
      if ((src_first & 1) == 0 && src_first + 1 == src_second &&
          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {
        // 64-bit
        int offset = ra_->reg2offset(src_first);
        if (cbuf) {
          C2_MacroAssembler _masm(cbuf);
          __ ld_d(as_Register(Matcher::_regEncode[dst_first]), Address(SP, offset));
#ifndef PRODUCT
        } else {
          st->print("\tld_d    %s, [SP + #%d]\t# spill 3",
                    Matcher::regName[dst_first],
                    offset);
#endif
        }
      } else {
        // 32-bit
        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), "no transform");
        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), "no transform");
        int offset = ra_->reg2offset(src_first);
        if (cbuf) {
          C2_MacroAssembler _masm(cbuf);
          if (this->ideal_reg() == Op_RegI)
            __ ld_w(as_Register(Matcher::_regEncode[dst_first]), Address(SP, offset));
          else {
            __ ld_wu(as_Register(Matcher::_regEncode[dst_first]), Address(SP, offset));
          }
#ifndef PRODUCT
        } else {
          if (this->ideal_reg() == Op_RegI)
            st->print("\tld_w    %s, [SP + #%d]\t# spill 4",
                      Matcher::regName[dst_first],
                      offset);
          else
            st->print("\tld_wu    %s, [SP + #%d]\t# spill 5",
                      Matcher::regName[dst_first],
                      offset);
#endif
        }
      }
      return 0;
    } else if (dst_first_rc == rc_float) {
      // mem-> xmm
      if ((src_first & 1) == 0 && src_first + 1 == src_second &&
          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {
        // 64-bit
        int offset = ra_->reg2offset(src_first);
        if (cbuf) {
          C2_MacroAssembler _masm(cbuf);
          __ fld_d( as_FloatRegister(Matcher::_regEncode[dst_first]), Address(SP, offset));
#ifndef PRODUCT
        } else {
          st->print("\tfld_d  %s, [SP + #%d]\t# spill 6",
                    Matcher::regName[dst_first],
                    offset);
#endif
        }
      } else {
        // 32-bit
        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), "no transform");
        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), "no transform");
        int offset = ra_->reg2offset(src_first);
        if (cbuf) {
          C2_MacroAssembler _masm(cbuf);
          __ fld_s( as_FloatRegister(Matcher::_regEncode[dst_first]), Address(SP, offset));
#ifndef PRODUCT
        } else {
          st->print("\tfld_s   %s, [SP + #%d]\t# spill 7",
                    Matcher::regName[dst_first],
                    offset);
#endif
        }
      }
    }
    return 0;
  } else if (src_first_rc == rc_int) {
    // gpr ->
    if (dst_first_rc == rc_stack) {
      // gpr -> mem
      if ((src_first & 1) == 0 && src_first + 1 == src_second &&
          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {
        // 64-bit
        int offset = ra_->reg2offset(dst_first);
        if (cbuf) {
          C2_MacroAssembler _masm(cbuf);
          __ st_d(as_Register(Matcher::_regEncode[src_first]), Address(SP, offset));
#ifndef PRODUCT
        } else {
          st->print("\tst_d    %s, [SP + #%d] # spill 8",
                    Matcher::regName[src_first],
                    offset);
#endif
        }
      } else {
        // 32-bit
        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), "no transform");
        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), "no transform");
        int offset = ra_->reg2offset(dst_first);
        if (cbuf) {
          C2_MacroAssembler _masm(cbuf);
          __ st_w(as_Register(Matcher::_regEncode[src_first]), Address(SP, offset));
#ifndef PRODUCT
        } else {
          st->print("\tst_w    %s, [SP + #%d]\t# spill 9",
                    Matcher::regName[src_first], offset);
#endif
        }
      }
      return 0;
    } else if (dst_first_rc == rc_int) {
      // gpr -> gpr
      if ((src_first & 1) == 0 && src_first + 1 == src_second &&
          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {
        // 64-bit
        if (cbuf) {
          C2_MacroAssembler _masm(cbuf);
          __ move(as_Register(Matcher::_regEncode[dst_first]),
                  as_Register(Matcher::_regEncode[src_first]));
#ifndef PRODUCT
        } else {
          st->print("\tmove(64bit)    %s <-- %s\t# spill 10",
                    Matcher::regName[dst_first],
                    Matcher::regName[src_first]);
#endif
        }
        return 0;
      } else {
        // 32-bit
        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), "no transform");
        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), "no transform");
        if (cbuf) {
          C2_MacroAssembler _masm(cbuf);
          if (this->ideal_reg() == Op_RegI)
              __ move_u32(as_Register(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
          else
              __ add_d(as_Register(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]), R0);
#ifndef PRODUCT
        } else {
          st->print("\n\t");
          st->print("move(32-bit)    %s <-- %s\t# spill 11",
                    Matcher::regName[dst_first],
                    Matcher::regName[src_first]);
#endif
        }
        return 0;
      }
    } else if (dst_first_rc == rc_float) {
      // gpr -> xmm
      if ((src_first & 1) == 0 && src_first + 1 == src_second &&
          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {
        // 64-bit
        if (cbuf) {
          C2_MacroAssembler _masm(cbuf);
          __ movgr2fr_d(as_FloatRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
#ifndef PRODUCT
        } else {
          st->print("\n\t");
          st->print("movgr2fr_d   %s, %s\t# spill 12",
                    Matcher::regName[dst_first],
                    Matcher::regName[src_first]);
#endif
        }
      } else {
        // 32-bit
        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), "no transform");
        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), "no transform");
        if (cbuf) {
          C2_MacroAssembler _masm(cbuf);
          __ movgr2fr_w(as_FloatRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
#ifndef PRODUCT
        } else {
          st->print("\n\t");
          st->print("movgr2fr_w   %s, %s\t# spill 13",
                    Matcher::regName[dst_first],
                    Matcher::regName[src_first]);
#endif
        }
      }
      return 0;
    }
  } else if (src_first_rc == rc_float) {
    // xmm ->
    if (dst_first_rc == rc_stack) {
      // xmm -> mem
      if ((src_first & 1) == 0 && src_first + 1 == src_second &&
          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {
        // 64-bit
        int offset = ra_->reg2offset(dst_first);
        if (cbuf) {
          C2_MacroAssembler _masm(cbuf);
          __ fst_d( as_FloatRegister(Matcher::_regEncode[src_first]), Address(SP, offset) );
#ifndef PRODUCT
        } else {
          st->print("\n\t");
          st->print("fst_d   %s, [SP + #%d]\t# spill 14",
                    Matcher::regName[src_first],
                    offset);
#endif
        }
      } else {
        // 32-bit
        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), "no transform");
        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), "no transform");
        int offset = ra_->reg2offset(dst_first);
        if (cbuf) {
          C2_MacroAssembler _masm(cbuf);
          __ fst_s(as_FloatRegister(Matcher::_regEncode[src_first]), Address(SP, offset));
#ifndef PRODUCT
        } else {
          st->print("\n\t");
          st->print("fst_s   %s, [SP + #%d]\t# spill 15",
                    Matcher::regName[src_first],
                    offset);
#endif
        }
      }
      return 0;
    } else if (dst_first_rc == rc_int) {
      // xmm -> gpr
      if ((src_first & 1) == 0 && src_first + 1 == src_second &&
          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {
        // 64-bit
        if (cbuf) {
          C2_MacroAssembler _masm(cbuf);
          __ movfr2gr_d( as_Register(Matcher::_regEncode[dst_first]), as_FloatRegister(Matcher::_regEncode[src_first]));
#ifndef PRODUCT
        } else {
          st->print("\n\t");
          st->print("movfr2gr_d   %s, %s\t# spill 16",
                    Matcher::regName[dst_first],
                    Matcher::regName[src_first]);
#endif
        }
      } else {
        // 32-bit
        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), "no transform");
        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), "no transform");
        if (cbuf) {
          C2_MacroAssembler _masm(cbuf);
          __ movfr2gr_s( as_Register(Matcher::_regEncode[dst_first]), as_FloatRegister(Matcher::_regEncode[src_first]));
#ifndef PRODUCT
        } else {
          st->print("\n\t");
          st->print("movfr2gr_s   %s, %s\t# spill 17",
                    Matcher::regName[dst_first],
                    Matcher::regName[src_first]);
#endif
        }
      }
      return 0;
    } else if (dst_first_rc == rc_float) {
      // xmm -> xmm
      if ((src_first & 1) == 0 && src_first + 1 == src_second &&
          (dst_first & 1) == 0 && dst_first + 1 == dst_second) {
        // 64-bit
        if (cbuf) {
          C2_MacroAssembler _masm(cbuf);
          __ fmov_d( as_FloatRegister(Matcher::_regEncode[dst_first]), as_FloatRegister(Matcher::_regEncode[src_first]));
#ifndef PRODUCT
        } else {
          st->print("\n\t");
          st->print("fmov_d  %s <-- %s\t# spill 18",
                    Matcher::regName[dst_first],
                    Matcher::regName[src_first]);
#endif
        }
      } else {
        // 32-bit
        assert(!((src_first & 1) == 0 && src_first + 1 == src_second), "no transform");
        assert(!((dst_first & 1) == 0 && dst_first + 1 == dst_second), "no transform");
        if (cbuf) {
          C2_MacroAssembler _masm(cbuf);
          __ fmov_s( as_FloatRegister(Matcher::_regEncode[dst_first]), as_FloatRegister(Matcher::_regEncode[src_first]));
#ifndef PRODUCT
        } else {
          st->print("\n\t");
          st->print("fmov_s  %s <-- %s\t# spill 19",
                    Matcher::regName[dst_first],
                    Matcher::regName[src_first]);
#endif
        }
      }
      return 0;
    }
  }

  assert(0," foo ");
  Unimplemented();
  return 0;
}

#ifndef PRODUCT
void MachSpillCopyNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
  implementation( nullptr, ra_, false, st );
}
#endif

void MachSpillCopyNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {
  implementation( &cbuf, ra_, false, nullptr );
}

uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
  return MachNode::size(ra_);
}

//=============================================================================
#ifndef PRODUCT
void MachEpilogNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
  Compile *C = ra_->C;
  int framesize = C->output()->frame_size_in_bytes();

  assert((framesize & (StackAlignmentInBytes-1)) == 0, "frame size not aligned");

  st->print_cr("ld_d    RA, SP, %d # Restore RA @ MachEpilogNode", -wordSize);
  st->print("\t");
  st->print_cr("ld_d    FP, SP, %d # Restore FP @ MachEpilogNode", -wordSize*2);
  st->print("\t");
  if (Assembler::is_simm(framesize, 12)) {
    st->print_cr("addi_d   SP, SP, %d # Rlease stack @ MachEpilogNode", framesize);
  } else {
    st->print_cr("li   AT, %d # Rlease stack @ MachEpilogNode", framesize);
    st->print_cr("add_d   SP, SP, AT # Rlease stack @ MachEpilogNode");
  }
  if( do_polling() && C->is_method_compilation() ) {
    st->print("\t");
    st->print_cr("ld_d    AT, poll_offset[thread] #polling_word_offset\n\t"
                 "ld_w    AT, [AT]\t"
                 "# Safepoint: poll for GC");
  }
}
#endif

void MachEpilogNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {
  Compile *C = ra_->C;
  C2_MacroAssembler _masm(&cbuf);
  int framesize = C->output()->frame_size_in_bytes();

  assert((framesize & (StackAlignmentInBytes-1)) == 0, "frame size not aligned");

  __ remove_frame(framesize);

  if (StackReservedPages > 0 && C->has_reserved_stack_access()) {
    __ reserved_stack_check();
  }

  if( do_polling() && C->is_method_compilation() ) {
    Label dummy_label;
    Label* code_stub = &dummy_label;
    if (!C->output()->in_scratch_emit_size()) {
      C2SafepointPollStub* stub = new (C->comp_arena()) C2SafepointPollStub(__ offset());
      C->output()->add_stub(stub);
      code_stub = &stub->entry();
    }
    __ relocate(relocInfo::poll_return_type);
    __ safepoint_poll(*code_stub, TREG, true /* at_return */, false /* acquire */, true /* in_nmethod */);
  }
}

uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
  return MachNode::size(ra_); // too many variables; just compute it the hard way
}

int MachEpilogNode::reloc() const {
  return 0; // a large enough number
}

const Pipeline * MachEpilogNode::pipeline() const {
  return MachNode::pipeline_class();
}

//=============================================================================

#ifndef PRODUCT
void BoxLockNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
  int offset = ra_->reg2offset(in_RegMask(0).find_first_elem());
  int reg = ra_->get_reg_first(this);
  st->print("ADDI_D %s, SP, %d   @BoxLockNode",Matcher::regName[reg],offset);
}
#endif


uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
   int offset = ra_->reg2offset(in_RegMask(0).find_first_elem());

   if (Assembler::is_simm(offset, 12))
     return 4;
   else
     return 3 * 4;
}

void BoxLockNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {
  C2_MacroAssembler _masm(&cbuf);
  int offset = ra_->reg2offset(in_RegMask(0).find_first_elem());
  int reg = ra_->get_encode(this);

  if (Assembler::is_simm(offset, 12)) {
    __ addi_d(as_Register(reg), SP, offset);
  } else {
    __ lu12i_w(AT, Assembler::split_low20(offset >> 12));
    __ ori(AT, AT, Assembler::split_low12(offset));
    __ add_d(as_Register(reg), SP, AT);
  }
}

int MachCallRuntimeNode::ret_addr_offset() {
  // pcaddu18i
  // jirl
  return NativeFarCall::instruction_size;
}

//=============================================================================
#ifndef PRODUCT
void MachNopNode::format( PhaseRegAlloc *, outputStream* st ) const {
  st->print("NOP \t# %d bytes pad for loops and calls", 4 * _count);
}
#endif

void MachNopNode::emit(CodeBuffer &cbuf, PhaseRegAlloc * ) const {
  C2_MacroAssembler _masm(&cbuf);
  int i = 0;
  for(i = 0; i < _count; i++)
     __ nop();
}

uint MachNopNode::size(PhaseRegAlloc *) const {
  return 4 * _count;
}
const Pipeline* MachNopNode::pipeline() const {
  return MachNode::pipeline_class();
}

//=============================================================================

//=============================================================================
#ifndef PRODUCT
void MachUEPNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
  st->print_cr("load_klass(T4, T0)");
  st->print_cr("\tbeq(T4, iCache, L)");
  st->print_cr("\tjmp(SharedRuntime::get_ic_miss_stub(), relocInfo::runtime_call_type)");
  st->print_cr("    L:");
}
#endif


void MachUEPNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {
  C2_MacroAssembler _masm(&cbuf);
  int  ic_reg = Matcher::inline_cache_reg_encode();
  Label L;
  Register receiver = T0;
  Register   iCache = as_Register(ic_reg);

  __ load_klass(T4, receiver);
  __ beq(T4, iCache, L);
  __ jmp((address)SharedRuntime::get_ic_miss_stub(), relocInfo::runtime_call_type);
  __ bind(L);
}

uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
  return MachNode::size(ra_);
}



//=============================================================================

const RegMask& MachConstantBaseNode::_out_RegMask = P_REG_mask();

int ConstantTable::calculate_table_base_offset() const {
  return 0;  // absolute addressing, no offset
}

bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
void MachConstantBaseNode::postalloc_expand(GrowableArray <Node *> *nodes, PhaseRegAlloc *ra_) {
  ShouldNotReachHere();
}

void MachConstantBaseNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
  Compile* C = ra_->C;
  ConstantTable& constant_table = C->output()->constant_table();
  C2_MacroAssembler _masm(&cbuf);

  Register Rtoc = as_Register(ra_->get_encode(this));
  CodeSection* consts_section = cbuf.consts();
  int consts_size = cbuf.insts()->align_at_start(consts_section->size());
  assert(constant_table.size() == consts_size, "must be equal");

  if (consts_section->size()) {
    assert((CodeBuffer::SECT_CONSTS + 1) == CodeBuffer::SECT_INSTS,
           "insts must be immediately follow consts");
    // Materialize the constant table base.
    address baseaddr = cbuf.insts()->start() - consts_size + -(constant_table.table_base_offset());
    jint offs = (baseaddr - __ pc()) >> 2;
    guarantee(Assembler::is_simm(offs, 20), "Not signed 20-bit offset");
    __ pcaddi(Rtoc, offs);
  }
}

uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  // pcaddi
  return 1 * BytesPerInstWord;
}

#ifndef PRODUCT
void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  Register r = as_Register(ra_->get_encode(this));
  st->print("pcaddi    %s, &constanttable (constant table base) @ MachConstantBaseNode", r->name());
}
#endif


//=============================================================================
#ifndef PRODUCT
void MachPrologNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
  Compile* C = ra_->C;

  int framesize = C->output()->frame_size_in_bytes();
  int bangsize = C->output()->bang_size_in_bytes();
  assert((framesize & (StackAlignmentInBytes-1)) == 0, "frame size not aligned");

  // Calls to C2R adapters often do not accept exceptional returns.
  // We require that their callers must bang for them.  But be careful, because
  // some VM calls (such as call site linkage) can use several kilobytes of
  // stack.  But the stack safety zone should account for that.
  // See bugs 4446381, 4468289, 4497237.
  if (C->output()->need_stack_bang(bangsize)) {
    st->print_cr("# stack bang"); st->print("\t");
  }
  st->print("st_d       RA, %d(SP)  @ MachPrologNode\n\t", -wordSize);
  st->print("st_d       FP, %d(SP)  @ MachPrologNode\n\t", -wordSize*2);
  if (PreserveFramePointer) {
    if (Assembler::is_simm((framesize - wordSize * 2), 12)) {
      st->print("addi_d   FP, SP, %d \n\t", framesize);
    } else {
      st->print("li   AT, %d \n\t", framesize);
      st->print("add_d   FP, AT \n\t");
    }
  }
  st->print("addi_d   SP, SP, -%d \t",framesize);
  if (C->stub_function() == nullptr && BarrierSet::barrier_set()->barrier_set_nmethod() != nullptr) {
    st->print("\n\t");
    st->print("ld_d  T1, guard, 0\n\t");
    st->print("membar  LoadLoad\n\t");
    st->print("ld_d  T2, TREG, thread_disarmed_guard_value_offset\n\t");
    st->print("beq   T1, T2, skip\n\t");
    st->print("\n\t");
    st->print("jalr  #nmethod_entry_barrier_stub\n\t");
    st->print("b     skip\n\t");
    st->print("guard: int\n\t");
    st->print("\n\t");
    st->print("skip:\n\t");
  }
}
#endif


void MachPrologNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {
  Compile* C = ra_->C;
  C2_MacroAssembler _masm(&cbuf);

  int framesize = C->output()->frame_size_in_bytes();
  int bangsize = C->output()->bang_size_in_bytes();

  assert((framesize & (StackAlignmentInBytes-1)) == 0, "frame size not aligned");

#ifdef ASSERT
  address start = __ pc();
#endif

  if (C->clinit_barrier_on_entry()) {
    assert(!C->method()->holder()->is_not_initialized(), "initialization should have been started");

    Label L_skip_barrier;

    __ mov_metadata(T4, C->method()->holder()->constant_encoding());
    __ clinit_barrier(T4, AT, &L_skip_barrier);
    __ jmp((address)SharedRuntime::get_handle_wrong_method_stub(), relocInfo::runtime_call_type);
    __ bind(L_skip_barrier);
  }

  if (C->output()->need_stack_bang(bangsize)) {
    __ generate_stack_overflow_check(bangsize);
  }

  __ build_frame(framesize);

  assert((__ pc() - start) >= 1 * BytesPerInstWord, "No enough room for patch_verified_entry");

  if (C->stub_function() == nullptr) {
    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();
    if (BarrierSet::barrier_set()->barrier_set_nmethod() != nullptr) {
      // Dummy labels for just measuring the code size
      Label dummy_slow_path;
      Label dummy_continuation;
      Label dummy_guard;
      Label* slow_path = &dummy_slow_path;
      Label* continuation = &dummy_continuation;
      Label* guard = &dummy_guard;
      if (!Compile::current()->output()->in_scratch_emit_size()) {
        // Use real labels from actual stub when not emitting code for purpose of measuring its size
        C2EntryBarrierStub* stub = new (Compile::current()->comp_arena()) C2EntryBarrierStub();
        Compile::current()->output()->add_stub(stub);
        slow_path = &stub->entry();
        continuation = &stub->continuation();
        guard = &stub->guard();
      }
      // In the C2 code, we move the non-hot part of nmethod entry barriers out-of-line to a stub.
      bs->nmethod_entry_barrier(&_masm, slow_path, continuation, guard);
    }
  }

  C->output()->set_frame_complete(cbuf.insts_size());
  if (C->has_mach_constant_base_node()) {
    // NOTE: We set the table base offset here because users might be
    // emitted before MachConstantBaseNode.
    ConstantTable& constant_table = C->output()->constant_table();
    constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  }
}


uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
  return MachNode::size(ra_); // too many variables; just compute it the hard way
}

int MachPrologNode::reloc() const {
  return 0; // a large enough number
}

bool is_CAS(int opcode)
{
  switch(opcode) {
  // We handle these
  case Op_CompareAndSwapB:
  case Op_CompareAndSwapS:
  case Op_CompareAndSwapI:
  case Op_CompareAndSwapL:
  case Op_CompareAndSwapP:
  case Op_CompareAndSwapN:
  case Op_ShenandoahCompareAndSwapP:
  case Op_ShenandoahCompareAndSwapN:
  case Op_ShenandoahWeakCompareAndSwapP:
  case Op_ShenandoahWeakCompareAndSwapN:
  case Op_ShenandoahCompareAndExchangeP:
  case Op_ShenandoahCompareAndExchangeN:
  case Op_GetAndSetB:
  case Op_GetAndSetS:
  case Op_GetAndSetI:
  case Op_GetAndSetL:
  case Op_GetAndSetP:
  case Op_GetAndSetN:
  case Op_GetAndAddB:
  case Op_GetAndAddS:
  case Op_GetAndAddI:
  case Op_GetAndAddL:
    return true;
  default:
    return false;
  }
}

bool use_AMO(int opcode)
{
  switch(opcode) {
  // We handle these
  case Op_StoreI:
  case Op_StoreL:
  case Op_StoreP:
  case Op_StoreN:
  case Op_StoreNKlass:
    return true;
  default:
    return false;
  }
}

bool unnecessary_acquire(const Node *barrier)
{
  assert(barrier->is_MemBar(), "expecting a membar");

  if (UseBarriersForVolatile) {
    // we need to plant a dbar
    return false;
  }

  MemBarNode* mb = barrier->as_MemBar();

  if (mb->trailing_load_store()) {
    Node* load_store = mb->in(MemBarNode::Precedent);
    assert(load_store->is_LoadStore(), "unexpected graph shape");
    return is_CAS(load_store->Opcode());
  }

  return false;
}

bool unnecessary_release(const Node *n)
{
  assert((n->is_MemBar() && n->Opcode() == Op_MemBarRelease), "expecting a release membar");

  if (UseBarriersForVolatile) {
    // we need to plant a dbar
    return false;
  }

  MemBarNode *barrier = n->as_MemBar();

  if (!barrier->leading()) {
    return false;
  } else {
    Node* trailing = barrier->trailing_membar();
    MemBarNode* trailing_mb = trailing->as_MemBar();
    assert(trailing_mb->trailing(), "Not a trailing membar?");
    assert(trailing_mb->leading_membar() == n, "inconsistent leading/trailing membars");

    Node* mem = trailing_mb->in(MemBarNode::Precedent);
    if (mem->is_Store()) {
      assert(mem->as_Store()->is_release(), "");
      assert(trailing_mb->Opcode() == Op_MemBarVolatile, "");
      return use_AMO(mem->Opcode());
    } else {
      assert(mem->is_LoadStore(), "");
      assert(trailing_mb->Opcode() == Op_MemBarAcquire, "");
      return is_CAS(mem->Opcode());
    }
  }

  return false;
}

bool unnecessary_volatile(const Node *n)
{
  // assert n->is_MemBar();
  if (UseBarriersForVolatile) {
    // we need to plant a dbar
    return false;
  }

  MemBarNode *mbvol = n->as_MemBar();

  bool release = false;
  if (mbvol->trailing_store()) {
    Node* mem = mbvol->in(MemBarNode::Precedent);
    release = use_AMO(mem->Opcode());
  }

  assert(!release || (mbvol->in(MemBarNode::Precedent)->is_Store() && mbvol->in(MemBarNode::Precedent)->as_Store()->is_release()), "");
#ifdef ASSERT
  if (release) {
    Node* leading = mbvol->leading_membar();
    assert(leading->Opcode() == Op_MemBarRelease, "");
    assert(leading->as_MemBar()->leading_store(), "");
    assert(leading->as_MemBar()->trailing_membar() == mbvol, "");
   }
#endif

  return release;
}

bool needs_releasing_store(const Node *n)
{
  // assert n->is_Store();
  if (UseBarriersForVolatile) {
    // we use a normal store and dbar combination
    return false;
  }

  StoreNode *st = n->as_Store();

  return st->trailing_membar() != nullptr;
}

%}

//----------ENCODING BLOCK-----------------------------------------------------
// This block specifies the encoding classes used by the compiler to output
// byte streams.  Encoding classes generate functions which are called by
// Machine Instruction Nodes in order to generate the bit encoding of the
// instruction.  Operands specify their base encoding interface with the
// interface keyword.  There are currently supported four interfaces,
// REG_INTER, CONST_INTER, MEMORY_INTER, & COND_INTER.  REG_INTER causes an
// operand to generate a function which returns its register number when
// queried.   CONST_INTER causes an operand to generate a function which
// returns the value of the constant when queried.  MEMORY_INTER causes an
// operand to generate four functions which return the Base Register, the
// Index Register, the Scale Value, and the Offset Value of the operand when
// queried.  COND_INTER causes an operand to generate six functions which
// return the encoding code (ie - encoding bits for the instruction)
// associated with each basic boolean condition for a conditional instruction.
// Instructions specify two basic values for encoding.  They use the
// ins_encode keyword to specify their encoding class (which must be one of
// the class names specified in the encoding block), and they use the
// opcode keyword to specify, in order, their primary, secondary, and
// tertiary opcode.  Only the opcode sections which a particular instruction
// needs for encoding need to be specified.
encode %{

  enc_class Java_To_Runtime (method meth) %{    // CALL Java_To_Runtime, Java_To_Runtime_Leaf
    C2_MacroAssembler _masm(&cbuf);
    // This is the instruction starting address for relocation info.
    __ block_comment("Java_To_Runtime");
    cbuf.set_insts_mark();
    __ relocate(relocInfo::runtime_call_type);
    __ patchable_call((address)$meth$$method);
    _masm.clear_inst_mark();
    __ post_call_nop();
  %}

  enc_class Java_Static_Call (method meth) %{    // JAVA STATIC CALL
    // CALL to fixup routine.  Fixup routine uses ScopeDesc info to determine
    // who we intended to call.
    C2_MacroAssembler _masm(&cbuf);
    cbuf.set_insts_mark();
    address addr = (address)$meth$$method;
    address call;
    __ block_comment("Java_Static_Call");

    if ( !_method ) {
      // A call to a runtime wrapper, e.g. new, new_typeArray_Java, uncommon_trap.
      call = __ trampoline_call(AddressLiteral(addr, relocInfo::runtime_call_type), &cbuf);
      if (call == nullptr) {
        ciEnv::current()->record_failure("CodeCache is full");
        return;
      }
    } else {
      int method_index = resolved_method_index(cbuf);
      RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
                                     : static_call_Relocation::spec(method_index);
      call = __ trampoline_call(AddressLiteral(addr, rspec), &cbuf);
      if (call == nullptr) {
        ciEnv::current()->record_failure("CodeCache is full");
        return;
      }
      if (CodeBuffer::supports_shared_stubs() && _method->can_be_statically_bound()) {
        // Calls of the same statically bound method can share
        // a stub to the interpreter.
        cbuf.shared_stub_to_interp_for(_method, cbuf.insts()->mark_off());
      } else {
        // Emit stub for static call
        address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
        if (stub == nullptr) {
          ciEnv::current()->record_failure("CodeCache is full");
          return;
        }
      }
    }
    _masm.clear_inst_mark();
    __ post_call_nop();
  %}


  //
  // [Ref: LIR_Assembler::ic_call() ]
  //
  enc_class Java_Dynamic_Call (method meth) %{    // JAVA DYNAMIC CALL
    C2_MacroAssembler _masm(&cbuf);
    __ block_comment("Java_Dynamic_Call");
    address call = __ ic_call((address)$meth$$method, resolved_method_index(cbuf));
    if (call == nullptr) {
      ciEnv::current()->record_failure("CodeCache is full");
      return;
    }
    _masm.clear_inst_mark();
    __ post_call_nop();
  %}


  enc_class enc_PartialSubtypeCheck(mRegP result, mRegP sub, mRegP super, mRegI tmp, mRegI tmp2) %{
    Register result = $result$$Register;
    Register sub    = $sub$$Register;
    Register super  = $super$$Register;
    Register length = $tmp$$Register;
    Register tmp    = $tmp2$$Register;
    Label miss;

    // result may be the same as sub
    //    47c   B40: #    B21 B41 <- B20  Freq: 0.155379
    //    47c     partialSubtypeCheck result=S1, sub=S1, super=S3, length=S0
    //    4bc     mov   S2, nullptr #@loadConP
    //    4c0     beq   S1, S2, B21 #@branchConP  P=0.999999 C=-1.000000
    //
    C2_MacroAssembler _masm(&cbuf);
    Label done;
    __ check_klass_subtype_slow_path<false>(sub, super, length, tmp,
        nullptr, &miss,
        /*set_cond_codes:*/ true);
    // Refer to X86_64's RDI
    __ move(result, R0);
    __ b(done);

    __ bind(miss);
    __ li(result, 1);
    __ bind(done);
  %}

%}


//---------LOONGARCH FRAME--------------------------------------------------------------
// Definition of frame structure and management information.
//
//  S T A C K   L A Y O U T    Allocators stack-slot number
//                             |   (to get allocators register number
//  G  Owned by    |        |  v    add SharedInfo::stack0)
//  r   CALLER     |        |
//  o     |        +--------+      pad to even-align allocators stack-slot
//  w     V        |  pad0  |        numbers; owned by CALLER
//  t   -----------+--------+----> Matcher::_in_arg_limit, unaligned
//  h     ^        |   in   |  5
//        |        |  args  |  4   Holes in incoming args owned by SELF
//  |     |    old |        |  3
//  |     |     SP-+--------+----> Matcher::_old_SP, even aligned
//  v     |        |  ret   |  3   return address
//     Owned by    +--------+
//      Self       |  pad2  |  2   pad to align old SP
//        |        +--------+  1
//        |        | locks  |  0
//        |        +--------+----> SharedInfo::stack0, even aligned
//        |        |  pad1  | 11   pad to align new SP
//        |        +--------+
//        |        |        | 10
//        |        | spills |  9   spills
//        V        |        |  8   (pad0 slot for callee)
//      -----------+--------+----> Matcher::_out_arg_limit, unaligned
//        ^        |  out   |  7
//        |        |  args  |  6   Holes in outgoing args owned by CALLEE
//   Owned by  new |        |
//    Callee    SP-+--------+----> Matcher::_new_SP, even aligned
//                  |        |
//
// Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
//         known from SELF's arguments and the Java calling convention.
//         Region 6-7 is determined per call site.
// Note 2: If the calling convention leaves holes in the incoming argument
//         area, those holes are owned by SELF.  Holes in the outgoing area
//         are owned by the CALLEE.  Holes should not be necessary in the
//         incoming area, as the Java calling convention is completely under
//         the control of the AD file.  Doubles can be sorted and packed to
//         avoid holes.  Holes in the outgoing arguments may be necessary for
//         varargs C calling conventions.
// Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
//         even aligned with pad0 as needed.
//         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
//         region 6-11 is even aligned; it may be padded out more so that
//         the region from SP to FP meets the minimum stack alignment.
// Note 4: For I2C adapters, the incoming FP may not meet the minimum stack
//         alignment.  Region 11, pad1, may be dynamically extended so that
//         SP meets the minimum alignment.


frame %{
  // These two registers define part of the calling convention
  // between compiled code and the interpreter.
  // SEE StartI2CNode::calling_convention & StartC2INode::calling_convention & StartOSRNode::calling_convention
  // for more information.

  inline_cache_reg(T1);                // Inline Cache Register

  // Optional: name the operand used by cisc-spilling to access [stack_pointer + offset]
  cisc_spilling_operand_name(indOffset32);

  // Number of stack slots consumed by locking an object
  // generate Compile::sync_stack_slots
  sync_stack_slots(2);

  frame_pointer(SP);

  // Interpreter stores its frame pointer in a register which is
  // stored to the stack by I2CAdaptors.
  // I2CAdaptors convert from interpreted java to compiled java.

  interpreter_frame_pointer(FP);

  // generate Matcher::stack_alignment
  stack_alignment(StackAlignmentInBytes);  //wordSize = sizeof(char*);

  // Number of outgoing stack slots killed above the out_preserve_stack_slots
  // for calls to C.  Supports the var-args backing area for register parms.
  varargs_C_out_slots_killed(0);

  // The after-PROLOG location of the return address.  Location of
  // return address specifies a type (REG or STACK) and a number
  // representing the register number (i.e. - use a register name) or
  // stack slot.
  // Ret Addr is on stack in slot 0 if no locks or verification or alignment.
  // Otherwise, it is above the locks and verification slot and alignment word
  //return_addr(STACK -1+ round_to(1+VerifyStackAtCalls+Compile::current()->sync()*Compile::current()->sync_stack_slots(),WordsPerLong));
  return_addr(REG RA);

  // Location of C & interpreter return values
  // register(s) contain(s) return value for Op_StartI2C and Op_StartOSR.
  // SEE Matcher::match.
  c_return_value %{
    assert( ideal_reg >= Op_RegI && ideal_reg <= Op_RegL, "only return normal values" );
                               /* -- , -- , Op_RegN, Op_RegI, Op_RegP, Op_RegF, Op_RegD, Op_RegL */
    static int lo[Op_RegL+1] = { 0, 0, V0_num,       V0_num,       V0_num,       F0_num,       F0_num,    V0_num };
    static int hi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, V0_H_num,     OptoReg::Bad, F0_H_num,  V0_H_num };
    return OptoRegPair(hi[ideal_reg],lo[ideal_reg]);
  %}

  // Location of return values
  // register(s) contain(s) return value for Op_StartC2I and Op_Start.
  // SEE Matcher::match.

  return_value %{
    assert( ideal_reg >= Op_RegI && ideal_reg <= Op_RegL, "only return normal values" );
                               /* -- , -- , Op_RegN, Op_RegI, Op_RegP, Op_RegF, Op_RegD, Op_RegL */
    static int lo[Op_RegL+1] = { 0, 0, V0_num,       V0_num,       V0_num,       F0_num,       F0_num,     V0_num };
    static int hi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, V0_H_num,     OptoReg::Bad, F0_H_num,   V0_H_num};
    return OptoRegPair(hi[ideal_reg],lo[ideal_reg]);
  %}

%}

//----------ATTRIBUTES---------------------------------------------------------
//----------Operand Attributes-------------------------------------------------
op_attrib op_cost(0);        // Required cost attribute

//----------Instruction Attributes---------------------------------------------
ins_attrib ins_cost(100);       // Required cost attribute
ins_attrib ins_size(32);         // Required size attribute (in bits)
ins_attrib ins_pc_relative(0);  // Required PC Relative flag
ins_attrib ins_short_branch(0); // Required flag: is this instruction a
                                // non-matching short branch variant of some
                                                            // long branch?
ins_attrib ins_alignment(4);    // Required alignment attribute (must be a power of 2)
                                // specifies the alignment that some part of the instruction (not
                                // necessarily the start) requires.  If > 1, a compute_padding()
                                // function must be provided for the instruction

//----------OPERANDS-----------------------------------------------------------
// Operand definitions must precede instruction definitions for correct parsing
// in the ADLC because operands constitute user defined types which are used in
// instruction definitions.

// Vectors

operand vReg() %{
  constraint(ALLOC_IN_RC(dynamic));
  match(VecS);
  match(VecD);
  match(VecX);
  match(VecY);

  format %{ %}
  interface(REG_INTER);
%}

operand vecS() %{
  constraint(ALLOC_IN_RC(flt_reg));
  match(VecS);

  format %{ %}
  interface(REG_INTER);
%}

operand vecD() %{
  constraint(ALLOC_IN_RC(dbl_reg));
  match(VecD);

  format %{ %}
  interface(REG_INTER);
%}

operand vecX() %{
  constraint(ALLOC_IN_RC(vectorx_reg));
  match(VecX);

  format %{ %}
  interface(REG_INTER);
%}

operand vecY() %{
  constraint(ALLOC_IN_RC(vectory_reg));
  match(VecY);

   format %{ %}
   interface(REG_INTER);
%}

// Flags register, used as output of compare instructions
operand FlagsReg() %{
  constraint(ALLOC_IN_RC(t0_reg));
  match(RegFlags);

  format %{ "T0" %}
  interface(REG_INTER);
%}

//----------Simple Operands----------------------------------------------------
// TODO: Should we need to define some more special immediate number ?
// Immediate Operands
// Integer Immediate
operand immI() %{
  match(ConI);

  op_cost(20);
  format %{ %}
  interface(CONST_INTER);
%}

operand immIU1() %{
  predicate((0 <= n->get_int()) && (n->get_int() <= 1));
  match(ConI);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

operand immIU2() %{
  predicate((0 <= n->get_int()) && (n->get_int() <= 3));
  match(ConI);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

operand immIU3() %{
  predicate((0 <= n->get_int()) && (n->get_int() <= 7));
  match(ConI);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

operand immIU4() %{
  predicate((0 <= n->get_int()) && (n->get_int() <= 15));
  match(ConI);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

operand immIU5() %{
  predicate((0 <= n->get_int()) && (n->get_int() <= 31));
  match(ConI);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

operand immIU6() %{
  predicate((0 <= n->get_int()) && (n->get_int() <= 63));
  match(ConI);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

operand immIU8() %{
  predicate((0 <= n->get_int()) && (n->get_int() <= 255));
  match(ConI);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

operand immI10() %{
  predicate((-512 <= n->get_int()) && (n->get_int() <= 511));
  match(ConI);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

operand immI12() %{
  predicate((-2048 <= n->get_int()) && (n->get_int() <= 2047));
  match(ConI);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

operand immI_M65536() %{
  predicate(n->get_int() == -65536);
  match(ConI);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

// Constant for decrement
operand immI_M1() %{
  predicate(n->get_int() == -1);
  match(ConI);

  op_cost(0);
  format %{ %}
  interface(CONST_INTER);
%}

// Constant for zero
operand immI_0() %{
  predicate(n->get_int() == 0);
  match(ConI);

  op_cost(0);
  format %{ %}
  interface(CONST_INTER);
%}

operand immI_1() %{
  predicate(n->get_int() == 1);
  match(ConI);

  op_cost(0);
  format %{ %}
  interface(CONST_INTER);
%}

operand immI_2() %{
  predicate(n->get_int() == 2);
  match(ConI);

  op_cost(0);
  format %{ %}
  interface(CONST_INTER);
%}

operand immI_4() %{
  predicate(n->get_int() == 4);
  match(ConI);

  op_cost(0);
  format %{ %}
  interface(CONST_INTER);
%}

operand immI_8() %{
  predicate(n->get_int() == 8);
  match(ConI);

  op_cost(0);
  format %{ %}
  interface(CONST_INTER);
%}

operand immI_16() %{
  predicate(n->get_int() == 16);
  match(ConI);

  format %{ %}
  interface(CONST_INTER);
%}

operand immI_24() %{
  predicate(n->get_int() == 24);
  match(ConI);

  format %{ %}
  interface(CONST_INTER);
%}

// Constant for long shifts
operand immI_32() %{
  predicate(n->get_int() == 32);
  match(ConI);

  op_cost(0);
  format %{ %}
  interface(CONST_INTER);
%}

// Constant for byte-wide masking
operand immI_255() %{
  predicate(n->get_int() == 255);
  match(ConI);

  op_cost(0);
  format %{ %}
  interface(CONST_INTER);
%}

operand immI_65535() %{
  predicate(n->get_int() == 65535);
  match(ConI);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

operand immI_MaxI() %{
  predicate(n->get_int() == 2147483647);
  match(ConI);

  op_cost(0);
  format %{ %}
  interface(CONST_INTER);
%}

operand immI_M2047_2048() %{
  predicate((-2047 <= n->get_int()) && (n->get_int() <= 2048));
  match(ConI);

  op_cost(10);
  format %{ %}
  interface(CONST_INTER);
%}

// Valid scale values for addressing modes
operand immI_0_3() %{
  predicate(0 <= n->get_int() && (n->get_int() <= 3));
  match(ConI);

  format %{ %}
  interface(CONST_INTER);
%}

operand immI_0_31() %{
  predicate(n->get_int() >= 0 && n->get_int() <= 31);
  match(ConI);

  op_cost(0);
  format %{ %}
  interface(CONST_INTER);
%}

operand immI_0_4095() %{
  predicate(n->get_int() >= 0 && n->get_int() <= 4095);
  match(ConI);
  op_cost(0);

  format %{ %}
  interface(CONST_INTER);
%}

operand immI_1_4() %{
  predicate(1 <= n->get_int() && (n->get_int() <= 4));
  match(ConI);

  format %{ %}
  interface(CONST_INTER);
%}

operand immI_32_63() %{
  predicate(n->get_int() >= 32 && n->get_int() <= 63);
  match(ConI);
  op_cost(0);

  format %{ %}
  interface(CONST_INTER);
%}

operand immI_M128_255() %{
  predicate((-128 <= n->get_int()) && (n->get_int() <= 255));
  match(ConI);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

// Operand for non-negtive integer mask
operand immI_nonneg_mask() %{
  predicate((n->get_int() >= 0) && Assembler::is_nonneg_mask(n->get_int()));
  match(ConI);

  op_cost(0);
  format %{ %}
  interface(CONST_INTER);
%}

operand immI_zeroins_mask() %{
  predicate(Assembler::is_zeroins_mask(n->get_int()));
  match(ConI);

  op_cost(0);
  format %{ %}
  interface(CONST_INTER);
%}

// Long Immediate
operand immL() %{
  match(ConL);

  op_cost(20);
  format %{ %}
  interface(CONST_INTER);
%}

operand immLU5() %{
  predicate((0 <= n->get_long()) && (n->get_long() <= 31));
  match(ConL);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

operand immL10() %{
  predicate((-512 <= n->get_long()) && (n->get_long() <= 511));
  match(ConL);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

operand immAlign16() %{
  predicate((-65536 <= n->get_long()) && (n->get_long() <= 65535) && ((n->get_long() & 0x3) == 0));
  match(ConL);

  op_cost(10);
  format %{ %}
  interface(CONST_INTER);
%}

operand immL12() %{
  predicate((-2048 <= n->get_long()) && (n->get_long() <= 2047));
  match(ConL);

  op_cost(10);
  format %{ %}
  interface(CONST_INTER);
%}

// Long Immediate 32-bit signed
operand immL32()
%{
  predicate(n->get_long() == (int)n->get_long());
  match(ConL);

  op_cost(15);
  format %{ %}
  interface(CONST_INTER);
%}

// Long Immediate zero
operand immL_0() %{
  predicate(n->get_long() == 0L);
  match(ConL);
  op_cost(0);

  format %{ %}
  interface(CONST_INTER);
%}

operand immL_MaxUI() %{
  predicate(n->get_long() == 0xFFFFFFFFL);
  match(ConL);
  op_cost(20);

  format %{ %}
  interface(CONST_INTER);
%}

operand immL_M2047_2048() %{
  predicate((-2047 <= n->get_long()) && (n->get_long() <= 2048));
  match(ConL);

  op_cost(10);
  format %{ %}
  interface(CONST_INTER);
%}

operand immL_0_4095() %{
  predicate(n->get_long() >= 0 && n->get_long() <= 4095);
  match(ConL);
  op_cost(0);

  format %{ %}
  interface(CONST_INTER);
%}

// Operand for non-negtive long mask
operand immL_nonneg_mask() %{
  predicate((n->get_long() >= 0) && Assembler::is_nonneg_mask(n->get_long()));
  match(ConL);

  op_cost(0);
  format %{ %}
  interface(CONST_INTER);
%}

operand immL_zeroins_mask() %{
  predicate(Assembler::is_zeroins_mask(n->get_long()));
  match(ConL);

  op_cost(0);
  format %{ %}
  interface(CONST_INTER);
%}

operand immL_gt_7()
%{
  predicate(n->get_long() > 7);
  match(ConL);

  op_cost(0);
  format %{ %}
  interface(CONST_INTER);
%}

operand immL_gt_15()
%{
  predicate(n->get_long() > 15);
  match(ConL);

  op_cost(0);
  format %{ %}
  interface(CONST_INTER);
%}

// Pointer Immediate
operand immP() %{
  match(ConP);

  op_cost(10);
  format %{ %}
  interface(CONST_INTER);
%}

// null Pointer Immediate
operand immP_0() %{
  predicate(n->get_ptr() == 0);
  match(ConP);
  op_cost(0);

  format %{ %}
  interface(CONST_INTER);
%}

// Pointer Immediate
operand immP_no_oop_cheap() %{
  predicate(!n->bottom_type()->isa_oop_ptr());
  match(ConP);

  op_cost(5);
  // formats are generated automatically for constants and base registers
  format %{ %}
  interface(CONST_INTER);
%}

// Pointer Immediate
operand immN() %{
  match(ConN);

  op_cost(10);
  format %{ %}
  interface(CONST_INTER);
%}

// null Pointer Immediate
operand immN_0() %{
  predicate(n->get_narrowcon() == 0);
  match(ConN);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

operand immNKlass() %{
  match(ConNKlass);

  op_cost(10);
  format %{ %}
  interface(CONST_INTER);
%}

// Single-precision floating-point immediate
operand immF() %{
  match(ConF);

  op_cost(20);
  format %{ %}
  interface(CONST_INTER);
%}

// Single-precision floating-point zero
operand immF_0() %{
  predicate(jint_cast(n->getf()) == 0);
  match(ConF);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

operand immFVec() %{
  predicate(UseLSX && Assembler::is_vec_imm(n->getf()));
  match(ConF);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

// Double-precision floating-point immediate
operand immD() %{
  match(ConD);

  op_cost(20);
  format %{ %}
  interface(CONST_INTER);
%}

// Double-precision floating-point zero
operand immD_0() %{
  predicate(jlong_cast(n->getd()) == 0);
  match(ConD);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

operand immDVec() %{
  predicate(UseLSX && Assembler::is_vec_imm(n->getd()));
  match(ConD);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

// Register Operands
// Integer Register
operand mRegI() %{
  constraint(ALLOC_IN_RC(int_reg));
  match(RegI);

  format %{ %}
  interface(REG_INTER);
%}

operand mS0RegI() %{
  constraint(ALLOC_IN_RC(s0_reg));
  match(RegI);
  match(mRegI);

  format %{ "S0" %}
  interface(REG_INTER);
%}

operand mS1RegI() %{
  constraint(ALLOC_IN_RC(s1_reg));
  match(RegI);
  match(mRegI);

  format %{ "S1" %}
  interface(REG_INTER);
%}

operand mS3RegI() %{
  constraint(ALLOC_IN_RC(s3_reg));
  match(RegI);
  match(mRegI);

  format %{ "S3" %}
  interface(REG_INTER);
%}

operand mS4RegI() %{
  constraint(ALLOC_IN_RC(s4_reg));
  match(RegI);
  match(mRegI);

  format %{ "S4" %}
  interface(REG_INTER);
%}

operand mS5RegI() %{
  constraint(ALLOC_IN_RC(s5_reg));
  match(RegI);
  match(mRegI);

  format %{ "S5" %}
  interface(REG_INTER);
%}

operand mS6RegI() %{
  constraint(ALLOC_IN_RC(s6_reg));
  match(RegI);
  match(mRegI);

  format %{ "S6" %}
  interface(REG_INTER);
%}

operand mS7RegI() %{
  constraint(ALLOC_IN_RC(s7_reg));
  match(RegI);
  match(mRegI);

  format %{ "S7" %}
  interface(REG_INTER);
%}


operand mT0RegI() %{
  constraint(ALLOC_IN_RC(t0_reg));
  match(RegI);
  match(mRegI);

  format %{ "T0" %}
  interface(REG_INTER);
%}

operand mT1RegI() %{
  constraint(ALLOC_IN_RC(t1_reg));
  match(RegI);
  match(mRegI);

  format %{ "T1" %}
  interface(REG_INTER);
%}

operand mT2RegI() %{
  constraint(ALLOC_IN_RC(t2_reg));
  match(RegI);
  match(mRegI);

  format %{ "T2" %}
  interface(REG_INTER);
%}

operand mT3RegI() %{
  constraint(ALLOC_IN_RC(t3_reg));
  match(RegI);
  match(mRegI);

  format %{ "T3" %}
  interface(REG_INTER);
%}

operand mT8RegI() %{
  constraint(ALLOC_IN_RC(t8_reg));
  match(RegI);
  match(mRegI);

  format %{ "T8" %}
  interface(REG_INTER);
%}

operand mT4RegI() %{
  constraint(ALLOC_IN_RC(t4_reg));
  match(RegI);
  match(mRegI);

  format %{ "T4" %}
  interface(REG_INTER);
%}

operand mA0RegI() %{
  constraint(ALLOC_IN_RC(a0_reg));
  match(RegI);
  match(mRegI);

  format %{ "A0" %}
  interface(REG_INTER);
%}

operand mA1RegI() %{
  constraint(ALLOC_IN_RC(a1_reg));
  match(RegI);
  match(mRegI);

  format %{ "A1" %}
  interface(REG_INTER);
%}

operand mA2RegI() %{
  constraint(ALLOC_IN_RC(a2_reg));
  match(RegI);
  match(mRegI);

  format %{ "A2" %}
  interface(REG_INTER);
%}

operand mA3RegI() %{
  constraint(ALLOC_IN_RC(a3_reg));
  match(RegI);
  match(mRegI);

  format %{ "A3" %}
  interface(REG_INTER);
%}

operand mA4RegI() %{
  constraint(ALLOC_IN_RC(a4_reg));
  match(RegI);
  match(mRegI);

  format %{ "A4" %}
  interface(REG_INTER);
%}

operand mA5RegI() %{
  constraint(ALLOC_IN_RC(a5_reg));
  match(RegI);
  match(mRegI);

  format %{ "A5" %}
  interface(REG_INTER);
%}

operand mA6RegI() %{
  constraint(ALLOC_IN_RC(a6_reg));
  match(RegI);
  match(mRegI);

  format %{ "A6" %}
  interface(REG_INTER);
%}

operand mA7RegI() %{
  constraint(ALLOC_IN_RC(a7_reg));
  match(RegI);
  match(mRegI);

  format %{ "A7" %}
  interface(REG_INTER);
%}

operand mRegN() %{
  constraint(ALLOC_IN_RC(int_reg));
  match(RegN);

  format %{ %}
  interface(REG_INTER);
%}

operand t0_RegN() %{
  constraint(ALLOC_IN_RC(t0_reg));
  match(RegN);
  match(mRegN);

  format %{ %}
  interface(REG_INTER);
%}

operand t1_RegN() %{
  constraint(ALLOC_IN_RC(t1_reg));
  match(RegN);
  match(mRegN);

  format %{ %}
  interface(REG_INTER);
%}

operand t3_RegN() %{
  constraint(ALLOC_IN_RC(t3_reg));
  match(RegN);
  match(mRegN);

  format %{ %}
  interface(REG_INTER);
%}

operand t8_RegN() %{
  constraint(ALLOC_IN_RC(t8_reg));
  match(RegN);
  match(mRegN);

  format %{ %}
  interface(REG_INTER);
%}

operand a0_RegN() %{
  constraint(ALLOC_IN_RC(a0_reg));
  match(RegN);
  match(mRegN);

  format %{ %}
  interface(REG_INTER);
%}

operand a1_RegN() %{
  constraint(ALLOC_IN_RC(a1_reg));
  match(RegN);
  match(mRegN);

  format %{ %}
  interface(REG_INTER);
%}

operand a2_RegN() %{
  constraint(ALLOC_IN_RC(a2_reg));
  match(RegN);
  match(mRegN);

  format %{ %}
  interface(REG_INTER);
%}

operand a3_RegN() %{
  constraint(ALLOC_IN_RC(a3_reg));
  match(RegN);
  match(mRegN);

  format %{ %}
  interface(REG_INTER);
%}

operand a4_RegN() %{
  constraint(ALLOC_IN_RC(a4_reg));
  match(RegN);
  match(mRegN);

  format %{ %}
  interface(REG_INTER);
%}

operand a5_RegN() %{
  constraint(ALLOC_IN_RC(a5_reg));
  match(RegN);
  match(mRegN);

  format %{ %}
  interface(REG_INTER);
%}

operand a6_RegN() %{
  constraint(ALLOC_IN_RC(a6_reg));
  match(RegN);
  match(mRegN);

  format %{ %}
  interface(REG_INTER);
%}

operand a7_RegN() %{
  constraint(ALLOC_IN_RC(a7_reg));
  match(RegN);
  match(mRegN);

  format %{ %}
  interface(REG_INTER);
%}

operand s0_RegN() %{
  constraint(ALLOC_IN_RC(s0_reg));
  match(RegN);
  match(mRegN);

  format %{ %}
  interface(REG_INTER);
%}

operand s1_RegN() %{
  constraint(ALLOC_IN_RC(s1_reg));
  match(RegN);
  match(mRegN);

  format %{ %}
  interface(REG_INTER);
%}

operand s2_RegN() %{
  constraint(ALLOC_IN_RC(s2_reg));
  match(RegN);
  match(mRegN);

  format %{ %}
  interface(REG_INTER);
%}

operand s3_RegN() %{
  constraint(ALLOC_IN_RC(s3_reg));
  match(RegN);
  match(mRegN);

  format %{ %}
  interface(REG_INTER);
%}

operand s4_RegN() %{
  constraint(ALLOC_IN_RC(s4_reg));
  match(RegN);
  match(mRegN);

  format %{ %}
  interface(REG_INTER);
%}

operand s5_RegN() %{
  constraint(ALLOC_IN_RC(s5_reg));
  match(RegN);
  match(mRegN);

  format %{ %}
  interface(REG_INTER);
%}

operand s6_RegN() %{
  constraint(ALLOC_IN_RC(s6_reg));
  match(RegN);
  match(mRegN);

  format %{ %}
  interface(REG_INTER);
%}

operand s7_RegN() %{
  constraint(ALLOC_IN_RC(s7_reg));
  match(RegN);
  match(mRegN);

  format %{ %}
  interface(REG_INTER);
%}

// Pointer Register
operand mRegP() %{
  constraint(ALLOC_IN_RC(p_reg));
  match(RegP);
  match(a0_RegP);
  match(javaThread_RegP);

  format %{  %}
  interface(REG_INTER);
%}

operand no_CR_mRegP() %{
  constraint(ALLOC_IN_RC(no_CR_reg));
  match(RegP);
  match(mRegP);

  format %{  %}
  interface(REG_INTER);
%}

operand p_has_s6_mRegP() %{
  constraint(ALLOC_IN_RC(p_has_s6_reg));
  match(RegP);
  match(mRegP);

  format %{  %}
  interface(REG_INTER);
%}

operand s1_RegP()
%{
  constraint(ALLOC_IN_RC(s1_long_reg));
  match(RegP);
  match(mRegP);

  format %{ %}
  interface(REG_INTER);
%}

operand s3_RegP()
%{
  constraint(ALLOC_IN_RC(s3_long_reg));
  match(RegP);
  match(mRegP);

  format %{ %}
  interface(REG_INTER);
%}

operand s4_RegP()
%{
  constraint(ALLOC_IN_RC(s4_long_reg));
  match(RegP);
  match(mRegP);

  format %{ %}
  interface(REG_INTER);
%}

operand s5_RegP()
%{
  constraint(ALLOC_IN_RC(s5_long_reg));
  match(RegP);
  match(mRegP);

  format %{ %}
  interface(REG_INTER);
%}

operand s6_RegP()
%{
  constraint(ALLOC_IN_RC(s6_long_reg));
  match(RegP);
  match(mRegP);

  format %{ %}
  interface(REG_INTER);
%}

// Java Thread Register
operand javaThread_RegP(mRegP reg)
%{
  constraint(ALLOC_IN_RC(s6_long_reg)); // S6 denotes TREG (java_thread)
  match(reg);
  op_cost(0);
  format %{ %}
  interface(REG_INTER);
%}

operand s7_RegP()
%{
  constraint(ALLOC_IN_RC(s7_long_reg));
  match(RegP);
  match(mRegP);

  format %{ %}
  interface(REG_INTER);
%}

operand t0_RegP()
%{
  constraint(ALLOC_IN_RC(t0_long_reg));
  match(RegP);
  match(mRegP);

  format %{ %}
  interface(REG_INTER);
%}

operand t1_RegP()
%{
  constraint(ALLOC_IN_RC(t1_long_reg));
  match(RegP);
  match(mRegP);

  format %{ %}
  interface(REG_INTER);
%}

operand t2_RegP()
%{
  constraint(ALLOC_IN_RC(t2_long_reg));
  match(RegP);
  match(mRegP);

  format %{ %}
  interface(REG_INTER);
%}

operand t3_RegP()
%{
  constraint(ALLOC_IN_RC(t3_long_reg));
  match(RegP);
  match(mRegP);
  format %{ %}
  interface(REG_INTER);
%}

operand t8_RegP()
%{
  constraint(ALLOC_IN_RC(t8_long_reg));
  match(RegP);
  match(mRegP);

  format %{ %}
  interface(REG_INTER);
%}

operand a0_RegP()
%{
  constraint(ALLOC_IN_RC(a0_long_reg));
  match(RegP);
  match(mRegP);

  format %{ %}
  interface(REG_INTER);
%}

operand a1_RegP()
%{
  constraint(ALLOC_IN_RC(a1_long_reg));
  match(RegP);
  match(mRegP);

  format %{ %}
  interface(REG_INTER);
%}

operand a2_RegP()
%{
  constraint(ALLOC_IN_RC(a2_long_reg));
  match(RegP);
  match(mRegP);

  format %{ %}
  interface(REG_INTER);
%}

operand a3_RegP()
%{
  constraint(ALLOC_IN_RC(a3_long_reg));
  match(RegP);
  match(mRegP);

  format %{ %}
  interface(REG_INTER);
%}

operand a4_RegP()
%{
  constraint(ALLOC_IN_RC(a4_long_reg));
  match(RegP);
  match(mRegP);

  format %{ %}
  interface(REG_INTER);
%}


operand a5_RegP()
%{
  constraint(ALLOC_IN_RC(a5_long_reg));
  match(RegP);
  match(mRegP);

  format %{ %}
  interface(REG_INTER);
%}

operand a6_RegP()
%{
  constraint(ALLOC_IN_RC(a6_long_reg));
  match(RegP);
  match(mRegP);

  format %{ %}
  interface(REG_INTER);
%}

operand a7_RegP()
%{
  constraint(ALLOC_IN_RC(a7_long_reg));
  match(RegP);
  match(mRegP);

  format %{ %}
  interface(REG_INTER);
%}

operand v0_RegP()
%{
  constraint(ALLOC_IN_RC(v0_long_reg));
  match(RegP);
  match(mRegP);

  format %{ %}
  interface(REG_INTER);
%}

operand v1_RegP()
%{
  constraint(ALLOC_IN_RC(v1_long_reg));
  match(RegP);
  match(mRegP);

  format %{ %}
  interface(REG_INTER);
%}

operand mRegL() %{
  constraint(ALLOC_IN_RC(long_reg));
  match(RegL);

  format %{ %}
  interface(REG_INTER);
%}

operand mRegI2L(mRegI reg) %{
  match(ConvI2L reg);

  format %{ %}
  interface(REG_INTER);
%}

operand mRegL2I(mRegL reg) %{
  match(ConvL2I reg);

  format %{ %}
  interface(REG_INTER);
%}

operand v0RegL() %{
  constraint(ALLOC_IN_RC(v0_long_reg));
  match(RegL);
  match(mRegL);

  format %{ %}
  interface(REG_INTER);
%}

operand v1RegL() %{
  constraint(ALLOC_IN_RC(v1_long_reg));
  match(RegL);
  match(mRegL);

  format %{ %}
  interface(REG_INTER);
%}

operand a0RegL() %{
  constraint(ALLOC_IN_RC(a0_long_reg));
  match(RegL);
  match(mRegL);

  format %{ "A0" %}
  interface(REG_INTER);
%}

operand a1RegL() %{
  constraint(ALLOC_IN_RC(a1_long_reg));
  match(RegL);
  match(mRegL);

  format %{ %}
  interface(REG_INTER);
%}

operand a2RegL() %{
  constraint(ALLOC_IN_RC(a2_long_reg));
  match(RegL);
  match(mRegL);

  format %{ %}
  interface(REG_INTER);
%}

operand a3RegL() %{
  constraint(ALLOC_IN_RC(a3_long_reg));
  match(RegL);
  match(mRegL);

  format %{ %}
  interface(REG_INTER);
%}

operand t0RegL() %{
  constraint(ALLOC_IN_RC(t0_long_reg));
  match(RegL);
  match(mRegL);

  format %{ %}
  interface(REG_INTER);
%}

operand t1RegL() %{
  constraint(ALLOC_IN_RC(t1_long_reg));
  match(RegL);
  match(mRegL);

  format %{ %}
  interface(REG_INTER);
%}

operand t2RegL() %{
  constraint(ALLOC_IN_RC(t2_long_reg));
  match(RegL);
  match(mRegL);

  format %{ %}
  interface(REG_INTER);
%}

operand t3RegL() %{
  constraint(ALLOC_IN_RC(t3_long_reg));
  match(RegL);
  match(mRegL);

  format %{ %}
  interface(REG_INTER);
%}

operand t8RegL() %{
  constraint(ALLOC_IN_RC(t8_long_reg));
  match(RegL);
  match(mRegL);

  format %{ %}
  interface(REG_INTER);
%}

operand a4RegL() %{
  constraint(ALLOC_IN_RC(a4_long_reg));
  match(RegL);
  match(mRegL);

  format %{ %}
  interface(REG_INTER);
%}

operand a5RegL() %{
  constraint(ALLOC_IN_RC(a5_long_reg));
  match(RegL);
  match(mRegL);

  format %{ %}
  interface(REG_INTER);
%}

operand a6RegL() %{
  constraint(ALLOC_IN_RC(a6_long_reg));
  match(RegL);
  match(mRegL);

  format %{ %}
  interface(REG_INTER);
%}

operand a7RegL() %{
  constraint(ALLOC_IN_RC(a7_long_reg));
  match(RegL);
  match(mRegL);

  format %{ %}
  interface(REG_INTER);
%}

operand s0RegL() %{
  constraint(ALLOC_IN_RC(s0_long_reg));
  match(RegL);
  match(mRegL);

  format %{ %}
  interface(REG_INTER);
%}

operand s1RegL() %{
  constraint(ALLOC_IN_RC(s1_long_reg));
  match(RegL);
  match(mRegL);

  format %{ %}
  interface(REG_INTER);
%}

operand s3RegL() %{
  constraint(ALLOC_IN_RC(s3_long_reg));
  match(RegL);
  match(mRegL);

  format %{ %}
  interface(REG_INTER);
%}

operand s4RegL() %{
  constraint(ALLOC_IN_RC(s4_long_reg));
  match(RegL);
  match(mRegL);

  format %{ %}
  interface(REG_INTER);
%}

operand s7RegL() %{
  constraint(ALLOC_IN_RC(s7_long_reg));
  match(RegL);
  match(mRegL);

  format %{ %}
  interface(REG_INTER);
%}

// Floating register operands
operand regF() %{
  constraint(ALLOC_IN_RC(flt_reg));
  match(RegF);

  format %{ %}
  interface(REG_INTER);
%}

//Double Precision Floating register operands
operand regD() %{
  constraint(ALLOC_IN_RC(dbl_reg));
  match(RegD);

  format %{ %}
  interface(REG_INTER);
%}

//----------Memory Operands----------------------------------------------------
// Indirect Memory Operand
operand indirect(mRegP reg) %{
  constraint(ALLOC_IN_RC(p_reg));
  match(reg);

  format %{ "[$reg] @ indirect" %}
  interface(MEMORY_INTER) %{
    base($reg);
    index(0xffffffff);  /* NO_INDEX */
    scale(0x0);
    disp(0x0);
  %}
%}

// Indirect Memory Plus Short Offset Operand
operand indOffset12(p_has_s6_mRegP reg, immL12 off)
%{
  constraint(ALLOC_IN_RC(p_reg));
  match(AddP reg off);

  op_cost(10);
  format %{ "[$reg + $off (12-bit)] @ indOffset12" %}
  interface(MEMORY_INTER) %{
    base($reg);
    index(0xffffffff); /* NO_INDEX */
    scale(0x0);
    disp($off);
  %}
%}

operand indOffset12I2L(mRegP reg, immI12 off)
%{
  constraint(ALLOC_IN_RC(p_reg));
  match(AddP reg (ConvI2L off));

  op_cost(10);
  format %{ "[$reg + $off (12-bit)] @ indOffset12I2L" %}
  interface(MEMORY_INTER) %{
    base($reg);
    index(0xffffffff); /* NO_INDEX */
    scale(0x0);
    disp($off);
  %}
%}

operand indOffset16(p_has_s6_mRegP reg, immAlign16 off)
%{
  constraint(ALLOC_IN_RC(p_reg));
  match(AddP reg off);

  op_cost(10);
  format %{ "[$reg + $off (16-bit)] @ indOffset16" %}
  interface(MEMORY_INTER) %{
    base($reg);
    index(0xffffffff); /* NO_INDEX */
    scale(0x0);
    disp($off);
  %}
%}

// Indirect Memory Plus Index Register
operand indIndex(mRegP addr, mRegL index) %{
  constraint(ALLOC_IN_RC(p_reg));
  match(AddP addr index);

  op_cost(20);
  format %{"[$addr + $index] @ indIndex" %}
  interface(MEMORY_INTER) %{
    base($addr);
    index($index);
    scale(0x0);
    disp(0x0);
  %}
%}

operand indIndexI2L(mRegP reg, mRegI ireg)
%{
  constraint(ALLOC_IN_RC(ptr_reg));
  match(AddP reg (ConvI2L ireg));
  op_cost(10);
  format %{ "[$reg + $ireg] @ indIndexI2L" %}
  interface(MEMORY_INTER) %{
    base($reg);
    index($ireg);
    scale(0x0);
    disp(0x0);
  %}
%}

// Indirect Memory Operand
operand indirectNarrow(mRegN reg)
%{
  predicate(CompressedOops::shift() == 0);
  constraint(ALLOC_IN_RC(p_reg));
  op_cost(10);
  match(DecodeN reg);

  format %{ "[$reg] @ indirectNarrow" %}
  interface(MEMORY_INTER) %{
    base($reg);
    index(0xffffffff);
    scale(0x0);
    disp(0x0);
  %}
%}

// Indirect Memory Plus Short Offset Operand
operand indOffset12Narrow(mRegN reg, immL12 off)
%{
  predicate(CompressedOops::shift() == 0);
  constraint(ALLOC_IN_RC(p_reg));
  op_cost(10);
  match(AddP (DecodeN reg) off);

  format %{ "[$reg + $off (12-bit)] @ indOffset12Narrow" %}
  interface(MEMORY_INTER) %{
    base($reg);
    index(0xffffffff);
    scale(0x0);
    disp($off);
  %}
%}

//----------Conditional Branch Operands----------------------------------------
// Comparison Op  - This is the operation of the comparison, and is limited to
//                  the following set of codes:
//                  L (<), LE (<=), G (>), GE (>=), E (==), NE (!=)
//
// Other attributes of the comparison, such as unsignedness, are specified
// by the comparison instruction that sets a condition code flags register.
// That result is represented by a flags operand whose subtype is appropriate
// to the unsignedness (etc.) of the comparison.
//
// Later, the instruction which matches both the Comparison Op (a Bool) and
// the flags (produced by the Cmp) specifies the coding of the comparison op
// by matching a specific subtype of Bool operand below, such as cmpOp.

// Comparison Code
operand cmpOp() %{
  match(Bool);

  format %{ "" %}
  interface(COND_INTER) %{
    equal(0x01);
    not_equal(0x02);
    greater(0x03);
    greater_equal(0x04);
    less(0x05);
    less_equal(0x06);
    overflow(0x7);
    no_overflow(0x8);
  %}
%}

operand cmpOpEqNe() %{
  match(Bool);
  predicate(n->as_Bool()->_test._test == BoolTest::ne
            || n->as_Bool()->_test._test == BoolTest::eq);

  format %{ "" %}
  interface(COND_INTER) %{
    equal(0x01);
    not_equal(0x02);
    greater(0x03);
    greater_equal(0x04);
    less(0x05);
    less_equal(0x06);
    overflow(0x7);
    no_overflow(0x8);
  %}
%}

//----------Special Memory Operands--------------------------------------------
// Stack Slot Operand - This operand is used for loading and storing temporary
//                      values on the stack where a match requires a value to
//                      flow through memory.
operand stackSlotP(sRegP reg) %{
  constraint(ALLOC_IN_RC(stack_slots));
  // No match rule because this operand is only generated in matching
  op_cost(50);
  format %{ "[$reg]" %}
  interface(MEMORY_INTER) %{
    base(0x1d);  // SP
    index(0xffffffff);  // No Index
    scale(0x0);  // No Scale
    disp($reg);  // Stack Offset
  %}
%}

operand stackSlotI(sRegI reg) %{
  constraint(ALLOC_IN_RC(stack_slots));
  // No match rule because this operand is only generated in matching
  op_cost(50);
  format %{ "[$reg]" %}
  interface(MEMORY_INTER) %{
    base(0x1d);  // SP
    index(0xffffffff);  // No Index
    scale(0x0);  // No Scale
    disp($reg);  // Stack Offset
  %}
%}

operand stackSlotF(sRegF reg) %{
  constraint(ALLOC_IN_RC(stack_slots));
  // No match rule because this operand is only generated in matching
  op_cost(50);
  format %{ "[$reg]" %}
  interface(MEMORY_INTER) %{
    base(0x1d);  // SP
    index(0xffffffff);  // No Index
    scale(0x0);  // No Scale
    disp($reg);  // Stack Offset
  %}
%}

operand stackSlotD(sRegD reg) %{
  constraint(ALLOC_IN_RC(stack_slots));
  // No match rule because this operand is only generated in matching
  op_cost(50);
  format %{ "[$reg]" %}
  interface(MEMORY_INTER) %{
    base(0x1d);  // SP
    index(0xffffffff);  // No Index
    scale(0x0);  // No Scale
    disp($reg);  // Stack Offset
  %}
%}

operand stackSlotL(sRegL reg) %{
  constraint(ALLOC_IN_RC(stack_slots));
  // No match rule because this operand is only generated in matching
  op_cost(50);
  format %{ "[$reg]" %}
  interface(MEMORY_INTER) %{
    base(0x1d);  // SP
    index(0xffffffff);  // No Index
    scale(0x0);  // No Scale
    disp($reg);  // Stack Offset
  %}
%}


//------------------------OPERAND CLASSES--------------------------------------
opclass memory( indirect, indOffset12, indOffset12I2L, indIndex, indIndexI2L,
                indirectNarrow, indOffset12Narrow);
opclass memory_loadRange(indOffset12, indirect);
opclass memory_exclusive(indOffset16, indirect);

opclass mRegLorI2L(mRegI2L, mRegL);
opclass mRegIorL2I(mRegI, mRegL2I);
opclass mRegLorP(mRegL, mRegP);

//----------PIPELINE-----------------------------------------------------------
// Rules which define the behavior of the target architectures pipeline.

pipeline %{

  //----------ATTRIBUTES---------------------------------------------------------
  attributes %{
    fixed_size_instructions;          // Fixed size instructions
    max_instructions_per_bundle = 1;     // 1 instruction per bundle
    max_bundles_per_cycle = 4;         // Up to 4 bundles per cycle
         bundle_unit_size=4;
    instruction_unit_size = 4;           // An instruction is 4 bytes long
    instruction_fetch_unit_size = 16;    // The processor fetches one line
    instruction_fetch_units = 1;         // of 16 bytes

    // List of nop instructions
    nops( MachNop );
  %}

  //----------RESOURCES----------------------------------------------------------
  // Resources are the functional units available to the machine

  resources(D1, D2, D3, D4, DECODE = D1 | D2 | D3 | D4,
            ALU1, ALU2, ALU3, ALU4, ALU = ALU1 | ALU2 | ALU3 | ALU4,
            FPU1, FPU2, FPU = FPU1 | FPU2,
            MEM1, MEM2, MEM = MEM1 | MEM2);

  //----------PIPELINE DESCRIPTION-----------------------------------------------
  // Pipeline Description specifies the stages in the machine's pipeline

  // PC:
  // IF: fetch
  // ID: decode
  // ID1: decode 1
  // ID2: decode 2
  // RN: register rename
  // SCHED: schedule
  // EMIT: emit
  // RD: read
  // CA: calculate
  // WB: write back
  // CM: commit

  pipe_desc(PC, IF, ID, ID1, ID2, RN, SCHED, EMIT, RD, CA, WB, CM);

  //----------PIPELINE CLASSES---------------------------------------------------
  // Pipeline Classes describe the stages in which input and output are
  // referenced by the hardware pipeline.

  // No.1 ALU reg-reg operation : dst <-- reg1 op reg2
  pipe_class ialu_reg_reg(mRegI dst, mRegI src1, mRegI src2) %{
    single_instruction;
    fixed_latency(1);
    src1   : RD(read);
    src2   : RD(read);
    dst    : WB(write);
    DECODE : ID;
    ALU    : CA;
  %}

  // No.2 ALU reg-imm operation : dst <-- reg1 op imm
  pipe_class ialu_reg_imm(mRegI dst, mRegI src) %{
    single_instruction;
    fixed_latency(1);
    src    : RD(read);
    dst    : WB(write);
    DECODE : ID;
    ALU    : CA;
  %}

  // No.3 Integer mult operation : dst <-- reg1 mult reg2
  pipe_class ialu_mult(mRegI dst, mRegI src1, mRegI src2) %{
    single_instruction;
    fixed_latency(3);
    src1   : RD(read);
    src2   : RD(read);
    dst    : WB(write);
    DECODE : ID;
    ALU    : CA;
  %}

  // No.4 Integer div operation : dst <-- reg1 div reg2
  pipe_class ialu_div(mRegI dst, mRegI src1, mRegI src2) %{
    single_instruction;
    fixed_latency(10);
    src1   : RD(read);
    src2   : RD(read);
    dst    : WB(write);
    DECODE : ID;
    ALU    : CA;
  %}

  // No.5 load from memory :
  pipe_class ialu_load(mRegL dst, memory mem) %{
    single_instruction;
    fixed_latency(4);
    mem    : RD(read);
    dst    : WB(write);
    DECODE : ID;
    MEM    : RD;
  %}

  // No.6 Store to Memory :
  pipe_class ialu_store(mRegL src, memory mem) %{
    single_instruction;
    fixed_latency(0);
    mem    : RD(read);
    src    : RD(read);
    DECODE : ID;
    MEM    : RD;
  %}

  // No.7 No instructions : do nothing
  pipe_class empty( ) %{
    instruction_count(0);
  %}

  // No.8 prefetch data :
  pipe_class pipe_prefetch( memory mem ) %{
    single_instruction;
    fixed_latency(0);
    mem    : RD(read);
    DECODE : ID;
    MEM    : RD;
  %}

  // No.9 UnConditional branch :
  pipe_class pipe_jump( label labl ) %{
    multiple_bundles;
    DECODE : ID;
    ALU    : RD;
  %}

  // No.10 ALU Conditional branch :
  pipe_class pipe_alu_branch(mRegI src1, mRegI src2, label labl ) %{
    multiple_bundles;
    src1   : RD(read);
    src2   : RD(read);
    DECODE : ID;
    ALU    : RD;
  %}

  // No.11 Floating FPU reg-reg operation : dst <-- reg
  //include  f{abs/neg}.{s/d}  fmov.{s/d}
  pipe_class fpu_absnegmov(regF dst, regF src) %{
    single_instruction;
    fixed_latency(1);
    src    : RD(read);
    dst    : WB(write);
    DECODE : ID;
    FPU    : CA;
  %}

  // No.12 Floating FPU reg-reg operation : dst <-- reg1 op reg2
  // include fsel
  pipe_class fpu_sel(regF dst, regF src1, regF src2) %{
    single_instruction;
    fixed_latency(1);
    src1   : RD(read);
    src2   : RD(read);
    dst    : WB(write);
    DECODE : ID;
    FPU    : CA;
  %}

  // No.13 Floating FPU reg-reg operation : dst <-- reg
  // include  fclass.s/d
  pipe_class fpu_class(regF dst, regF src) %{
    single_instruction;
    fixed_latency(2);
    src    : RD(read);
    dst    : WB(write);
    DECODE : ID;
    FPU    : CA;
  %}

  // No.14 Floating FPU reg-reg operation : dst <-- reg1 op reg2
  // include f{max/min}.s/d, f{maxa/mina}.s/d
  pipe_class fpu_maxmin(regF dst, regF src1, regF src2) %{
    single_instruction;
    fixed_latency(2);
    src1   : RD(read);
    src2   : RD(read);
    dst    : WB(write);
    DECODE : ID;
    FPU    : CA;
  %}

  // No.15 Floating FPU reg-reg operation : dst <-- reg
  // include  movgr2fr.{w/d}, movfr2gr.{w/d}
  pipe_class fpu_movgrfr(regF dst, regF src) %{
    single_instruction;
    fixed_latency(2);
    src    : RD(read);
    dst    : WB(write);
    DECODE : ID;
    FPU    : CA;
  %}

  // No.16 Floating FPU reg-reg operation : dst <-- reg
  // include  fcvt.s/d, ffint.{s/d}.{w/l}, ftint.{w/l}.{s.d}, ftint{rm/rp/rz/rne}.{w/l}.{s/d}, frint.{s/d}
  pipe_class fpu_cvt(regF dst, regF src) %{
    single_instruction;
    fixed_latency(4);
    src    : RD(read);
    dst    : WB(write);
    DECODE : ID;
    FPU    : CA;
  %}

  // No.17 Floating FPU reg-reg operation : dst <-- reg1 op reg2
  // include fadd.s/d, fsub.s/d, fmul.s/d, f{scaleb/copysign}.s/d
  pipe_class fpu_arith(regF dst, regF src1, regF src2) %{
    single_instruction;
    fixed_latency(5);
    src1   : RD(read);
    src2   : RD(read);
    dst    : WB(write);
    DECODE : ID;
    FPU    : CA;
  %}

  // No.18 Floating FPU reg-reg operation : dst <-- reg1 op reg2 op reg3
  // include f{madd/msub/nmadd/nmsub}.s/d
  pipe_class fpu_arith3(regF dst, regF src1, regF src2, regF src3) %{
    single_instruction;
    fixed_latency(5);
    src1   : RD(read);
    src2   : RD(read);
    src3   : RD(read);
    dst    : WB(write);
    DECODE : ID;
    FPU    : CA;
  %}

  // No.19 Floating FPU reg-reg operation : dst <-- reg
  // include flogb.s/d
  pipe_class fpu_logb(regF dst, regF src) %{
    single_instruction;
    fixed_latency(5);
    src    : RD(read);
    dst    : WB(write);
    DECODE : ID;
    FPU    : CA;
  %}

  // No.20 Floating div operation : dst <-- reg1 div reg2
  pipe_class fpu_div(regF dst, regF src1, regF src2) %{
    single_instruction;
    fixed_latency(10);
    src1   : RD(read);
    src2   : RD(read);
    dst    : WB(write);
    DECODE : ID;
    FPU2   : CA;
  %}

  // No.21 Load Floating from Memory :
  pipe_class fpu_load(regF dst, memory mem) %{
    single_instruction;
    fixed_latency(5);
    mem    : RD(read);
    dst    : WB(write);
    DECODE : ID;
    MEM    : RD;
  %}

  // No.22 Store Floating to Memory :
  pipe_class fpu_store(regF src, memory mem) %{
    single_instruction;
    fixed_latency(0);
    mem    : RD(read);
    src    : RD(read);
    DECODE : ID;
    MEM    : RD;
  %}

  // No.23 FPU Conditional branch :
  pipe_class pipe_fpu_branch(regF src1, regF src2, label labl ) %{
    multiple_bundles;
    src1   : RD(read);
    src2   : RD(read);
    DECODE : ID;
    ALU    : RD;
  %}

  // No.24
  pipe_class long_memory_op() %{
    instruction_count(10); multiple_bundles; force_serialization;
    fixed_latency(30);
  %}

  // No.25 Any operation requiring serialization :
  // EG.  DBAR/Atomic
  pipe_class pipe_serial()
  %{
    single_instruction;
    force_serialization;
    fixed_latency(16);
    DECODE : ID;
    MEM    : RD;
  %}

  // No.26 Piple slow : for multi-instructions
  pipe_class pipe_slow(  ) %{
    instruction_count(20);
    force_serialization;
    multiple_bundles;
    fixed_latency(50);
  %}

%}

//----------INSTRUCTIONS-------------------------------------------------------
//
// match      -- States which machine-independent subtree may be replaced
//               by this instruction.
// ins_cost   -- The estimated cost of this instruction is used by instruction
//               selection to identify a minimum cost tree of machine
//               instructions that matches a tree of machine-independent
//               instructions.
// format     -- A string providing the disassembly for this instruction.
//               The value of an instruction's operand may be inserted
//               by referring to it with a '$' prefix.
// opcode     -- Three instruction opcodes may be provided.  These are referred
//               to within an encode class as $primary, $secondary, and $tertiary
//               respectively.  The primary opcode is commonly used to
//               indicate the type of machine instruction, while secondary
//               and tertiary are often used for prefix options or addressing
//               modes.
// ins_encode -- A list of encode classes with parameters. The encode class
//               name must have been defined in an 'enc_class' specification
//               in the encode section of the architecture description.


// Load Integer
instruct loadI(mRegI dst, memory mem) %{
  match(Set dst (LoadI mem));

  ins_cost(125);
  format %{ "ld_w    $dst, $mem   #@loadI" %}
  ins_encode %{
    __ loadstore_enc($dst$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_INT);
  %}
  ins_pipe( ialu_load );
%}

instruct loadI_convI2L(mRegL dst, memory mem) %{
  match(Set dst (ConvI2L (LoadI mem)));

  ins_cost(125);
  format %{ "ld_w    $dst, $mem   #@loadI_convI2L" %}
  ins_encode %{
    __ loadstore_enc($dst$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_INT);
  %}
  ins_pipe( ialu_load );
%}

// Load Integer (32 bit signed) to Byte (8 bit signed)
instruct loadI2B(mRegI dst, memory mem, immI_24 twentyfour) %{
  match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));

  ins_cost(125);
  format %{ "ld_b  $dst, $mem\t# int -> byte #@loadI2B" %}
  ins_encode %{
    __ loadstore_enc($dst$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_BYTE);
  %}
  ins_pipe( ialu_load );
%}

// Load Integer (32 bit signed) to Unsigned Byte (8 bit UNsigned)
instruct loadI2UB(mRegI dst, memory mem, immI_255 mask) %{
  match(Set dst (AndI (LoadI mem) mask));

  ins_cost(125);
  format %{ "ld_bu  $dst, $mem\t# int -> ubyte #@loadI2UB" %}
    ins_encode %{
    __ loadstore_enc($dst$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_U_BYTE);
  %}
  ins_pipe( ialu_load );
%}

// Load Integer (32 bit signed) to Short (16 bit signed)
instruct loadI2S(mRegI dst, memory mem, immI_16 sixteen) %{
  match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));

  ins_cost(125);
  format %{ "ld_h  $dst, $mem\t# int -> short #@loadI2S" %}
  ins_encode %{
    __ loadstore_enc($dst$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_SHORT);
  %}
  ins_pipe( ialu_load );
%}

// Load Integer (32 bit signed) to Unsigned Short/Char (16 bit UNsigned)
instruct loadI2US(mRegI dst, memory mem, immI_65535 mask) %{
  match(Set dst (AndI (LoadI mem) mask));

  ins_cost(125);
  format %{ "ld_hu  $dst, $mem\t# int -> ushort/char #@loadI2US" %}
  ins_encode %{
    __ loadstore_enc($dst$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_U_SHORT);
  %}
  ins_pipe( ialu_load );
%}

// Load Long.
instruct loadL(mRegL dst, memory mem) %{
//  predicate(!((LoadLNode*)n)->require_atomic_access());
  match(Set dst (LoadL mem));

  ins_cost(250);
  format %{ "ld_d    $dst, $mem   #@loadL" %}
  ins_encode %{
    __ loadstore_enc($dst$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_LONG);
  %}
  ins_pipe( ialu_load );
%}

// Load Long - UNaligned
instruct loadL_unaligned(mRegL dst, memory mem) %{
  match(Set dst (LoadL_unaligned mem));

  // FIXME: Need more effective ldl/ldr
  ins_cost(450);
  format %{ "ld_d    $dst, $mem   #@loadL_unaligned\n\t" %}
  ins_encode %{
    __ loadstore_enc($dst$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_LONG);
  %}
  ins_pipe( ialu_load );
%}

// Store Long
instruct storeL_reg(memory mem, mRegL src) %{
  match(Set mem (StoreL mem src));
  predicate(!needs_releasing_store(n));

  ins_cost(200);
  format %{ "st_d    $mem,   $src #@storeL_reg\n" %}
  ins_encode %{
    __ loadstore_enc($src$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::STORE_LONG);
  %}
  ins_pipe( ialu_store );
%}

instruct storeL_reg_volatile(indirect mem, mRegL src) %{
  match(Set mem (StoreL mem src));

  ins_cost(205);
  format %{ "amswap_db_d    R0, $src, $mem #@storeL_reg\n" %}
  ins_encode %{
    __ amswap_db_d(R0, $src$$Register, as_Register($mem$$base));
  %}
  ins_pipe( pipe_serial );
%}

instruct storeL_immL_0(memory mem, immL_0 zero) %{
  match(Set mem (StoreL mem zero));
  predicate(!needs_releasing_store(n));

  ins_cost(180);
  format %{ "st_d    zero, $mem #@storeL_immL_0" %}
  ins_encode %{
     __ loadstore_enc(R0, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::STORE_LONG);
  %}
  ins_pipe( ialu_store );
%}

instruct storeL_immL_0_volatile(indirect mem, immL_0 zero) %{
  match(Set mem (StoreL mem zero));

  ins_cost(185);
  format %{ "amswap_db_d    AT, R0, $mem #@storeL_immL_0" %}
  ins_encode %{
    __ amswap_db_d(AT, R0, as_Register($mem$$base));
  %}
  ins_pipe( pipe_serial );
%}

// Load Compressed Pointer
instruct loadN(mRegN dst, memory mem)
%{
   match(Set dst (LoadN mem));

   ins_cost(125);
   format %{ "ld_wu    $dst, $mem\t# compressed ptr @ loadN" %}
   ins_encode %{
     relocInfo::relocType disp_reloc = $mem->disp_reloc();
     assert(disp_reloc == relocInfo::none, "cannot have disp");
     __ loadstore_enc($dst$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_U_INT);
   %}
   ins_pipe( ialu_load );
%}

instruct loadN2P(mRegP dst, memory mem)
%{
   match(Set dst (DecodeN (LoadN mem)));
   predicate(CompressedOops::base() == nullptr && CompressedOops::shift() == 0);

   ins_cost(125);
   format %{ "ld_wu    $dst, $mem\t# @ loadN2P" %}
   ins_encode %{
     relocInfo::relocType disp_reloc = $mem->disp_reloc();
     assert(disp_reloc == relocInfo::none, "cannot have disp");
     __ loadstore_enc($dst$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_U_INT);
   %}
   ins_pipe( ialu_load );
%}

// Load Pointer
instruct loadP(mRegP dst, memory mem) %{
  match(Set dst (LoadP mem));
  predicate(n->as_Load()->barrier_data() == 0);

  ins_cost(125);
  format %{ "ld_d    $dst, $mem #@loadP" %}
  ins_encode %{
    relocInfo::relocType disp_reloc = $mem->disp_reloc();
    assert(disp_reloc == relocInfo::none, "cannot have disp");
    __ block_comment("loadP");
    __ loadstore_enc($dst$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_LONG);
  %}
  ins_pipe( ialu_load );
%}

// Load Klass Pointer
instruct loadKlass(mRegP dst, memory mem) %{
  match(Set dst (LoadKlass mem));

  ins_cost(125);
  format %{ "MOV    $dst,$mem @ loadKlass" %}
  ins_encode %{
    relocInfo::relocType disp_reloc = $mem->disp_reloc();
    assert(disp_reloc == relocInfo::none, "cannot have disp");
    __ loadstore_enc($dst$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_LONG);
  %}
  ins_pipe( ialu_load );
%}

// Load narrow Klass Pointer
instruct loadNKlass(mRegN dst, memory mem)
%{
  match(Set dst (LoadNKlass mem));

  ins_cost(125);
  format %{ "ld_wu    $dst, $mem\t# compressed klass ptr @ loadNKlass" %}
  ins_encode %{
    relocInfo::relocType disp_reloc = $mem->disp_reloc();
    assert(disp_reloc == relocInfo::none, "cannot have disp");
    __ loadstore_enc($dst$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_U_INT);
  %}
  ins_pipe( ialu_load );
%}

instruct loadN2PKlass(mRegP dst, memory mem)
%{
  match(Set dst (DecodeNKlass (LoadNKlass mem)));
  predicate(CompressedKlassPointers::base() == nullptr && CompressedKlassPointers::shift() == 0);

  ins_cost(125);
  format %{ "ld_wu    $dst, $mem\t# compressed klass ptr @ loadN2PKlass" %}
  ins_encode %{
    relocInfo::relocType disp_reloc = $mem->disp_reloc();
    assert(disp_reloc == relocInfo::none, "cannot have disp");
    __ loadstore_enc($dst$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_U_INT);
  %}
  ins_pipe( ialu_load );
%}

// Load Constant
instruct loadConI(mRegI dst, immI src) %{
  match(Set dst src);

  ins_cost(120);
  format %{ "mov    $dst, $src #@loadConI" %}
  ins_encode %{
    Register dst = $dst$$Register;
    int    value = $src$$constant;
    __ li(dst, value);
  %}
  ins_pipe( ialu_reg_reg );
%}


instruct loadConL(mRegL dst, immL src) %{
  match(Set dst src);
  ins_cost(120);
  format %{ "li   $dst, $src @ loadConL" %}
  ins_encode %{
    __ li($dst$$Register, $src$$constant);
  %}
  ins_pipe( ialu_reg_reg );
%}

// Load Range
instruct loadRange(mRegI dst, memory_loadRange mem) %{
  match(Set dst (LoadRange mem));

  ins_cost(125);
  format %{ "MOV    $dst,$mem @ loadRange" %}
  ins_encode %{
    __ loadstore_enc($dst$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_INT);
  %}
  ins_pipe( ialu_load );
%}


instruct storeP(memory mem, mRegP src ) %{
  match(Set mem (StoreP mem src));
  predicate(!needs_releasing_store(n));

  ins_cost(125);
  format %{ "st_d    $src, $mem #@storeP" %}
  ins_encode %{
    __ loadstore_enc($src$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::STORE_LONG);
  %}
  ins_pipe( ialu_store );
%}

instruct storeP_volatile(indirect mem, mRegP src ) %{
  match(Set mem (StoreP mem src));

  ins_cost(130);
  format %{ "amswap_db_d    R0, $src, $mem #@storeP" %}
  ins_encode %{
    __ amswap_db_d(R0, $src$$Register, as_Register($mem$$base));
  %}
  ins_pipe( pipe_serial );
%}

// Store null Pointer, mark word, or other simple pointer constant.
instruct storeImmP_immP_0(memory mem, immP_0 zero) %{
  match(Set mem (StoreP mem zero));
  predicate(!needs_releasing_store(n));

  ins_cost(125);
  format %{ "mov    $mem, $zero #@storeImmP_0" %}
    ins_encode %{
     __ loadstore_enc(R0, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::STORE_LONG);
  %}
  ins_pipe( ialu_store );
%}

instruct storeImmP_immP_0_volatile(indirect mem, immP_0 zero) %{
  match(Set mem (StoreP mem zero));

  ins_cost(130);
  format %{ "amswap_db_d    AT, R0, $mem #@storeImmP_0" %}
  ins_encode %{
    __ amswap_db_d(AT, R0, as_Register($mem$$base));
  %}
  ins_pipe( pipe_serial );
%}

// Store Compressed Pointer
instruct storeN(memory mem, mRegN src)
%{
  match(Set mem (StoreN mem src));
  predicate(!needs_releasing_store(n));

  ins_cost(125);
  format %{ "st_w    $mem, $src\t# compressed ptr @ storeN" %}
  ins_encode %{
    __ loadstore_enc($src$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::STORE_INT);
  %}
  ins_pipe( ialu_store );
%}

instruct storeN_volatile(indirect mem, mRegN src)
%{
  match(Set mem (StoreN mem src));

  ins_cost(130);
  format %{ "amswap_db_w    R0, $src, $mem # compressed ptr @ storeN" %}
  ins_encode %{
    __ amswap_db_w(R0, $src$$Register, as_Register($mem$$base));
  %}
  ins_pipe( pipe_serial );
%}

instruct storeP2N(memory mem, mRegP src)
%{
  match(Set mem (StoreN mem (EncodeP src)));
  predicate(CompressedOops::base() == nullptr && CompressedOops::shift() == 0 && !needs_releasing_store(n));

  ins_cost(125);
  format %{ "st_w    $mem, $src\t# @ storeP2N" %}
  ins_encode %{
    __ loadstore_enc($src$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::STORE_INT);
  %}
  ins_pipe( ialu_store );
%}

instruct storeP2N_volatile(indirect mem, mRegP src)
%{
  match(Set mem (StoreN mem (EncodeP src)));
  predicate(CompressedOops::base() == nullptr && CompressedOops::shift() == 0);

  ins_cost(130);
  format %{ "amswap_db_w    R0, $src, $mem # @ storeP2N" %}
  ins_encode %{
    __ amswap_db_w(R0, $src$$Register, as_Register($mem$$base));
  %}
  ins_pipe( pipe_serial );
%}

instruct storeNKlass(memory mem, mRegN src)
%{
  match(Set mem (StoreNKlass mem src));
  predicate(!needs_releasing_store(n));

  ins_cost(125);
  format %{ "st_w    $mem, $src\t# compressed klass ptr @ storeNKlass" %}
  ins_encode %{
    __ loadstore_enc($src$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::STORE_INT);
  %}
  ins_pipe( ialu_store );
%}

instruct storeNKlass_volatile(indirect mem, mRegN src)
%{
  match(Set mem (StoreNKlass mem src));

  ins_cost(130);
  format %{ "amswap_db_w    R0, $src, $mem # compressed klass ptr @ storeNKlass" %}
  ins_encode %{
    __ amswap_db_w(R0, $src$$Register, as_Register($mem$$base));
  %}
  ins_pipe( pipe_serial );
%}

instruct storeP2NKlass(memory mem, mRegP src)
%{
  match(Set mem (StoreNKlass mem (EncodePKlass src)));
  predicate(CompressedKlassPointers::base() == nullptr && CompressedKlassPointers::shift() == 0 && !needs_releasing_store(n));

  ins_cost(125);
  format %{ "st_w    $mem, $src\t# @ storeP2NKlass" %}
  ins_encode %{
    __ loadstore_enc($src$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::STORE_INT);
  %}
  ins_pipe( ialu_store );
%}

instruct storeP2NKlass_volatile(indirect mem, mRegP src)
%{
  match(Set mem (StoreNKlass mem (EncodePKlass src)));
  predicate(CompressedKlassPointers::base() == nullptr && CompressedKlassPointers::shift() == 0);

  ins_cost(130);
  format %{ "amswap_db_w    R0, $src, $mem # @ storeP2NKlass" %}
  ins_encode %{
    __ amswap_db_w(R0, $src$$Register, as_Register($mem$$base));
  %}
  ins_pipe( pipe_serial );
%}

instruct storeImmN_immN_0(memory mem, immN_0 zero)
%{
  match(Set mem (StoreN mem zero));
  predicate(!needs_releasing_store(n));

  ins_cost(125);
  format %{ "storeN0    zero, $mem\t# compressed ptr" %}
  ins_encode %{
     __ loadstore_enc(R0, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::STORE_INT);
  %}
  ins_pipe( ialu_store );
%}

instruct storeImmN_immN_0_volatile(indirect mem, immN_0 zero)
%{
  match(Set mem (StoreN mem zero));

  ins_cost(130);
  format %{ "amswap_db_w    AT, R0, $mem # compressed ptr" %}
  ins_encode %{
    __ amswap_db_w(AT, R0, as_Register($mem$$base));
  %}
  ins_pipe( pipe_serial );
%}

// Store Byte
instruct storeB_immB_0(memory mem, immI_0 zero) %{
  match(Set mem (StoreB mem zero));

  format %{ "mov    $mem, zero #@storeB_immB_0" %}
  ins_encode %{
    __ loadstore_enc(R0, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::STORE_BYTE);
  %}
  ins_pipe( ialu_store );
%}

instruct storeB(memory mem, mRegIorL2I src) %{
  match(Set mem (StoreB mem src));

  ins_cost(125);
  format %{ "st_b    $src, $mem #@storeB" %}
  ins_encode %{
    __ loadstore_enc($src$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::STORE_BYTE);
  %}
  ins_pipe( ialu_store );
%}

// Load Byte (8bit signed)
instruct loadB(mRegI dst, memory mem) %{
  match(Set dst (LoadB mem));

  ins_cost(125);
  format %{ "ld_b   $dst, $mem #@loadB" %}
  ins_encode %{
    __ loadstore_enc($dst$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_BYTE);
  %}
  ins_pipe( ialu_load );
%}

instruct loadB_convI2L(mRegL dst, memory mem) %{
  match(Set dst (ConvI2L (LoadB mem)));

  ins_cost(125);
  format %{ "ld_b   $dst, $mem #@loadB_convI2L" %}
  ins_encode %{
    __ loadstore_enc($dst$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_BYTE);
  %}
  ins_pipe( ialu_load );
%}

// Load Byte (8bit UNsigned)
instruct loadUB(mRegI dst, memory mem) %{
  match(Set dst (LoadUB mem));

  ins_cost(125);
  format %{ "ld_bu   $dst, $mem #@loadUB" %}
  ins_encode %{
    __ loadstore_enc($dst$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_U_BYTE);
  %}
  ins_pipe( ialu_load );
%}

instruct loadUB_convI2L(mRegL dst, memory mem) %{
  match(Set dst (ConvI2L (LoadUB mem)));

  ins_cost(125);
  format %{ "ld_bu   $dst, $mem #@loadUB_convI2L" %}
  ins_encode %{
    __ loadstore_enc($dst$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_U_BYTE);
  %}
  ins_pipe( ialu_load );
%}

// Load Short (16bit signed)
instruct loadS(mRegI dst, memory mem) %{
  match(Set dst (LoadS mem));

  ins_cost(125);
  format %{ "ld_h   $dst, $mem #@loadS" %}
  ins_encode %{
    __ loadstore_enc($dst$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_SHORT);
  %}
  ins_pipe( ialu_load );
%}

// Load Short (16 bit signed) to Byte (8 bit signed)
instruct loadS2B(mRegI dst, memory mem, immI_24 twentyfour) %{
  match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));

  ins_cost(125);
  format %{ "ld_b $dst, $mem\t# short -> byte #@loadS2B" %}
  ins_encode %{
    __ loadstore_enc($dst$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_BYTE);
  %}
  ins_pipe( ialu_load );
%}

instruct loadS_convI2L(mRegL dst, memory mem) %{
  match(Set dst (ConvI2L (LoadS mem)));

  ins_cost(125);
  format %{ "ld_h   $dst, $mem #@loadS_convI2L" %}
  ins_encode %{
    __ loadstore_enc($dst$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_SHORT);
  %}
  ins_pipe( ialu_load );
%}

// Store Integer Immediate
instruct storeI_immI_0(memory mem, immI_0 zero) %{
  match(Set mem (StoreI mem zero));
  predicate(!needs_releasing_store(n));

  ins_cost(120);
  format %{ "mov    $mem, zero #@storeI_immI_0" %}
  ins_encode %{
    __ loadstore_enc(R0, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::STORE_INT);
  %}
  ins_pipe( ialu_store );
%}

instruct storeI_immI_0_volatile(indirect mem, immI_0 zero) %{
  match(Set mem (StoreI mem zero));

  ins_cost(125);
  format %{ "amswap_db_w    AT, R0, $mem #@storeI_immI_0" %}
  ins_encode %{
    __ amswap_db_w(AT, R0, as_Register($mem$$base));
  %}
  ins_pipe( pipe_serial );
%}

// Store Integer
instruct storeI(memory mem, mRegIorL2I src) %{
  match(Set mem (StoreI mem src));
  predicate(!needs_releasing_store(n));

  ins_cost(125);
  format %{ "st_w    $mem, $src #@storeI" %}
  ins_encode %{
    __ loadstore_enc($src$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::STORE_INT);
  %}
  ins_pipe( ialu_store );
%}

instruct storeI_volatile(indirect mem, mRegIorL2I src) %{
  match(Set mem (StoreI mem src));

  ins_cost(130);
  format %{ "amswap_db_w    R0, $src, $mem #@storeI" %}
  ins_encode %{
    __ amswap_db_w(R0, $src$$Register, as_Register($mem$$base));
  %}
  ins_pipe( pipe_serial );
%}

// Load Float
instruct loadF(regF dst, memory mem) %{
  match(Set dst (LoadF mem));

  ins_cost(150);
  format %{ "loadF $dst, $mem #@loadF" %}
  ins_encode %{
    __ loadstore_enc($dst$$FloatRegister, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_FLOAT);
  %}
  ins_pipe( fpu_load );
%}

instruct loadConP_general(mRegP dst, immP src) %{
  match(Set dst src);

  ins_cost(120);
  format %{ "li   $dst, $src #@loadConP_general" %}

  ins_encode %{
    Register dst = $dst$$Register;
    long* value = (long*)$src$$constant;

    if ($src->constant_reloc() == relocInfo::metadata_type){
      __ mov_metadata(dst, (Metadata*)value);
    } else if($src->constant_reloc() == relocInfo::oop_type){
      __ movoop(dst, (jobject)value);
    } else if ($src->constant_reloc() == relocInfo::none) {
      __ li(dst, (long)value);
    }
  %}

  ins_pipe( pipe_slow );
%}

instruct loadConP_no_oop_cheap(mRegP dst, immP_no_oop_cheap src) %{
  match(Set dst src);

  ins_cost(80);
  format %{ "li    $dst, $src @ loadConP_no_oop_cheap" %}

  ins_encode %{
    if ($src->constant_reloc() == relocInfo::metadata_type) {
      __ mov_metadata($dst$$Register, (Metadata*)$src$$constant);
    } else {
      __ li($dst$$Register, $src$$constant);
    }
  %}

  ins_pipe( ialu_reg_reg );
%}

instruct loadConP_immP_0(mRegP dst, immP_0 src)
%{
  match(Set dst src);

  ins_cost(50);
  format %{ "mov    $dst, R0\t# ptr" %}
  ins_encode %{
     Register dst_reg = $dst$$Register;
     __ add_d(dst_reg, R0, R0);
  %}
  ins_pipe( ialu_reg_reg );
%}

instruct loadConN_immN_0(mRegN dst, immN_0 src) %{
  match(Set dst src);
  format %{ "move    $dst, R0\t# compressed null ptr" %}
  ins_encode %{
    __ move($dst$$Register, R0);
  %}
  ins_pipe( ialu_reg_reg );
%}

instruct loadConN(mRegN dst, immN src) %{
  match(Set dst src);

  ins_cost(125);
  format %{ "li    $dst, $src\t# compressed ptr @ loadConN" %}
  ins_encode %{
    Register dst = $dst$$Register;
    __ set_narrow_oop(dst, (jobject)$src$$constant);
  %}
  ins_pipe( pipe_slow );
%}

instruct loadConNKlass(mRegN dst, immNKlass src) %{
  match(Set dst src);

  ins_cost(125);
  format %{ "li    $dst, $src\t# compressed klass ptr @ loadConNKlass" %}
  ins_encode %{
    Register dst = $dst$$Register;
    __ set_narrow_klass(dst, (Klass*)$src$$constant);
  %}
  ins_pipe( pipe_slow );
%}

// Tail Call; Jump from runtime stub to Java code.
// Also known as an 'interprocedural jump'.
// Target of jump will eventually return to caller.
// TailJump below removes the return address.
instruct TailCalljmpInd(mRegP jump_target, s3_RegP method_ptr) %{
  match(TailCall jump_target method_ptr);

  format %{ "JMP    $jump_target \t# @TailCalljmpInd" %}

  ins_encode %{
    __ jr($jump_target$$Register);
  %}

  ins_pipe( pipe_jump );
%}

// Create exception oop: created by stack-crawling runtime code.
// Created exception is now available to this handler, and is setup
// just prior to jumping to this handler.  No code emitted.
instruct CreateException( a0_RegP ex_oop )
%{
  match(Set ex_oop (CreateEx));

  // use the following format syntax
  format %{ "# exception oop is in A0; no code emitted @CreateException" %}
  ins_encode %{
    // X86 leaves this function empty
    __ block_comment("CreateException is empty in LA");
  %}
  ins_pipe( empty );
%}


/* The mechanism of exception handling is clear now.

- Common try/catch:
  [stubGenerator_loongarch.cpp] generate_forward_exception()
      |- V0, V1 are created
      |- T4 <= SharedRuntime::exception_handler_for_return_address
      `- jr T4
           `- the caller's exception_handler
                 `- jr OptoRuntime::exception_blob
                        `- here
- Rethrow(e.g. 'unwind'):
  * The callee:
     |- an exception is triggered during execution
     `- exits the callee method through RethrowException node
          |- The callee pushes exception_oop(T0) and exception_pc(RA)
          `- The callee jumps to OptoRuntime::rethrow_stub()
  * In OptoRuntime::rethrow_stub:
     |- The VM calls _rethrow_Java to determine the return address in the caller method
     `- exits the stub with tailjmpInd
          |- pops exception_oop(V0) and exception_pc(V1)
          `- jumps to the return address(usually an exception_handler)
  * The caller:
     `- continues processing the exception_blob with V0/V1
*/

// Rethrow exception:
// The exception oop will come in the first argument position.
// Then JUMP (not call) to the rethrow stub code.
instruct RethrowException()
%{
  match(Rethrow);

  // use the following format syntax
  format %{ "JMP    rethrow_stub #@RethrowException" %}
  ins_encode %{
    __ block_comment("@ RethrowException");

    cbuf.set_insts_mark();
    cbuf.relocate(cbuf.insts_mark(), runtime_call_Relocation::spec());

    // call OptoRuntime::rethrow_stub to get the exception handler in parent method
    __ patchable_jump((address)OptoRuntime::rethrow_stub());
  %}
  ins_pipe( pipe_jump );
%}

// ============================================================================
// Branch Instructions --- long offset versions

// Jump Direct
instruct jmpDir_long(label labl) %{
  match(Goto);
  effect(USE labl);

  ins_cost(300);
  format %{ "JMP    $labl #@jmpDir_long" %}

  ins_encode %{
    Label* L = $labl$$label;
    __ jmp_far(*L);
  %}

  ins_pipe( pipe_jump );
  //ins_pc_relative(1);
%}

// Jump Direct Conditional - Label defines a relative address from Jcc+1
instruct  CountedLoopEnd_reg_reg_long(cmpOp cop, mRegI src1, mRegI src2, label labl) %{
  match(CountedLoopEnd cop (CmpI src1 src2));
  effect(USE labl);

  ins_cost(300);
  format %{ "J$cop  $src1, $src2,  $labl\t# Loop end @ CountedLoopEnd_reg_reg_long" %}
  ins_encode %{
    Register op1 = $src1$$Register;
    Register op2 = $src2$$Register;
    Label*     L = $labl$$label;
    int     flag = $cop$$cmpcode;

    __ cmp_branch_long(flag, op1, op2, L, true /* signed */);
  %}
  ins_pipe( pipe_jump );
  ins_pc_relative(1);
%}

// Note: LA does not have a branching instruction with an immediate number
// The purpose of retaining CountedLoopEnd_reg_imm12_short/long and branchConIU_reg_imm12_short/long
// is to reduce the long lifecycle of shared nodes.
// see #29437
instruct  CountedLoopEnd_reg_imm12_short(cmpOp cop, mRegI src1, immI12 imm, label labl) %{
  match(CountedLoopEnd cop (CmpI src1 imm));
  effect(USE labl);

  ins_cost(300);
  format %{ "J$cop  $src1, $imm,  $labl\t# Loop end @ CountedLoopEnd_reg_imm12_short" %}
  ins_encode %{
    Register op1 = $src1$$Register;
    Label     &L = *($labl$$label);
    int     flag = $cop$$cmpcode;

    __ addi_d(AT, R0, $imm$$constant);
    __ cmp_branch_short(flag, op1, AT, L, true /* signed */);
  %}
  ins_pipe( pipe_jump );
  ins_pc_relative(1);
  ins_short_branch(1);
%}

instruct  CountedLoopEnd_reg_imm12_long(cmpOp cop, mRegI src1, immI12 imm, label labl) %{
  match(CountedLoopEnd cop (CmpI src1 imm));
  effect(USE labl);

  ins_cost(300);
  format %{ "J$cop  $src1, $imm,  $labl\t# Loop end @ CountedLoopEnd_reg_imm12_long" %}
  ins_encode %{
    Register op1 = $src1$$Register;
    Label*     L = $labl$$label;
    int     flag = $cop$$cmpcode;

    __ addi_d(AT, R0, $imm$$constant);
    __ cmp_branch_long(flag, op1, AT, L, true /* signed */);
  %}
  ins_pipe( pipe_jump );
  ins_pc_relative(1);
%}

instruct  CountedLoopEnd_reg_zero_long(cmpOp cop, mRegI src1, immI_0 zero, label labl) %{
  match(CountedLoopEnd cop (CmpI src1 zero));
  effect(USE labl);

  ins_cost(300);
  format %{ "J$cop  $src1, $zero,  $labl\t# Loop end @ CountedLoopEnd_reg_zero_long" %}
  ins_encode %{
    Register op1 = $src1$$Register;
    Label*     L = $labl$$label;
    int     flag = $cop$$cmpcode;

    __ cmp_branch_long(flag, op1, R0, L, true /* signed */);
  %}
  ins_pipe( pipe_jump );
  ins_pc_relative(1);
%}


instruct jmpCon_flags_long(cmpOpEqNe cop, FlagsReg cr, label labl) %{
  match(If cop cr);
  effect(USE labl);

  ins_cost(300);
  format %{ "J$cop    $labl  #LoongArch uses T0 as equivalent to eflag @jmpCon_flags_long" %}

  ins_encode %{
    Label*    L =  $labl$$label;
    Label not_taken;
    switch($cop$$cmpcode) {
      case 0x01: //equal
        __ bne($cr$$Register, R0, not_taken);
        break;
      case 0x02: //not equal
        __ beq($cr$$Register, R0, not_taken);
        break;
      default:
        Unimplemented();
    }
    __ jmp_far(*L);
    __ bind(not_taken);
  %}

  ins_pipe( pipe_jump );
  ins_pc_relative(1);
%}

// Conditional jumps
instruct branchConP_0_long(cmpOpEqNe cmp, mRegP op1, immP_0 zero, label labl) %{
  match(If cmp (CmpP op1 zero));
  effect(USE labl);

  ins_cost(180);
  format %{ "b$cmp   $op1, R0, $labl #@branchConP_0_long" %}

  ins_encode %{
    Register op1 = $op1$$Register;
    Label*    L  = $labl$$label;
    int     flag = $cmp$$cmpcode;

    __ cmp_branch_long(flag, op1, R0, L, true /* signed */);
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
%}

instruct branchConN2P_0_long(cmpOpEqNe cmp, mRegN op1, immP_0 zero, label labl) %{
  match(If cmp (CmpP (DecodeN op1) zero));
  predicate(CompressedOops::base() == nullptr);
  effect(USE labl);

  ins_cost(180);
  format %{ "b$cmp   $op1, R0, $labl #@branchConN2P_0_long" %}

  ins_encode %{
    Register op1 = $op1$$Register;
    Label*    L  = $labl$$label;
    int     flag = $cmp$$cmpcode;

    __ cmp_branch_long(flag, op1, R0, L, true /* signed */);
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
%}


instruct branchConP_long(cmpOp cmp, mRegP op1, mRegP op2, label labl) %{
  match(If cmp (CmpP op1 op2));
//  predicate(can_branch_register(_kids[0]->_leaf, _kids[1]->_leaf));
  effect(USE labl);

  ins_cost(200);
  format %{ "b$cmp   $op1, $op2, $labl #@branchConP_long" %}

  ins_encode %{
    Register op1 = $op1$$Register;
    Register op2 = $op2$$Register;
    Label*    L  = $labl$$label;
    int     flag = $cmp$$cmpcode;

    __ cmp_branch_long(flag, op1, op2, L, false /* unsigned */);
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
%}

instruct cmpN_null_branch_long(cmpOpEqNe cmp, mRegN op1, immN_0 null, label labl) %{
  match(If cmp (CmpN op1 null));
  effect(USE labl);

  ins_cost(180);
  format %{ "CMP    $op1,0\t! compressed ptr\n\t"
            "BP$cmp   $labl @ cmpN_null_branch_long" %}
  ins_encode %{
    Register op1 = $op1$$Register;
    Label*    L  = $labl$$label;
    int     flag = $cmp$$cmpcode;

    __ cmp_branch_long(flag, op1, R0, L, true /* signed */);
  %}
//TODO: pipe_branchP or create pipe_branchN LEE
  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
%}

instruct cmpN_reg_branch_long(cmpOp cmp, mRegN op1, mRegN op2, label labl) %{
  match(If cmp (CmpN op1 op2));
  effect(USE labl);

  ins_cost(180);
  format %{ "CMP    $op1,$op2\t! compressed ptr\n\t"
            "BP$cmp   $labl @ cmpN_reg_branch_long" %}
  ins_encode %{
    Register op1 = $op1$$Register;
    Register op2 = $op2$$Register;
    Label*    L  = $labl$$label;
    int     flag = $cmp$$cmpcode;

    __ cmp_branch_long(flag, op1, op2, L, false /* unsigned */);
  %}
  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
%}

instruct branchConIU_reg_imm12_short(cmpOp cmp, mRegI src1, immI12 imm, label labl) %{
  match( If cmp (CmpU src1 imm) );
  effect(USE labl);
  format %{ "BR$cmp   $src1, $imm, $labl #@branchConIU_reg_imm12_short" %}

  ins_encode %{
    Register op1 = $src1$$Register;
    Label     &L = *($labl$$label);
    int     flag = $cmp$$cmpcode;
    int       imm = $imm$$constant;
    __ addi_d(AT, R0, imm);
    __ cmp_branch_short(flag, op1, AT, L, false /* unsigned*/);
  %}

  ins_short_branch(1);
  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
%}

instruct branchConIU_reg_imm12_long(cmpOp cmp, mRegI src1, immI12 src2, label labl) %{
  match( If cmp (CmpU src1 src2) );
  effect(USE labl);
  format %{ "BR$cmp   $src1, $src2, $labl #@branchConIU_reg_imm12_long" %}

  ins_encode %{
    Register op1 = $src1$$Register;
    Label*     L = $labl$$label;
    int     flag = $cmp$$cmpcode;
    int       imm = $src2$$constant;
    __ addi_d(AT, R0, imm);
    __ cmp_branch_long(flag, op1, AT, L, false /* unsigned*/);
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
%}

instruct branchConIU_reg_reg_long(cmpOp cmp, mRegI src1, mRegI src2, label labl) %{
  match( If cmp (CmpU src1 src2) );
  effect(USE labl);
  format %{ "BR$cmp   $src1, $src2, $labl #@branchConIU_reg_reg_long" %}

  ins_encode %{
    Register op1 = $src1$$Register;
    Register op2 = $src2$$Register;
    Label*     L = $labl$$label;
    int     flag = $cmp$$cmpcode;

    __ cmp_branch_long(flag, op1, op2, L, false /* unsigned */);
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
%}


instruct branchConIU_reg_zero_long(cmpOp cmp, mRegI src1, immI_0 zero, label labl) %{
  match( If cmp (CmpU src1 zero) );
  effect(USE labl);
  format %{ "BR$cmp   $src1, $zero, $labl #@branchConIU_reg_zero_long" %}

  ins_encode %{
    Register op1 = $src1$$Register;
    Label*     L = $labl$$label;
    int     flag = $cmp$$cmpcode;

    __ cmp_branch_long(flag, op1, R0, L, false /* unsigned */);
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
%}

instruct branchConI_reg_reg_long(cmpOp cmp, mRegI src1, mRegI src2, label labl) %{
  match( If cmp (CmpI src1 src2) );
  effect(USE labl);
  format %{ "BR$cmp   $src1, $src2, $labl #@branchConI_reg_reg_long" %}

  ins_encode %{
    Register op1 = $src1$$Register;
    Register op2 = $src2$$Register;
    Label*     L = $labl$$label;
    int     flag = $cmp$$cmpcode;

    __ cmp_branch_long(flag, op1, op2, L, true /* signed */);
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
%}

instruct branchConI_reg_zero_long(cmpOp cmp, mRegI src1, immI_0 zero, label labl) %{
  match( If cmp (CmpI src1 zero) );
  effect(USE labl);
  ins_cost(200);
  format %{ "BR$cmp   $src1, $zero, $labl #@branchConI_reg_zero_long" %}

  ins_encode %{
    Register op1 = $src1$$Register;
    Label*     L =  $labl$$label;
    int     flag = $cmp$$cmpcode;

    __ cmp_branch_long(flag, op1, R0, L, true /* signed */);
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
%}

instruct branchConL_regL_regL_long(cmpOp cmp, mRegLorI2L src1, mRegLorI2L src2, label labl) %{
  match( If cmp (CmpL src1 src2) );
  effect(USE labl);
  format %{ "BR$cmp   $src1, $src2, $labl #@branchConL_regL_regL_long" %}
  ins_cost(250);

  ins_encode %{
    Register op1 = as_Register($src1$$reg);
    Register op2 = as_Register($src2$$reg);

    Label*   target = $labl$$label;
    int     flag = $cmp$$cmpcode;

    __ cmp_branch_long(flag, op1, op2, target, true /* signed */);
  %}


  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
%}

instruct branchConUL_regL_regL_long(cmpOp cmp, mRegLorI2L src1, mRegLorI2L src2, label labl) %{
  match(If cmp (CmpUL src1 src2));
  effect(USE labl);
  format %{ "BR$cmp   $src1, $src2, $labl #@branchConUL_regL_regL_long" %}
  ins_cost(250);

  ins_encode %{
    Register op1 = as_Register($src1$$reg);
    Register op2 = as_Register($src2$$reg);
    Label*   target = $labl$$label;
    int      flag   = $cmp$$cmpcode;

    __ cmp_branch_long(flag, op1, op2, target, false /* signed */);
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
%}

instruct branchConL_regL_zero_long(cmpOp cmp, mRegL src1, immL_0 zero, label labl) %{
  match( If cmp (CmpL src1 zero) );
  effect(USE labl);
  format %{ "BR$cmp   $src1, $zero, $labl #@branchConL_regL_immL_long" %}
  ins_cost(180);

  ins_encode %{
    Register op1 = as_Register($src1$$reg);
    Label*   target = $labl$$label;
    int      flag = $cmp$$cmpcode;

    __ cmp_branch_long(flag, op1, R0, target, true /* signed */);
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
%}

instruct branchConUL_regL_zero_long(cmpOp cmp, mRegL src1, immL_0 zero, label labl) %{
  match(If cmp (CmpUL src1 zero));
  effect(USE labl);
  format %{ "BR$cmp   $src1, $zero, $labl #@branchConUL_regL_immL_long" %}
  ins_cost(180);

  ins_encode %{
    Register op1 = as_Register($src1$$reg);
    Label*   target = $labl$$label;
    int      flag   = $cmp$$cmpcode;

    __ cmp_branch_long(flag, op1, R0, target, false /* signed */);
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
%}

//FIXME
instruct branchConF_reg_reg_long(cmpOp cmp, regF src1, regF src2, label labl) %{
  match( If cmp (CmpF src1 src2) );
  effect(USE labl);
  format %{ "BR$cmp   $src1, $src2, $labl #@branchConF_reg_reg_long" %}

  ins_encode %{
    FloatRegister reg_op1 = $src1$$FloatRegister;
    FloatRegister reg_op2 = $src2$$FloatRegister;
    Label*     L =  $labl$$label;
    Label not_taken;
    int     flag = $cmp$$cmpcode;

    switch(flag) {
      case 0x01: //equal
        __ fcmp_ceq_s(FCC0, reg_op1, reg_op2);
        __ bceqz(FCC0, not_taken);
        break;
      case 0x02: //not_equal
        __ fcmp_ceq_s(FCC0, reg_op1, reg_op2);
        __ bcnez(FCC0, not_taken);
        break;
      case 0x03: //greater
        __ fcmp_cule_s(FCC0, reg_op1, reg_op2);
        __ bcnez(FCC0, not_taken);
        break;
      case 0x04: //greater_equal
        __ fcmp_cult_s(FCC0, reg_op1, reg_op2);
        __ bcnez(FCC0, not_taken);
        break;
      case 0x05: //less
        __ fcmp_cult_s(FCC0, reg_op1, reg_op2);
        __ bceqz(FCC0, not_taken);
        break;
      case 0x06: //less_equal
        __ fcmp_cule_s(FCC0, reg_op1, reg_op2);
        __ bceqz(FCC0, not_taken);
        break;
      default:
        Unimplemented();
    }
    __ jmp_far(*L);
    __ bind(not_taken);
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_fpu_branch );
%}

instruct branchConD_reg_reg_long(cmpOp cmp, regD src1, regD src2, label labl) %{
  match( If cmp (CmpD src1 src2) );
  effect(USE labl);
  format %{ "BR$cmp   $src1, $src2, $labl #@branchConD_reg_reg_long" %}

  ins_encode %{
    FloatRegister reg_op1 = $src1$$FloatRegister;
    FloatRegister reg_op2 = $src2$$FloatRegister;
    Label*     L =  $labl$$label;
    Label not_taken;
    int     flag = $cmp$$cmpcode;

    switch(flag) {
      case 0x01: //equal
        __ fcmp_ceq_d(FCC0, reg_op1, reg_op2);
        __ bceqz(FCC0, not_taken);
        break;
      case 0x02: //not_equal
        // c_ueq_d cannot distinguish NaN from equal. Double.isNaN(Double) is implemented by 'f != f', so the use of c_ueq_d causes bugs.
        __ fcmp_ceq_d(FCC0, reg_op1, reg_op2);
        __ bcnez(FCC0, not_taken);
        break;
      case 0x03: //greater
        __ fcmp_cule_d(FCC0, reg_op1, reg_op2);
        __ bcnez(FCC0, not_taken);
        break;
      case 0x04: //greater_equal
        __ fcmp_cult_d(FCC0, reg_op1, reg_op2);
        __ bcnez(FCC0, not_taken);
        break;
      case 0x05: //less
        __ fcmp_cult_d(FCC0, reg_op1, reg_op2);
        __ bceqz(FCC0, not_taken);
        break;
      case 0x06: //less_equal
        __ fcmp_cule_d(FCC0, reg_op1, reg_op2);
        __ bceqz(FCC0, not_taken);
        break;
      default:
        Unimplemented();
    }
    __ jmp_far(*L);
    __ bind(not_taken);
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_fpu_branch );
%}


// ============================================================================
// Branch Instructions -- short offset versions

// Jump Direct
instruct jmpDir_short(label labl) %{
  match(Goto);
  effect(USE labl);

  ins_cost(300);
  format %{ "JMP    $labl #@jmpDir_short" %}

  ins_encode %{
    Label &L = *($labl$$label);
    __ b(L);
  %}

    ins_pipe( pipe_jump );
    ins_pc_relative(1);
    ins_short_branch(1);
%}

// Jump Direct Conditional - Label defines a relative address from Jcc+1
instruct  CountedLoopEnd_reg_reg_short(cmpOp cop, mRegI src1, mRegI src2, label labl) %{
  match(CountedLoopEnd cop (CmpI src1 src2));
  effect(USE labl);

  ins_cost(300);
  format %{ "J$cop  $src1, $src2,  $labl\t# Loop end @ CountedLoopEnd_reg_reg_short" %}
  ins_encode %{
    Register op1 = $src1$$Register;
    Register op2 = $src2$$Register;
    Label     &L = *($labl$$label);
    int     flag = $cop$$cmpcode;

    __ cmp_branch_short(flag, op1, op2, L, true /* signed */);
  %}
  ins_pipe( pipe_jump );
  ins_pc_relative(1);
  ins_short_branch(1);
%}

instruct  CountedLoopEnd_reg_zero_short(cmpOp cop, mRegI src1, immI_0 zero, label labl) %{
  match(CountedLoopEnd cop (CmpI src1 zero));
  effect(USE labl);

  ins_cost(300);
  format %{ "J$cop  $src1, $zero,  $labl\t# Loop end @ CountedLoopEnd_reg_zero_short" %}
  ins_encode %{
    Register op1 = $src1$$Register;
    Label     &L = *($labl$$label);
    int     flag = $cop$$cmpcode;

    __ cmp_branch_short(flag, op1, R0, L, true /* signed */);
  %}
  ins_pipe( pipe_jump );
  ins_pc_relative(1);
  ins_short_branch(1);
%}


instruct jmpCon_flags_short(cmpOpEqNe cop, FlagsReg cr, label labl) %{
  match(If cop cr);
  effect(USE labl);

  ins_cost(300);
  format %{ "J$cop    $labl  #LoongArch uses T0 as equivalent to eflag @jmpCon_flags_short" %}

  ins_encode %{
    Label    &L =  *($labl$$label);
    switch($cop$$cmpcode) {
      case 0x01: //equal
        __ bnez($cr$$Register, L);
        break;
      case 0x02: //not equal
        __ beqz($cr$$Register, L);
        break;
      default:
        Unimplemented();
    }
  %}

  ins_pipe( pipe_jump );
  ins_pc_relative(1);
  ins_short_branch(1);
%}

// Conditional jumps
instruct branchConP_0_short(cmpOpEqNe cmp, mRegP op1, immP_0 zero, label labl) %{
  match(If cmp (CmpP op1 zero));
  effect(USE labl);

  ins_cost(180);
  format %{ "b$cmp   $op1, R0, $labl #@branchConP_0_short" %}

  ins_encode %{
    Register op1 = $op1$$Register;
    Label    &L  = *($labl$$label);
    int     flag = $cmp$$cmpcode;

    __ cmp_branchEqNe_off21(flag, op1, L);
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
  ins_short_branch(1);
%}

instruct branchConN2P_0_short(cmpOpEqNe cmp, mRegN op1, immP_0 zero, label labl) %{
  match(If cmp (CmpP (DecodeN op1) zero));
  predicate(CompressedOops::base() == nullptr);
  effect(USE labl);

  ins_cost(180);
  format %{ "b$cmp   $op1, R0, $labl #@branchConN2P_0_short" %}

  ins_encode %{
    Register op1 = $op1$$Register;
    Label    &L  = *($labl$$label);
    int     flag = $cmp$$cmpcode;

    __ cmp_branchEqNe_off21(flag, op1, L);
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
  ins_short_branch(1);
%}


instruct branchConP_short(cmpOp cmp, mRegP op1, mRegP op2, label labl) %{
  match(If cmp (CmpP op1 op2));
//  predicate(can_branch_register(_kids[0]->_leaf, _kids[1]->_leaf));
  effect(USE labl);

  ins_cost(200);
  format %{ "b$cmp   $op1, $op2, $labl #@branchConP_short" %}

  ins_encode %{
    Register op1 = $op1$$Register;
    Register op2 = $op2$$Register;
    Label    &L  = *($labl$$label);
    int     flag = $cmp$$cmpcode;

    __ cmp_branch_short(flag, op1, op2, L, false /* unsigned */);
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
  ins_short_branch(1);
%}

instruct cmpN_null_branch_short(cmpOp cmp, mRegN op1, immN_0 null, label labl) %{
  match(If cmp (CmpN op1 null));
  effect(USE labl);

  ins_cost(180);
  format %{ "CMP    $op1,0\t! compressed ptr\n\t"
            "BP$cmp   $labl @ cmpN_null_branch_short" %}
  ins_encode %{
    Register op1 = $op1$$Register;
    Label    &L  = *($labl$$label);
    int     flag = $cmp$$cmpcode;

    __ cmp_branchEqNe_off21(flag, op1, L);
  %}
//TODO: pipe_branchP or create pipe_branchN LEE
  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
  ins_short_branch(1);
%}

instruct cmpN_reg_branch_short(cmpOp cmp, mRegN op1, mRegN op2, label labl) %{
  match(If cmp (CmpN op1 op2));
  effect(USE labl);

  ins_cost(180);
  format %{ "CMP    $op1,$op2\t! compressed ptr\n\t"
            "BP$cmp   $labl @ cmpN_reg_branch_short" %}
  ins_encode %{
    Register op1 = $op1$$Register;
    Register op2 = $op2$$Register;
    Label    &L  = *($labl$$label);
    int     flag = $cmp$$cmpcode;

    __ cmp_branch_short(flag, op1, op2, L, false /* unsigned */);
  %}
  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
  ins_short_branch(1);
%}

instruct branchConIU_reg_reg_short(cmpOp cmp, mRegI src1, mRegI src2, label labl) %{
  match( If cmp (CmpU src1 src2) );
  effect(USE labl);
  format %{ "BR$cmp   $src1, $src2, $labl #@branchConIU_reg_reg_short" %}

  ins_encode %{
    Register op1 = $src1$$Register;
    Register op2 = $src2$$Register;
    Label     &L = *($labl$$label);
    int     flag = $cmp$$cmpcode;

    __ cmp_branch_short(flag, op1, op2, L, false /* unsigned */);
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
  ins_short_branch(1);
%}


instruct branchConIU_reg_zero_short(cmpOp cmp, mRegI src1, immI_0 zero, label labl) %{
  match( If cmp (CmpU src1 zero) );
  effect(USE labl);
  format %{ "BR$cmp   $src1, $zero, $labl #@branchConIU_reg_imm_short" %}

  ins_encode %{
    Register op1 = $src1$$Register;
    Label     &L = *($labl$$label);
    int     flag = $cmp$$cmpcode;

    __ cmp_branch_short(flag, op1, R0, L, false /* unsigned */);
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
  ins_short_branch(1);
%}

instruct branchConI_reg_reg_short(cmpOp cmp, mRegI src1, mRegI src2, label labl) %{
  match( If cmp (CmpI src1 src2) );
  effect(USE labl);
  format %{ "BR$cmp   $src1, $src2, $labl #@branchConI_reg_reg_short" %}

  ins_encode %{
    Register op1 = $src1$$Register;
    Register op2 = $src2$$Register;
    Label     &L = *($labl$$label);
    int     flag = $cmp$$cmpcode;

    __ cmp_branch_short(flag, op1, op2, L, true /* signed */);
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
  ins_short_branch(1);
%}

instruct branchConI_reg_zero_short(cmpOp cmp, mRegI src1, immI_0 zero, label labl) %{
  match( If cmp (CmpI src1 zero) );
  effect(USE labl);
  ins_cost(200);
  format %{ "BR$cmp   $src1, $zero, $labl #@branchConI_reg_imm_short" %}

  ins_encode %{
    Register op1 = $src1$$Register;
    Label     &L =  *($labl$$label);
    int     flag = $cmp$$cmpcode;

    __ cmp_branch_short(flag, op1, R0, L, true /* signed */);
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
  ins_short_branch(1);
%}

instruct branchConL_regL_regL_short(cmpOp cmp, mRegLorI2L src1, mRegLorI2L src2, label labl) %{
  match( If cmp (CmpL src1 src2) );
  effect(USE labl);
  format %{ "BR$cmp   $src1, $src2, $labl #@branchConL_regL_regL_short" %}
  ins_cost(250);

  ins_encode %{
    Register op1 = as_Register($src1$$reg);
    Register op2 = as_Register($src2$$reg);

    Label   &target = *($labl$$label);
    int     flag = $cmp$$cmpcode;

    __ cmp_branch_short(flag, op1, op2, target, true /* signed */);
  %}


  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
  ins_short_branch(1);
%}

instruct branchConUL_regL_regL_short(cmpOp cmp, mRegLorI2L src1, mRegLorI2L src2, label labl) %{
  match(If cmp (CmpUL src1 src2));
  effect(USE labl);
  format %{ "BR$cmp   $src1, $src2, $labl #@branchConUL_regL_regL_short" %}
  ins_cost(250);

  ins_encode %{
    Register op1 = as_Register($src1$$reg);
    Register op2 = as_Register($src2$$reg);
    Label&   target = *($labl$$label);
    int      flag   = $cmp$$cmpcode;

    __ cmp_branch_short(flag, op1, op2, target, false /* signed */);
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
  ins_short_branch(1);
%}

instruct branchConL_regL_zero_short(cmpOp cmp, mRegL src1, immL_0 zero, label labl) %{
  match( If cmp (CmpL src1 zero) );
  effect(USE labl);
  format %{ "BR$cmp   $src1, $zero, $labl #@branchConL_regL_immL_short" %}
  ins_cost(180);

  ins_encode %{
    Register op1 = as_Register($src1$$reg);
    Label   &target = *($labl$$label);
    int     flag = $cmp$$cmpcode;

    __ cmp_branch_short(flag, op1, R0, target, true /* signed */);
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
  ins_short_branch(1);
%}

instruct branchConUL_regL_zero_short(cmpOp cmp, mRegL src1, immL_0 zero, label labl) %{
  match(If cmp (CmpUL src1 zero));
  effect(USE labl);
  format %{ "BR$cmp   $src1, $zero, $labl #@branchConUL_regL_immL_short" %}
  ins_cost(180);

  ins_encode %{
    Register op1 = as_Register($src1$$reg);
    Label&   target = *($labl$$label);
    int      flag   = $cmp$$cmpcode;

    __ cmp_branch_short(flag, op1, R0, target, false /* signed */);
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_alu_branch );
  ins_short_branch(1);
%}

//FIXME
instruct branchConF_reg_reg_short(cmpOp cmp, regF src1, regF src2, label labl) %{
  match( If cmp (CmpF src1 src2) );
  effect(USE labl);
  format %{ "BR$cmp   $src1, $src2, $labl #@branchConF_reg_reg_short" %}

  ins_encode %{
    FloatRegister reg_op1 = $src1$$FloatRegister;
    FloatRegister reg_op2 = $src2$$FloatRegister;
    Label     &L =  *($labl$$label);
    int     flag = $cmp$$cmpcode;

    switch(flag) {
      case 0x01: //equal
        __ fcmp_ceq_s(FCC0, reg_op1, reg_op2);
        __ bcnez(FCC0, L);
        break;
      case 0x02: //not_equal
        __ fcmp_ceq_s(FCC0, reg_op1, reg_op2);
        __ bceqz(FCC0, L);
        break;
      case 0x03: //greater
        __ fcmp_cule_s(FCC0, reg_op1, reg_op2);
        __ bceqz(FCC0, L);
        break;
      case 0x04: //greater_equal
        __ fcmp_cult_s(FCC0, reg_op1, reg_op2);
        __ bceqz(FCC0, L);
        break;
      case 0x05: //less
        __ fcmp_cult_s(FCC0, reg_op1, reg_op2);
        __ bcnez(FCC0, L);
        break;
      case 0x06: //less_equal
        __ fcmp_cule_s(FCC0, reg_op1, reg_op2);
        __ bcnez(FCC0, L);
        break;
      default:
        Unimplemented();
    }
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_fpu_branch );
  ins_short_branch(1);
%}

instruct branchConD_reg_reg_short(cmpOp cmp, regD src1, regD src2, label labl) %{
  match( If cmp (CmpD src1 src2) );
  effect(USE labl);
  format %{ "BR$cmp   $src1, $src2, $labl #@branchConD_reg_reg_short" %}

  ins_encode %{
    FloatRegister reg_op1 = $src1$$FloatRegister;
    FloatRegister reg_op2 = $src2$$FloatRegister;
    Label     &L =  *($labl$$label);
    int     flag = $cmp$$cmpcode;

    switch(flag) {
      case 0x01: //equal
        __ fcmp_ceq_d(FCC0, reg_op1, reg_op2);
        __ bcnez(FCC0, L);
        break;
      case 0x02: //not_equal
        // c_ueq_d cannot distinguish NaN from equal. Double.isNaN(Double) is implemented by 'f != f', so the use of c_ueq_d causes bugs.
        __ fcmp_ceq_d(FCC0, reg_op1, reg_op2);
        __ bceqz(FCC0, L);
        break;
      case 0x03: //greater
        __ fcmp_cule_d(FCC0, reg_op1, reg_op2);
        __ bceqz(FCC0, L);
        break;
      case 0x04: //greater_equal
        __ fcmp_cult_d(FCC0, reg_op1, reg_op2);
        __ bceqz(FCC0, L);
        break;
      case 0x05: //less
        __ fcmp_cult_d(FCC0, reg_op1, reg_op2);
        __ bcnez(FCC0, L);
        break;
      case 0x06: //less_equal
        __ fcmp_cule_d(FCC0, reg_op1, reg_op2);
        __ bcnez(FCC0, L);
        break;
      default:
        Unimplemented();
    }
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_fpu_branch );
  ins_short_branch(1);
%}

// =================== End of branch instructions ==========================

// Call Runtime Instruction
instruct CallRuntimeDirect(method meth) %{
  match(CallRuntime );
  effect(USE meth);

  ins_cost(300);
  format %{ "CALL,runtime #@CallRuntimeDirect" %}
  ins_encode( Java_To_Runtime( meth ) );
  ins_pipe( pipe_slow );
  ins_alignment(4);
%}



//------------------------MemBar Instructions-------------------------------
//Memory barrier flavors

instruct unnecessary_membar_acquire() %{
  predicate(unnecessary_acquire(n));
  match(MemBarAcquire);
  ins_cost(0);

  format %{ "membar_acquire (elided)" %}

  ins_encode %{
    __ block_comment("membar_acquire (elided)");
  %}

  ins_pipe( empty );
%}

instruct membar_acquire() %{
  match(MemBarAcquire);
  ins_cost(400);

  format %{ "MEMBAR-acquire @ membar_acquire" %}
  ins_encode %{
    __ membar(Assembler::Membar_mask_bits(__ LoadLoad|__ LoadStore));
  %}
  ins_pipe( pipe_serial );
%}

instruct load_fence() %{
  match(LoadFence);
  ins_cost(400);

  format %{ "MEMBAR @ load_fence" %}
  ins_encode %{
    __ membar(Assembler::Membar_mask_bits(__ LoadLoad|__ LoadStore));
  %}
  ins_pipe( pipe_serial );
%}

instruct membar_acquire_lock()
%{
  match(MemBarAcquireLock);
  ins_cost(0);

  size(0);
  format %{ "MEMBAR-acquire (acquire as part of CAS in prior FastLock so empty encoding) @ membar_acquire_lock" %}
  ins_encode();
  ins_pipe( empty );
%}

instruct unnecessary_membar_release() %{
  predicate(unnecessary_release(n));
  match(MemBarRelease);
  ins_cost(0);

  format %{ "membar_release (elided)" %}

  ins_encode %{
    __ block_comment("membar_release (elided)");
  %}
  ins_pipe( pipe_serial );
%}

instruct membar_release() %{
  match(MemBarRelease);
  ins_cost(400);

  format %{ "MEMBAR-release @ membar_release" %}

  ins_encode %{
    // Attention: DO NOT DELETE THIS GUY!
    __ membar(Assembler::Membar_mask_bits(__ LoadStore|__ StoreStore));
  %}

  ins_pipe( pipe_serial );
%}

instruct store_fence() %{
  match(StoreFence);
  ins_cost(400);

  format %{ "MEMBAR @ store_fence" %}

  ins_encode %{
    __ membar(Assembler::Membar_mask_bits(__ LoadStore|__ StoreStore));
  %}

  ins_pipe( pipe_serial );
%}

instruct membar_release_lock()
%{
  match(MemBarReleaseLock);
  ins_cost(0);

  size(0);
  format %{ "MEMBAR-release-lock (release in FastUnlock so empty) @ membar_release_lock" %}
  ins_encode();
  ins_pipe( empty );
%}

instruct unnecessary_membar_volatile() %{
  predicate(unnecessary_volatile(n));
  match(MemBarVolatile);
  ins_cost(0);

  format %{ "membar_volatile (elided)" %}

  ins_encode %{
    __ block_comment("membar_volatile (elided)");
  %}

  ins_pipe( pipe_serial );
%}

instruct membar_volatile() %{
  match(MemBarVolatile);
  ins_cost(400);

  format %{ "MEMBAR-volatile" %}
  ins_encode %{
    if( !os::is_MP() ) return;     // Not needed on single CPU
    __ membar(__ StoreLoad);

  %}
  ins_pipe( pipe_serial );
%}

instruct membar_storestore() %{
  match(MemBarStoreStore);
  match(StoreStoreFence);

  ins_cost(400);
  format %{ "MEMBAR-storestore @ membar_storestore" %}
  ins_encode %{
    __ membar(__ StoreStore);
  %}
  ins_pipe( pipe_serial );
%}

instruct same_addr_load_fence() %{
  match(SameAddrLoadFence);
  ins_cost(400);

  format %{ "MEMBAR @ same_addr_load_fence" %}
  ins_encode %{
    __ dbar(0x700);
  %}
  ins_pipe( pipe_serial );
%}

//----------Move Instructions--------------------------------------------------
instruct castX2P(mRegP dst, mRegL src) %{
  match(Set dst (CastX2P src));
  format %{ "castX2P  $dst, $src @ castX2P" %}
  ins_encode %{
    Register src = $src$$Register;
    Register dst = $dst$$Register;

  if(src != dst)
    __ move(dst, src);
  %}
  ins_cost(10);
  ins_pipe( ialu_reg_reg );
%}

instruct castP2X(mRegL dst, mRegP src ) %{
  match(Set dst (CastP2X src));

  format %{ "mov    $dst, $src\t  #@castP2X" %}
  ins_encode %{
    Register src = $src$$Register;
    Register dst = $dst$$Register;

  if(src != dst)
    __ move(dst, src);
  %}
  ins_pipe( ialu_reg_reg );
%}

instruct MoveF2I_reg_reg(mRegI dst, regF src) %{
  match(Set dst (MoveF2I src));
  effect(DEF dst, USE src);
  ins_cost(85);
  format %{ "MoveF2I   $dst, $src @ MoveF2I_reg_reg" %}
  ins_encode %{
    Register dst = as_Register($dst$$reg);
    FloatRegister src = as_FloatRegister($src$$reg);

    __ movfr2gr_s(dst, src);
  %}
  ins_pipe( fpu_movgrfr );
%}

instruct MoveI2F_reg_reg(regF dst, mRegI src) %{
  match(Set dst (MoveI2F src));
  effect(DEF dst, USE src);
  ins_cost(85);
  format %{ "MoveI2F   $dst, $src @ MoveI2F_reg_reg" %}
  ins_encode %{
    Register src = as_Register($src$$reg);
    FloatRegister dst = as_FloatRegister($dst$$reg);

    __ movgr2fr_w(dst, src);
  %}
  ins_pipe( fpu_movgrfr );
%}

instruct MoveD2L_reg_reg(mRegL dst, regD src) %{
  match(Set dst (MoveD2L src));
  effect(DEF dst, USE src);
  ins_cost(85);
  format %{ "MoveD2L   $dst, $src @ MoveD2L_reg_reg" %}
  ins_encode %{
    Register dst = as_Register($dst$$reg);
    FloatRegister src = as_FloatRegister($src$$reg);

    __ movfr2gr_d(dst, src);
  %}
  ins_pipe( fpu_movgrfr );
%}

instruct MoveL2D_reg_reg(regD dst, mRegL src) %{
  match(Set dst (MoveL2D src));
  effect(DEF dst, USE src);
  ins_cost(85);
  format %{ "MoveL2D   $dst, $src @ MoveL2D_reg_reg" %}
  ins_encode %{
    FloatRegister dst = as_FloatRegister($dst$$reg);
    Register src = as_Register($src$$reg);

    __ movgr2fr_d(dst, src);
  %}
  ins_pipe( fpu_movgrfr );
%}

//----------Conditional Move---------------------------------------------------
// Conditional move
instruct cmovI_cmpI_reg_reg(mRegI dst, mRegI src1, mRegI src2, cmpOp cop ) %{
  match(Set dst (CMoveI (Binary cop (CmpI src1 src2)) (Binary src1 src2)));
  ins_cost(50);
  format %{
             "CMP$cop  $src1, $src2\t  @cmovI_cmpI_reg_reg\n"
             "\tCMOV  $dst,$src1, $src2 \t @cmovI_cmpI_reg_reg"
         %}

  ins_encode %{
    Register op1 = $src1$$Register;
    Register op2 = $src2$$Register;
    Register dst = $dst$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, op2, dst, op1, op2, (MacroAssembler::CMCompare) flag, true);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovI_cmpI_reg_zero(mRegI dst, mRegI src1, immI_0 zero, mRegI tmp1, mRegI tmp2, cmpOp cop ) %{
  match(Set dst (CMoveI (Binary cop (CmpI tmp1 tmp2)) (Binary src1 zero)));
  ins_cost(20);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovI_cmpI_reg_zero\n"
             "\tCMOV  $dst,$src1, $zero \t @cmovI_cmpI_reg_zero"
         %}

  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    Register dst = $dst$$Register;
    Register src1 = $src1$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov_zero(op1, op2, dst, src1, (MacroAssembler::CMCompare) flag, true);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovI_cmpI_reg_reg2(mRegI dst, mRegI src1, mRegI src2, cmpOp cop ) %{
  match(Set dst (CMoveI (Binary cop (CmpI src1 src2)) (Binary src2 src1)));
  ins_cost(50);
  format %{
             "CMP$cop  $src1, $src2\t  @cmovI_cmpI_reg_reg2\n"
             "\tCMOV  $dst,$src2, $src1 \t @cmovI_cmpI_reg_reg2"
         %}

  ins_encode %{
    Register op1 = $src1$$Register;
    Register op2 = $src2$$Register;
    Register dst = $dst$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, op2, dst, op2, op1, (MacroAssembler::CMCompare) flag, true);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovI_cmpI_zero_reg(mRegI dst, mRegI src1, mRegI src2, mRegI tmp1, immI_0 zero, cmpOp cop ) %{
  match(Set dst (CMoveI (Binary cop (CmpI tmp1 zero)) (Binary src1 src2)));
  ins_cost(20);
  format %{
             "CMP$cop  $tmp1, $zero\t  @cmovI_cmpI_zero_reg\n"
             "\tCMOV  $dst,$src1, $src2 \t @cmovI_cmpI_zero_reg"
         %}

  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, R0, dst, src1, src2, (MacroAssembler::CMCompare) flag, true);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovI_cmpI_zero_zero(mRegI dst, mRegI src1, immI_0 zero, mRegI tmp1, cmpOp cop ) %{
  match(Set dst (CMoveI (Binary cop (CmpI tmp1 zero)) (Binary src1 zero)));
  ins_cost(20);
  format %{
             "CMP$cop  $tmp1, $zero\t  @cmovI_cmpI_zero_zero\n"
             "\tCMOV  $dst,$src1, $zero \t @cmovI_cmpI_zero_zero"
        %}

  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register dst = $dst$$Register;
    Register src1 = $src1$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov_zero(op1, R0, dst, src1, (MacroAssembler::CMCompare) flag, true);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovI_cmpI_dst_reg(mRegI dst, mRegI src, mRegI tmp1, mRegI tmp2, cmpOp cop ) %{
  match(Set dst (CMoveI (Binary cop (CmpI tmp1 tmp2)) (Binary dst src)));
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovI_cmpI_dst_reg\n"
             "\tCMOV  $dst,$src \t @cmovI_cmpI_dst_reg"
         %}

  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    Register dst = $dst$$Register;
    Register src = $src$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, op2, dst, src, (MacroAssembler::CMCompare) flag, true /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovI_cmpP_zero_reg(mRegI dst, mRegI src1, mRegI src2, mRegP tmp1, immP_0 zero, cmpOp cop ) %{
  match(Set dst (CMoveI (Binary cop (CmpP tmp1 zero)) (Binary src1 src2)));
  ins_cost(80);
  format %{
             "CMPU$cop $tmp1,$zero\t @cmovI_cmpP_zero_reg\n\t"
             "CMOV $dst,$src1, $src2\t @cmovI_cmpP_zero_reg"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;
    int     flag = $cop$$cmpcode;
    __ cmp_cmov(op1, R0, dst, src1, src2, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovI_cmpP_zero_zero(mRegI dst, mRegI src1, immI_0 zeroI, mRegP tmp1, immP_0 zeroP, cmpOp cop ) %{
  match(Set dst (CMoveI (Binary cop (CmpP tmp1 zeroP)) (Binary src1 zeroI)));
  ins_cost(80);
  format %{
             "CMPU$cop $tmp1,$zeroP\t @cmovI_cmpP_zero_zero\n\t"
             "CMOV $dst,$zeroI\t @cmovI_cmpP_zero_zero"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register src1 = $src1$$Register;
    Register dst = $dst$$Register;
    int     flag = $cop$$cmpcode;
    __ cmp_cmov_zero(op1, R0, dst, src1, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovI_cmpP_reg_reg(mRegI dst, mRegI src, mRegP tmp1, mRegP tmp2, cmpOp cop ) %{
  match(Set dst (CMoveI (Binary cop (CmpP tmp1 tmp2)) (Binary dst src)));
  ins_cost(80);
  format %{
             "CMPU$cop $tmp1,$tmp2\t @cmovI_cmpP_reg_reg\n\t"
             "CMOV $dst,$src\t @cmovI_cmpP_reg_reg"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    Register dst = $dst$$Register;
    Register src = $src$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, op2, dst, src, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovI_cmpN_zero_reg(mRegI dst, mRegI src1, mRegI src2, mRegN tmp1, immN_0 zero, cmpOp cop ) %{
  match(Set dst (CMoveI (Binary cop (CmpN tmp1 zero)) (Binary src1 src2)));
  ins_cost(80);
  format %{
             "CMPU$cop $tmp1,$zero\t @cmovI_cmpN_zero_reg\n\t"
             "CMOV $dst,$src1, $src2\t @cmovI_cmpN_zero_reg"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;
    int     flag = $cop$$cmpcode;
    __ cmp_cmov(op1, R0, dst, src1, src2, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovI_cmpN_zero_zero(mRegI dst, mRegI src1, immI_0 zeroI, mRegN tmp1, immN_0 zeroN, cmpOp cop ) %{
  match(Set dst (CMoveI (Binary cop (CmpN tmp1 zeroN)) (Binary src1 zeroI)));
  ins_cost(80);
  format %{
             "CMPU$cop $tmp1,$zeroN\t @cmovI_cmpN_zero_zero\n\t"
             "CMOV $dst,$zeroI\t @cmovI_cmpN_zero_zero"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register src1 = $src1$$Register;
    Register dst = $dst$$Register;
    int     flag = $cop$$cmpcode;
    __ cmp_cmov_zero(op1, R0, dst, src1, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovI_cmpN_reg_reg(mRegI dst, mRegI src, mRegN tmp1, mRegN tmp2, cmpOp cop ) %{
  match(Set dst (CMoveI (Binary cop (CmpN tmp1 tmp2)) (Binary dst src)));
  ins_cost(80);
  format %{
             "CMPU$cop $tmp1,$tmp2\t @cmovI_cmpN_reg_reg\n\t"
             "CMOV $dst,$src\t @cmovI_cmpN_reg_reg"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    Register dst = $dst$$Register;
    Register src = $src$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, op2, dst, src, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovP_cmpU_zero_reg(mRegP dst, mRegP src1, mRegP src2, mRegI tmp1, immI_0 zero, cmpOp cop ) %{
  match(Set dst (CMoveP (Binary cop (CmpU tmp1 zero)) (Binary src1 src2)));
  ins_cost(80);
  format %{
             "CMPU$cop $tmp1,$zero\t @cmovP_cmpU_zero_reg\n\t"
             "CMOV $dst,$src1, $src2\t @cmovP_cmpU_zero_reg"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;
    int     flag = $cop$$cmpcode;
    __ cmp_cmov(op1, R0, dst, src1, src2, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovP_cmpU_zero_zero(mRegP dst, mRegP src1, immP_0 zeroP, mRegI tmp1, immI_0 zeroI, cmpOp cop ) %{
  match(Set dst (CMoveP (Binary cop (CmpU tmp1 zeroI)) (Binary src1 zeroP)));
  ins_cost(80);
  format %{
             "CMPU$cop $tmp1,$zeroI\t @cmovP_cmpU_zero_zero\n\t"
             "CMOV $dst,$zeroP\t @cmovP_cmpU_zero_zero"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register src1 = $src1$$Register;
    Register dst = $dst$$Register;
    int     flag = $cop$$cmpcode;
    __ cmp_cmov_zero(op1, R0, dst, src1, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovP_cmpU_reg_reg(mRegP dst, mRegP src, mRegI tmp1, mRegI tmp2, cmpOp cop ) %{
  match(Set dst (CMoveP (Binary cop (CmpU tmp1 tmp2)) (Binary dst src)));
  ins_cost(80);
  format %{
             "CMPU$cop $tmp1,$tmp2\t @cmovP_cmpU_reg_reg\n\t"
             "CMOV $dst,$src\t @cmovP_cmpU_reg_reg"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    Register dst = $dst$$Register;
    Register src = $src$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, op2, dst, src, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovP_cmpF_reg_reg(mRegP dst, mRegP src, regF tmp1, regF tmp2, cmpOp cop, regD tmp3, regD tmp4) %{
  match(Set dst (CMoveP (Binary cop (CmpF tmp1 tmp2)) (Binary dst src)));
  effect(TEMP tmp3, TEMP tmp4);
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovP_cmpF_reg_reg\n"
             "\tCMOV  $dst,$src \t @cmovP_cmpF_reg_reg"
         %}

  ins_encode %{
    FloatRegister reg_op1 = $tmp1$$FloatRegister;
    FloatRegister reg_op2 = $tmp2$$FloatRegister;
    FloatRegister tmp1 = $tmp3$$FloatRegister;
    FloatRegister tmp2 = $tmp4$$FloatRegister;
    Register dst = $dst$$Register;
    Register src = $src$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(reg_op1, reg_op2, dst, src, tmp1, tmp2, (MacroAssembler::CMCompare) flag, true /* is_float */);
  %}
  ins_pipe( pipe_slow );
%}

instruct cmovP_cmpN_reg_reg(mRegP dst, mRegP src, mRegN tmp1, mRegN tmp2, cmpOp cop ) %{
  match(Set dst (CMoveP (Binary cop (CmpN tmp1 tmp2)) (Binary dst src)));
  ins_cost(80);
  format %{
             "CMPU$cop $tmp1,$tmp2\t @cmovP_cmpN_reg_reg\n\t"
             "CMOV $dst,$src\t @cmovP_cmpN_reg_reg"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    Register dst = $dst$$Register;
    Register src = $src$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, op2, dst, src, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovN_cmpP_reg_reg(mRegN dst, mRegN src, mRegP tmp1, mRegP tmp2, cmpOp cop ) %{
  match(Set dst (CMoveN (Binary cop (CmpP tmp1 tmp2)) (Binary dst src)));
  ins_cost(80);
  format %{
             "CMPU$cop $tmp1,$tmp2\t @cmovN_cmpP_reg_reg\n\t"
             "CMOV $dst,$src\t @cmovN_cmpP_reg_reg"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    Register dst = $dst$$Register;
    Register src = $src$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, op2, dst, src, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovP_cmpD_reg_reg(mRegP dst, mRegP src, regD tmp1, regD tmp2, cmpOp cop, regD tmp3, regD tmp4) %{
  match(Set dst (CMoveP (Binary cop (CmpD tmp1 tmp2)) (Binary dst src)));
  effect(TEMP tmp3, TEMP tmp4);
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovP_cmpD_reg_reg\n"
             "\tCMOV  $dst,$src \t @cmovP_cmpD_reg_reg"
         %}
  ins_encode %{
    FloatRegister reg_op1 = as_FloatRegister($tmp1$$reg);
    FloatRegister reg_op2 = as_FloatRegister($tmp2$$reg);
    FloatRegister tmp1 = $tmp3$$FloatRegister;
    FloatRegister tmp2 = $tmp4$$FloatRegister;
    Register dst = as_Register($dst$$reg);
    Register src = as_Register($src$$reg);
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(reg_op1, reg_op2, dst, src, tmp1, tmp2, (MacroAssembler::CMCompare) flag, false /* is_float */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovN_cmpN_reg_reg(mRegN dst, mRegN src, mRegN tmp1, mRegN tmp2, cmpOp cop ) %{
  match(Set dst (CMoveN (Binary cop (CmpN tmp1 tmp2)) (Binary dst src)));
  ins_cost(80);
  format %{
             "CMPU$cop $tmp1,$tmp2\t @cmovN_cmpN_reg_reg\n\t"
             "CMOV $dst,$src\t @cmovN_cmpN_reg_reg"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    Register dst = $dst$$Register;
    Register src = $src$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, op2, dst, src, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovI_cmpU_zero_reg(mRegI dst, mRegI src1, mRegI src2, mRegI tmp1, immI_0 zero, cmpOp cop ) %{
  match(Set dst (CMoveI (Binary cop (CmpU tmp1 zero)) (Binary src1 src2)));
  ins_cost(80);
  format %{
             "CMPU$cop $tmp1,$zero\t @cmovI_cmpU_zero_reg\n\t"
             "CMOV $dst,$src1, $src2\t @cmovI_cmpU_zero_reg"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, R0, dst, src1, src2, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovI_cmpU_zero_zero(mRegI dst, mRegI src1, mRegI tmp1, immI_0 zero, cmpOp cop ) %{
  match(Set dst (CMoveI (Binary cop (CmpU tmp1 zero)) (Binary src1 zero)));
  ins_cost(80);
  format %{
             "CMPU$cop $tmp1,$zero\t @cmovI_cmpU_zero_zero\n\t"
             "CMOV $dst,$zero\t @cmovI_cmpU_zero_zero"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register src1 = $src1$$Register;
    Register dst = $dst$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov_zero(op1, R0, dst, src1, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovI_cmpU_reg_reg(mRegI dst, mRegI src, mRegI tmp1, mRegI tmp2, cmpOp cop ) %{
  match(Set dst (CMoveI (Binary cop (CmpU tmp1 tmp2)) (Binary dst src)));
  ins_cost(80);
  format %{
             "CMPU$cop $tmp1,$tmp2\t @cmovI_cmpU_reg_reg\n\t"
             "CMOV $dst,$src\t @cmovI_cmpU_reg_reg"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    Register dst = $dst$$Register;
    Register src = $src$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, op2, dst, src, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovI_cmpL_zero_reg(mRegI dst, mRegI src1, mRegI src2, mRegLorI2L tmp1, immL_0 zero, cmpOp cop ) %{
  match(Set dst (CMoveI (Binary cop (CmpL tmp1 zero)) (Binary src1 src2)));
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $zero\t  @cmovI_cmpL_zero_reg\n"
             "\tCMOV  $dst,$src1, $src2 \t @cmovI_cmpL_zero_reg"
         %}
  ins_encode %{
    Register opr1 = as_Register($tmp1$$reg);
    Register dst  = $dst$$Register;
    Register src1  = $src1$$Register;
    Register src2  = $src2$$Register;
    int     flag  = $cop$$cmpcode;

    __ cmp_cmov(opr1, R0, dst, src1, src2, (MacroAssembler::CMCompare) flag, true /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovI_cmpUL_zero_reg(mRegI dst, mRegI src1, mRegI src2, mRegLorI2L tmp1, immL_0 zero, cmpOp cop) %{
  match(Set dst (CMoveI (Binary cop (CmpUL tmp1 zero)) (Binary src1 src2)));
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $zero\t  @cmovI_cmpUL_zero_reg\n"
             "\tCMOV  $dst,$src1, $src2 \t @cmovI_cmpUL_zero_reg"
         %}
  ins_encode %{
    Register opr1 = as_Register($tmp1$$reg);
    Register dst  = $dst$$Register;
    Register src1  = $src1$$Register;
    Register src2  = $src2$$Register;
    int     flag  = $cop$$cmpcode;

    __ cmp_cmov(opr1, R0, dst, src1, src2, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovI_cmpL_reg_zero(mRegI dst, mRegI src1, immI_0 zeroI, mRegL tmp1, mRegL tmp2, cmpOp cop ) %{
  match(Set dst (CMoveI (Binary cop (CmpL tmp1 tmp2)) (Binary src1 zeroI)));
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovI_cmpL_reg_zero\n"
             "\tCMOV  $dst, $src1, $zeroI \t @cmovI_cmpL_reg_zero"
         %}
  ins_encode %{
    Register op1 = as_Register($tmp1$$reg);
    Register op2 = as_Register($tmp2$$reg);
    Register dst  = $dst$$Register;
    Register src1  = $src1$$Register;
    int     flag  = $cop$$cmpcode;

    __ cmp_cmov_zero(op1, op2, dst, src1, (MacroAssembler::CMCompare) flag, true /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovI_cmpUL_reg_zero(mRegI dst, mRegI src1, immI_0 zeroI, mRegL tmp1, mRegL tmp2, cmpOp cop) %{
  match(Set dst (CMoveI (Binary cop (CmpUL tmp1 tmp2)) (Binary src1 zeroI)));
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovI_cmpUL_reg_zero\n"
             "\tCMOV  $dst, $src1, $zeroI \t @cmovI_cmpUL_reg_zero"
         %}
  ins_encode %{
    Register op1 = as_Register($tmp1$$reg);
    Register op2 = as_Register($tmp2$$reg);
    Register dst = $dst$$Register;
    Register src1 = $src1$$Register;
    int      flag = $cop$$cmpcode;

    __ cmp_cmov_zero(op1, op2, dst, src1, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovI_cmpL_zero_zero(mRegI dst, mRegI src1, immI_0 zeroI, mRegL tmp1, immL_0 zeroL, cmpOp cop ) %{
  match(Set dst (CMoveI (Binary cop (CmpL tmp1 zeroL)) (Binary src1 zeroI)));
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $zeroL\t  @cmovI_cmpL_zero_zero\n"
             "\tCMOV  $dst, $src1, $zeroI \t @cmovI_cmpL_zero_zero"
         %}
  ins_encode %{
    Register opr1 = as_Register($tmp1$$reg);
    Register dst  = $dst$$Register;
    Register src1  = $src1$$Register;
    int     flag  = $cop$$cmpcode;

    __ cmp_cmov_zero(opr1, R0, dst, src1, (MacroAssembler::CMCompare) flag, true /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovI_cmpUL_zero_zero(mRegI dst, mRegI src1, immI_0 zeroI, mRegL tmp1, immL_0 zeroL, cmpOp cop) %{
  match(Set dst (CMoveI (Binary cop (CmpUL tmp1 zeroL)) (Binary src1 zeroI)));
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $zeroL\t  @cmovI_cmpUL_zero_zero\n"
             "\tCMOV  $dst, $src1, $zeroI \t @cmovI_cmpUL_zero_zero"
         %}
  ins_encode %{
    Register opr1 = as_Register($tmp1$$reg);
    Register dst  = $dst$$Register;
    Register src1  = $src1$$Register;
    int     flag  = $cop$$cmpcode;

    __ cmp_cmov_zero(opr1, R0, dst, src1, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovI_cmpL_reg_reg(mRegI dst, mRegIorL2I src, mRegLorI2L tmp1, mRegLorI2L tmp2, cmpOp cop ) %{
  match(Set dst (CMoveI (Binary cop (CmpL tmp1 tmp2)) (Binary dst src)));
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovI_cmpL_reg_reg\n"
             "\tCMOV  $dst,$src \t @cmovI_cmpL_reg_reg"
         %}
  ins_encode %{
    Register opr1 = as_Register($tmp1$$reg);
    Register opr2 = as_Register($tmp2$$reg);
    Register dst  = $dst$$Register;
    Register src  = $src$$Register;
    int     flag  = $cop$$cmpcode;

    __ cmp_cmov(opr1, opr2, dst, src, (MacroAssembler::CMCompare) flag, true /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovI_cmpUL_reg_reg(mRegI dst, mRegIorL2I src, mRegLorI2L tmp1, mRegLorI2L tmp2, cmpOp cop) %{
  match(Set dst (CMoveI (Binary cop (CmpUL tmp1 tmp2)) (Binary dst src)));
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovI_cmpUL_reg_reg\n"
             "\tCMOV  $dst,$src \t @cmovI_cmpUL_reg_reg"
         %}
  ins_encode %{
    Register opr1 = as_Register($tmp1$$reg);
    Register opr2 = as_Register($tmp2$$reg);
    Register dst  = $dst$$Register;
    Register src  = $src$$Register;
    int     flag  = $cop$$cmpcode;

    __ cmp_cmov(opr1, opr2, dst, src, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovP_cmpL_zero_reg(mRegP dst, mRegP src1, mRegP src2, mRegLorI2L tmp1, immL_0 zero, cmpOp cop ) %{
  match(Set dst (CMoveP (Binary cop (CmpL tmp1 zero)) (Binary src1 src2)));
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $zero\t  @cmovP_cmpL_zero_reg\n"
             "\tCMOV  $dst,$src1, $src2 \t @cmovP_cmpL_zero_reg"
         %}
  ins_encode %{
    Register op1 = as_Register($tmp1$$reg);
    Register dst  = $dst$$Register;
    Register src1  = $src1$$Register;
    Register src2  = $src2$$Register;
    int     flag  = $cop$$cmpcode;

    __ cmp_cmov(op1, R0, dst, src1, src2, (MacroAssembler::CMCompare) flag, true /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovP_cmpUL_zero_reg(mRegP dst, mRegP src1, mRegP src2, mRegLorI2L tmp1, immL_0 zero, cmpOp cop) %{
  match(Set dst (CMoveP (Binary cop (CmpUL tmp1 zero)) (Binary src1 src2)));
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $zero\t  @cmovP_cmpUL_zero_reg\n"
             "\tCMOV  $dst,$src1, $src2 \t @cmovP_cmpUL_zero_reg"
         %}
  ins_encode %{
    Register op1 = as_Register($tmp1$$reg);
    Register dst = $dst$$Register;
    Register src1  = $src1$$Register;
    Register src2  = $src2$$Register;
    int     flag  = $cop$$cmpcode;

    __ cmp_cmov(op1, R0, dst, src1, src2, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovP_cmpL_reg_zero(mRegP dst, immP_0 zero, mRegL tmp1, mRegL tmp2, cmpOp cop ) %{
  match(Set dst (CMoveP (Binary cop (CmpL tmp1 tmp2)) (Binary dst zero)));
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovP_cmpL_reg_zero\n"
             "\tCMOV  $dst,$zero \t @cmovP_cmpL_reg_zero"
         %}
  ins_encode %{
    Register op1 = as_Register($tmp1$$reg);
    Register op2 = as_Register($tmp2$$reg);
    Register dst  = $dst$$Register;
    int     flag  = $cop$$cmpcode;

    __ cmp_cmov_zero(op1, op2, dst, dst, (MacroAssembler::CMCompare) flag, true /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovP_cmpUL_reg_zero(mRegP dst, immP_0 zero, mRegL tmp1, mRegL tmp2, cmpOp cop) %{
  match(Set dst (CMoveP (Binary cop (CmpUL tmp1 tmp2)) (Binary dst zero)));
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovP_cmpUL_reg_zero\n"
             "\tCMOV  $dst,$zero \t @cmovP_cmpUL_reg_zero"
         %}
  ins_encode %{
    Register op1 = as_Register($tmp1$$reg);
    Register op2 = as_Register($tmp2$$reg);
    Register dst = $dst$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov_zero(op1, op2, dst, dst, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovP_cmpL_zero_zero(mRegP dst, mRegP src1, immP_0 zeroP, mRegL tmp1, immL_0 zeroL, cmpOp cop ) %{
  match(Set dst (CMoveP (Binary cop (CmpL tmp1 zeroL)) (Binary src1 zeroP)));
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $zeroL\t  @cmovP_cmpL_zero_zero\n"
             "\tCMOV  $dst,$zeroP \t @cmovP_cmpL_zero_zero"
         %}
  ins_encode %{
    Register op1 = as_Register($tmp1$$reg);
    Register src1  = $src1$$Register;
    Register dst  = $dst$$Register;
    int     flag  = $cop$$cmpcode;

    __ cmp_cmov_zero(op1, R0, dst, src1, (MacroAssembler::CMCompare) flag, true /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovP_cmpUL_zero_zero(mRegP dst, mRegP src1, immP_0 zeroP, mRegL tmp1, immL_0 zeroL, cmpOp cop) %{
  match(Set dst (CMoveP (Binary cop (CmpUL tmp1 zeroL)) (Binary src1 zeroP)));
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $zeroL\t  @cmovP_cmpUL_zero_zero\n"
             "\tCMOV  $dst,$zeroP \t @cmovP_cmpUL_zero_zero"
         %}
  ins_encode %{
    Register op1 = as_Register($tmp1$$reg);
    Register src1 = $src1$$Register;
    Register dst  = $dst$$Register;
    int     flag  = $cop$$cmpcode;

    __ cmp_cmov_zero(op1, R0, dst, src1, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovP_cmpL_reg_reg(mRegP dst, mRegP src, mRegLorI2L tmp1, mRegLorI2L tmp2, cmpOp cop ) %{
  match(Set dst (CMoveP (Binary cop (CmpL tmp1 tmp2)) (Binary dst src)));
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovP_cmpL_reg_reg\n"
             "\tCMOV  $dst,$src \t @cmovP_cmpL_reg_reg"
         %}
  ins_encode %{
    Register opr1 = as_Register($tmp1$$reg);
    Register opr2 = as_Register($tmp2$$reg);
    Register dst  = $dst$$Register;
    Register src  = $src$$Register;
    int     flag  = $cop$$cmpcode;

    __ cmp_cmov(opr1, opr2, dst, src, (MacroAssembler::CMCompare) flag, true /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovP_cmpUL_reg_reg(mRegP dst, mRegP src, mRegLorI2L tmp1, mRegLorI2L tmp2, cmpOp cop) %{
  match(Set dst (CMoveP (Binary cop (CmpUL tmp1 tmp2)) (Binary dst src)));
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovP_cmpUL_reg_reg\n"
             "\tCMOV  $dst,$src \t @cmovP_cmpUL_reg_reg"
         %}
  ins_encode %{
    Register opr1 = as_Register($tmp1$$reg);
    Register opr2 = as_Register($tmp2$$reg);
    Register dst  = $dst$$Register;
    Register src  = $src$$Register;
    int     flag  = $cop$$cmpcode;

    __ cmp_cmov(opr1, opr2, dst, src, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovI_cmpD_reg_reg(mRegI dst, mRegI src, regD tmp1, regD tmp2, cmpOp cop, regD tmp3, regD tmp4) %{
  match(Set dst (CMoveI (Binary cop (CmpD tmp1 tmp2)) (Binary dst src)));
  effect(TEMP tmp3, TEMP tmp4);
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovI_cmpD_reg_reg\n"
             "\tCMOV  $dst,$src \t @cmovI_cmpD_reg_reg"
         %}
  ins_encode %{
    FloatRegister reg_op1 = as_FloatRegister($tmp1$$reg);
    FloatRegister reg_op2 = as_FloatRegister($tmp2$$reg);
    FloatRegister tmp1 = $tmp3$$FloatRegister;
    FloatRegister tmp2 = $tmp4$$FloatRegister;
    Register dst = as_Register($dst$$reg);
    Register src = as_Register($src$$reg);
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(reg_op1, reg_op2, dst, src, tmp1, tmp2, (MacroAssembler::CMCompare) flag, false /* is_float */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovP_cmpP_zero_reg(mRegP dst, mRegP src1, mRegP src2, mRegP tmp1, immP_0 zero, cmpOp cop ) %{
  match(Set dst (CMoveP (Binary cop (CmpP tmp1 zero)) (Binary src1 src2)));
  ins_cost(80);
  format %{
             "CMPU$cop $tmp1,$zero\t @cmovP_cmpP_zero_reg\n\t"
             "CMOV $dst,$src1, $src2\t @cmovP_cmpP_zero_reg"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, R0, dst, src1, src2, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovP_cmpP_reg_zero(mRegP dst, immP_0 zero, mRegP tmp1, mRegP tmp2, cmpOp cop ) %{
  match(Set dst (CMoveP (Binary cop (CmpP tmp1 tmp2)) (Binary dst zero)));
  ins_cost(80);
  format %{
             "CMPU$cop $tmp1,$tmp2\t @cmovP_cmpP_reg_zero\n\t"
             "CMOV $dst,$zero\t @cmovP_cmpP_reg_zero"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    Register dst = $dst$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov_zero(op1, op2, dst, dst, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovP_cmpP_reg_reg(mRegP dst, mRegP src, mRegP tmp1, mRegP tmp2, cmpOp cop ) %{
  match(Set dst (CMoveP (Binary cop (CmpP tmp1 tmp2)) (Binary dst src)));
  ins_cost(80);
  format %{
             "CMPU$cop $tmp1,$tmp2\t @cmovP_cmpP_reg_reg\n\t"
             "CMOV $dst,$src\t @cmovP_cmpP_reg_reg"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    Register dst = $dst$$Register;
    Register src = $src$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, op2, dst, src, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovP_cmpI_zero_reg(mRegP dst, mRegP src1, mRegP src2, mRegI tmp1, immI_0 zero, cmpOp cop ) %{
  match(Set dst (CMoveP (Binary cop (CmpI tmp1 zero)) (Binary src1 src2)));
  ins_cost(80);
  format %{
             "CMP$cop $tmp1,$zero\t @cmovP_cmpI_zero_reg\n\t"
             "CMOV $dst,$src1, $src2\t @cmovP_cmpI_zero_reg"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, R0, dst, src1, src2, (MacroAssembler::CMCompare) flag, true /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovP_cmpI_reg_zero(mRegP dst, immP_0 zero, mRegI tmp1, mRegI tmp2, cmpOp cop ) %{
  match(Set dst (CMoveP (Binary cop (CmpI tmp1 tmp2)) (Binary dst zero)));
  ins_cost(80);
  format %{
             "CMP$cop $tmp1,$tmp2\t @cmovP_cmpI_reg_zero\n\t"
             "CMOV $dst,$zero\t @cmovP_cmpI_reg_zero"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    Register dst = $dst$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov_zero(op1, op2, dst, dst, (MacroAssembler::CMCompare) flag, true /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovP_cmpI_zero_zero(mRegP dst, mRegP src1, immP_0 zeroP, mRegI tmp1, immI_0 zeroI, cmpOp cop ) %{
  match(Set dst (CMoveP (Binary cop (CmpI tmp1 zeroI)) (Binary src1 zeroP)));
  ins_cost(80);
  format %{
             "CMP$cop $tmp1,$zeroI\t @cmovP_cmpI_zero_zero\n\t"
             "CMOV $dst,$zeroP\t @cmovP_cmpI_zero_zero"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register src1 = $src1$$Register;
    Register dst = $dst$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov_zero(op1, R0, dst, src1, (MacroAssembler::CMCompare) flag, true /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovP_cmpI_reg_reg(mRegP dst, mRegP src, mRegI tmp1, mRegI tmp2, cmpOp cop ) %{
  match(Set dst (CMoveP (Binary cop (CmpI tmp1 tmp2)) (Binary dst src)));
  ins_cost(80);
  format %{
             "CMP$cop $tmp1,$tmp2\t @cmovP_cmpI_reg_reg\n\t"
             "CMOV $dst,$src\t @cmovP_cmpI_reg_reg"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    Register dst = $dst$$Register;
    Register src = $src$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, op2, dst, src, (MacroAssembler::CMCompare) flag, true /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovL_cmpP_zero_reg(mRegL dst, mRegL src1, mRegL src2, mRegP tmp1, immP_0 zero, cmpOp cop ) %{
  match(Set dst (CMoveL (Binary cop (CmpP tmp1 zero)) (Binary src1 src2)));
  ins_cost(80);
  format %{
             "CMPU$cop $tmp1,$zero\t @cmovL_cmpP_zero_reg\n\t"
             "CMOV $dst,$src1, $src2\t @cmovL_cmpP_zero_reg"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;
    int     flag = $cop$$cmpcode;
    Label L;

    __ cmp_cmov(op1, R0, dst, src1, src2, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovL_cmpP_reg_reg(mRegL dst, mRegL src, mRegP tmp1, mRegP tmp2, cmpOp cop ) %{
  match(Set dst (CMoveL (Binary cop (CmpP tmp1 tmp2)) (Binary dst src)));
  ins_cost(80);
  format %{
             "CMPU$cop $tmp1,$tmp2\t @cmovL_cmpP_reg_reg\n\t"
             "CMOV $dst,$src\t @cmovL_cmpP_reg_reg"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    Register dst = $dst$$Register;
    Register src = $src$$Register;
    int     flag = $cop$$cmpcode;
    Label L;

    __ cmp_cmov(op1, op2, dst, src, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovN_cmpU_zero_reg(mRegN dst, mRegN src1, mRegN src2, mRegI tmp1, immI_0 zero, cmpOp cop ) %{
  match(Set dst (CMoveN (Binary cop (CmpU tmp1 zero)) (Binary src1 src2)));
  ins_cost(80);
  format %{
             "CMPU$cop $tmp1,$zero\t @cmovN_cmpU_zero_reg\n\t"
             "CMOV $dst,$src1, $src2\t @cmovN_cmpU_zero_reg"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, R0, dst, src1, src2, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovN_cmpU_reg_reg(mRegN dst, mRegN src, mRegI tmp1, mRegI tmp2, cmpOp cop ) %{
  match(Set dst (CMoveN (Binary cop (CmpU tmp1 tmp2)) (Binary dst src)));
  ins_cost(80);
  format %{
             "CMPU$cop $tmp1,$tmp2\t @cmovN_cmpU_reg_reg\n\t"
             "CMOV $dst,$src\t @cmovN_cmpU_reg_reg"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    Register dst = $dst$$Register;
    Register src = $src$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, op2, dst, src, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovN_cmpL_zero_reg(mRegN dst, mRegN src1, mRegN src2, mRegL tmp1, immL_0 zero, cmpOp cop) %{
  match(Set dst (CMoveN (Binary cop (CmpL tmp1 zero)) (Binary src1 src2)));
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $zero\t  @cmovN_cmpL_zero_reg\n"
             "\tCMOV  $dst, $src1, $src2 \t @cmovN_cmpL_zero_reg"
         %}
  ins_encode %{
    Register opr1 = as_Register($tmp1$$reg);
    Register dst  = $dst$$Register;
    Register src1  = $src1$$Register;
    Register src2  = $src2$$Register;
    int     flag  = $cop$$cmpcode;

    __ cmp_cmov(opr1, R0, dst, src1, src2, (MacroAssembler::CMCompare) flag, true /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovN_cmpUL_zero_reg(mRegN dst, mRegN src1, mRegN src2, mRegL tmp1, immL_0 zero, cmpOp cop) %{
  match(Set dst (CMoveN (Binary cop (CmpUL tmp1 zero)) (Binary src1 src2)));
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $zero\t  @cmovN_cmpUL_zero_reg\n"
             "\tCMOV  $dst, $src1, $src2 \t @cmovN_cmpUL_zero_reg"
         %}
  ins_encode %{
    Register opr1 = as_Register($tmp1$$reg);
    Register dst  = $dst$$Register;
    Register src1  = $src1$$Register;
    Register src2  = $src2$$Register;
    int     flag  = $cop$$cmpcode;

    __ cmp_cmov(opr1, R0, dst, src1, src2, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovN_cmpL_reg_reg(mRegN dst, mRegN src, mRegL tmp1, mRegL tmp2, cmpOp cop) %{
  match(Set dst (CMoveN (Binary cop (CmpL tmp1 tmp2)) (Binary dst src)));
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovN_cmpL_reg_reg\n"
             "\tCMOV  $dst,$src \t @cmovN_cmpL_reg_reg"
         %}
  ins_encode %{
    Register opr1 = as_Register($tmp1$$reg);
    Register opr2 = as_Register($tmp2$$reg);
    Register dst  = $dst$$Register;
    Register src  = $src$$Register;
    int     flag  = $cop$$cmpcode;

    __ cmp_cmov(opr1, opr2, dst, src, (MacroAssembler::CMCompare) flag, true /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovN_cmpUL_reg_reg(mRegN dst, mRegN src, mRegL tmp1, mRegL tmp2, cmpOp cop) %{
  match(Set dst (CMoveN (Binary cop (CmpUL tmp1 tmp2)) (Binary dst src)));
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovN_cmpUL_reg_reg\n"
             "\tCMOV  $dst,$src \t @cmovN_cmpUL_reg_reg"
         %}
  ins_encode %{
    Register opr1 = as_Register($tmp1$$reg);
    Register opr2 = as_Register($tmp2$$reg);
    Register dst  = $dst$$Register;
    Register src  = $src$$Register;
    int     flag  = $cop$$cmpcode;

    __ cmp_cmov(opr1, opr2, dst, src, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovN_cmpI_reg_reg(mRegN dst, mRegN src, mRegI tmp1, mRegI tmp2, cmpOp cop ) %{
  match(Set dst (CMoveN (Binary cop (CmpI tmp1 tmp2)) (Binary dst src)));
  ins_cost(80);
  format %{
             "CMP$cop $tmp1,$tmp2\t @cmovN_cmpI_reg_reg\n\t"
             "CMOV $dst,$src\t @cmovN_cmpI_reg_reg"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    Register dst = $dst$$Register;
    Register src = $src$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, op2, dst, src, (MacroAssembler::CMCompare) flag, true /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovN_cmpI_zero_reg(mRegN dst, mRegN src1, mRegN src2, mRegI tmp1, immI_0 zero, cmpOp cop ) %{
  match(Set dst (CMoveN (Binary cop (CmpI tmp1 zero)) (Binary src1 src2)));
  ins_cost(80);
  format %{
             "CMP$cop $tmp1,$zero\t @cmovN_cmpI_zero_reg\n\t"
             "CMOV $dst,$src1,$src2\t @cmovN_cmpI_zero_reg"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, R0, dst, src1, src2, (MacroAssembler::CMCompare) flag, true /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovL_cmpU_zero_reg(mRegL dst, mRegL src1, mRegL src2, mRegI tmp1, immI_0 zero, cmpOp cop ) %{
  match(Set dst (CMoveL (Binary cop (CmpU tmp1 zero)) (Binary src1 src2)));
  ins_cost(80);
  format %{
             "CMPU$cop $tmp1,$zero\t @cmovL_cmpU_zero_reg\n\t"
             "CMOV $dst,$src1,$src2\t @cmovL_cmpU_zero_reg"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, R0, dst, src1, src2, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovL_cmpU_reg_zero(mRegL dst, immL_0 zero, mRegI tmp1, mRegI tmp2, cmpOp cop ) %{
  match(Set dst (CMoveL (Binary cop (CmpU tmp1 tmp2)) (Binary dst zero)));
  ins_cost(80);
  format %{
             "CMPU$cop $tmp1,$tmp2\t @cmovL_cmpU_reg_zero\n\t"
             "CMOV $dst,$zero\t @cmovL_cmpU_reg_zero"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    Register dst = $dst$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov_zero(op1, op2, dst, dst, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovL_cmpU_zero_zero(mRegL dst, mRegL src1, immL_0 zeroL, mRegI tmp1, immI_0 zeroI, cmpOp cop ) %{
  match(Set dst (CMoveL (Binary cop (CmpU tmp1 zeroI)) (Binary src1 zeroL)));
  ins_cost(80);
  format %{
             "CMPU$cop $tmp1,$zeroI\t @cmovL_cmpU_zero_zero\n\t"
             "CMOV $dst,$zeroL\t @cmovL_cmpU_zero_zero"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register src1 = $src1$$Register;
    Register dst = $dst$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov_zero(op1, R0, dst, src1, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovL_cmpU_reg_reg(mRegL dst, mRegL src, mRegI tmp1, mRegI tmp2, cmpOp cop ) %{
  match(Set dst (CMoveL (Binary cop (CmpU tmp1 tmp2)) (Binary dst src)));
  ins_cost(80);
  format %{
             "CMPU$cop $tmp1,$tmp2\t @cmovL_cmpU_reg_reg\n\t"
             "CMOV $dst,$src\t @cmovL_cmpU_reg_reg"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    Register dst = $dst$$Register;
    Register src = $src$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, op2, dst, src, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovL_cmpF_reg_reg(mRegL dst, mRegL src, regF tmp1, regF tmp2, cmpOp cop, regD tmp3, regD tmp4) %{
  match(Set dst (CMoveL (Binary cop (CmpF tmp1 tmp2)) (Binary dst src)));
  effect(TEMP tmp3, TEMP tmp4);
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovL_cmpF_reg_reg\n"
             "\tCMOV  $dst,$src \t @cmovL_cmpF_reg_reg"
         %}

  ins_encode %{
    FloatRegister reg_op1 = $tmp1$$FloatRegister;
    FloatRegister reg_op2 = $tmp2$$FloatRegister;
    FloatRegister tmp1 = $tmp3$$FloatRegister;
    FloatRegister tmp2 = $tmp4$$FloatRegister;
    Register dst = $dst$$Register;
    Register src = $src$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(reg_op1, reg_op2, dst, src, tmp1, tmp2, (MacroAssembler::CMCompare) flag, true /* is_float */);
  %}
  ins_pipe( pipe_slow );
%}

instruct cmovL_cmpI_zero_reg(mRegL dst, mRegL src1, mRegL src2, mRegI tmp1, immI_0 zero, cmpOp cop ) %{
  match(Set dst (CMoveL (Binary cop (CmpI tmp1 zero)) (Binary src1 src2)));
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $zero\t  @cmovL_cmpI_zero_reg\n"
             "\tCMOV  $dst, $src1, $src2 \t @cmovL_cmpI_zero_reg"
         %}

  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register dst = as_Register($dst$$reg);
    Register src1 = as_Register($src1$$reg);
    Register src2 = as_Register($src2$$reg);
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, R0, dst, src1, src2, (MacroAssembler::CMCompare) flag, true /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovL_cmpI_reg_zero(mRegL dst, immL_0 zero, mRegI tmp1, mRegI tmp2, cmpOp cop ) %{
  match(Set dst (CMoveL (Binary cop (CmpI tmp1 tmp2)) (Binary dst zero)));
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovL_cmpI_reg_zero\n"
             "\tCMOV  $dst,$zero \t @cmovL_cmpI_reg_zero"
         %}

  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    Register dst = as_Register($dst$$reg);
    int     flag = $cop$$cmpcode;

    __ cmp_cmov_zero(op1, op2, dst, dst, (MacroAssembler::CMCompare) flag, true /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovL_cmpI_zero_zero(mRegL dst, mRegL src1, immL_0 zeroL, mRegI tmp1, immI_0 zeroI, cmpOp cop ) %{
  match(Set dst (CMoveL (Binary cop (CmpI tmp1 zeroI)) (Binary src1 zeroL)));
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $zeroI\t  @cmovL_cmpI_zero_zero\n"
             "\tCMOV  $dst,$zeroL \t @cmovL_cmpI_zero_zero"
         %}

  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register src1 = $src1$$Register;
    Register dst = as_Register($dst$$reg);
    int     flag = $cop$$cmpcode;

    __ cmp_cmov_zero(op1, R0, dst, src1, (MacroAssembler::CMCompare) flag, true /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovL_cmpI_reg_reg(mRegL dst, mRegL src, mRegI tmp1, mRegI tmp2, cmpOp cop ) %{
  match(Set dst (CMoveL (Binary cop (CmpI tmp1 tmp2)) (Binary dst src)));
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovL_cmpI_reg_reg\n"
             "\tCMOV  $dst,$src \t @cmovL_cmpI_reg_reg"
         %}

  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    Register dst = as_Register($dst$$reg);
    Register src = as_Register($src$$reg);
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, op2, dst, src, (MacroAssembler::CMCompare) flag, true /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovL_cmpL_reg_reg(mRegL dst, mRegL src1, mRegL src2, cmpOp cop ) %{
  match(Set dst (CMoveL (Binary cop (CmpL src1 src2)) (Binary src1 src2)));
  ins_cost(50);
  format %{
             "CMP$cop  $src1, $src2\t  @cmovL_cmpL_reg_reg\n"
             "\tCMOV  $dst,$src1, $src2 \t @cmovL_cmpL_reg_reg"
         %}

  ins_encode %{
    Register op1 = $src1$$Register;
    Register op2 = $src2$$Register;
    Register dst = $dst$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, op2, dst, op1, op2, (MacroAssembler::CMCompare) flag, true);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovL_cmpUL_reg_reg(mRegL dst, mRegL src1, mRegL src2, cmpOp cop) %{
  match(Set dst (CMoveL (Binary cop (CmpUL src1 src2)) (Binary src1 src2)));
  ins_cost(50);
  format %{
             "CMP$cop  $src1, $src2\t  @cmovL_cmpUL_reg_reg\n"
             "\tCMOV  $dst,$src1, $src2 \t @cmovL_cmpUL_reg_reg"
         %}

  ins_encode %{
    Register op1 = $src1$$Register;
    Register op2 = $src2$$Register;
    Register dst = $dst$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, op2, dst, op1, op2, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovL_cmpL_reg_zero(mRegL dst, mRegL src1, immL_0 zero, mRegL tmp1, mRegL tmp2, cmpOp cop ) %{
  match(Set dst (CMoveL (Binary cop (CmpL tmp1 tmp2)) (Binary src1 zero)));
  ins_cost(20);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovL_cmpL_reg_zero\n"
             "\tCMOV  $dst,$src1, $zero \t @cmovL_cmpL_reg_zero"
         %}

  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    Register dst = $dst$$Register;
    Register src1 = $src1$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov_zero(op1, op2, dst, src1, (MacroAssembler::CMCompare) flag, true);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovL_cmpUL_reg_zero(mRegL dst, mRegL src1, immL_0 zero, mRegL tmp1, mRegL tmp2, cmpOp cop) %{
  match(Set dst (CMoveL (Binary cop (CmpUL tmp1 tmp2)) (Binary src1 zero)));
  ins_cost(20);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovL_cmpUL_reg_zero\n"
             "\tCMOV  $dst,$src1, $zero \t @cmovL_cmpUL_reg_zero"
         %}

  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    Register dst = $dst$$Register;
    Register src1 = $src1$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov_zero(op1, op2, dst, src1, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovL_cmpL_reg_reg2(mRegL dst, mRegL src1, mRegL src2, cmpOp cop ) %{
  match(Set dst (CMoveL (Binary cop (CmpL src1 src2)) (Binary src2 src1)));
  ins_cost(50);
  format %{
             "CMP$cop  $src1, $src2\t  @cmovL_cmpL_reg_reg2\n"
             "\tCMOV  $dst,$src2, $src1 \t @cmovL_cmpL_reg_reg2"
         %}

  ins_encode %{
    Register op1 = $src1$$Register;
    Register op2 = $src2$$Register;
    Register dst = $dst$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, op2, dst, op2, op1, (MacroAssembler::CMCompare) flag, true);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovL_cmpUL_reg_reg2(mRegL dst, mRegL src1, mRegL src2, cmpOp cop) %{
  match(Set dst (CMoveL (Binary cop (CmpUL src1 src2)) (Binary src2 src1)));
  ins_cost(50);
  format %{
             "CMP$cop  $src1, $src2\t  @cmovL_cmpUL_reg_reg2\n"
             "\tCMOV  $dst,$src2, $src1 \t @cmovL_cmpUL_reg_reg2"
         %}

  ins_encode %{
    Register op1 = $src1$$Register;
    Register op2 = $src2$$Register;
    Register dst = $dst$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, op2, dst, op2, op1, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovL_cmpL_zero_reg(mRegL dst, mRegL src1, mRegL src2, mRegL tmp1, immL_0 zero, cmpOp cop ) %{
  match(Set dst (CMoveL (Binary cop (CmpL tmp1 zero)) (Binary src1 src2)));
  ins_cost(20);
  format %{
             "CMP$cop  $tmp1, $zero\t  @cmovL_cmpL_zero_reg\n"
             "\tCMOV  $dst,$src1, $src2 \t @cmovL_cmpL_zero_reg"
         %}

  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, R0, dst, src1, src2, (MacroAssembler::CMCompare) flag,true);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovL_cmpUL_zero_reg(mRegL dst, mRegL src1, mRegL src2, mRegL tmp1, immL_0 zero, cmpOp cop) %{
  match(Set dst (CMoveL (Binary cop (CmpUL tmp1 zero)) (Binary src1 src2)));
  ins_cost(20);
  format %{
             "CMP$cop  $tmp1, $zero\t  @cmovL_cmpUL_zero_reg\n"
             "\tCMOV  $dst,$src1, $src2 \t @cmovL_cmpUL_zero_reg"
         %}

  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, R0, dst, src1, src2, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovL_cmpL_zero_zero(mRegL dst, mRegL src1, immL_0 zero, mRegL tmp1, cmpOp cop ) %{
  match(Set dst (CMoveL (Binary cop (CmpL tmp1 zero)) (Binary src1 zero)));
  ins_cost(20);
  format %{
             "CMP$cop  $tmp1, $zero\t  @cmovL_cmp_zero_zero\n"
             "\tCMOV  $dst,$src1, $zero \t @cmovL_cmpL_zero_zero"
         %}

  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register dst = $dst$$Register;
    Register src1 = $src1$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov_zero(op1, R0, dst, src1, (MacroAssembler::CMCompare) flag, true);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovL_cmpUL_zero_zero(mRegL dst, mRegL src1, immL_0 zero, mRegL tmp1, cmpOp cop) %{
  match(Set dst (CMoveL (Binary cop (CmpUL tmp1 zero)) (Binary src1 zero)));
  ins_cost(20);
  format %{
             "CMP$cop  $tmp1, $zero\t  @cmovL_cmpUL_zero_zero\n"
             "\tCMOV  $dst,$src1, $zero \t @cmovL_cmpUL_zero_zero"
         %}

  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register dst = $dst$$Register;
    Register src1 = $src1$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov_zero(op1, R0, dst, src1, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovL_cmpL_dst_reg(mRegL dst, mRegL src, mRegL tmp1, mRegL tmp2, cmpOp cop ) %{
  match(Set dst (CMoveL (Binary cop (CmpL tmp1 tmp2)) (Binary dst src)));
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovL_cmpL_dst_reg\n"
             "\tCMOV  $dst,$src \t @cmovL_cmpL_dst_reg"
         %}
  ins_encode %{
    Register opr1 = as_Register($tmp1$$reg);
    Register opr2 = as_Register($tmp2$$reg);
    Register dst  = as_Register($dst$$reg);
    Register src  = as_Register($src$$reg);
    int     flag  = $cop$$cmpcode;

    __ cmp_cmov(opr1, opr2, dst, src, (MacroAssembler::CMCompare) flag, true /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovL_cmpUL_dst_reg(mRegL dst, mRegL src, mRegL tmp1, mRegL tmp2, cmpOp cop) %{
  match(Set dst (CMoveL (Binary cop (CmpUL tmp1 tmp2)) (Binary dst src)));
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovL_cmpUL_dst_reg\n"
             "\tCMOV  $dst,$src \t @cmovL_cmpUL_dst_reg"
         %}
  ins_encode %{
    Register opr1 = as_Register($tmp1$$reg);
    Register opr2 = as_Register($tmp2$$reg);
    Register dst  = as_Register($dst$$reg);
    Register src  = as_Register($src$$reg);
    int     flag  = $cop$$cmpcode;

    __ cmp_cmov(opr1, opr2, dst, src, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovL_cmpN_reg_reg(mRegL dst, mRegL src, mRegN tmp1, mRegN tmp2, cmpOp cop ) %{
  match(Set dst (CMoveL (Binary cop (CmpN tmp1 tmp2)) (Binary dst src)));
  ins_cost(80);
  format %{
             "CMPU$cop $tmp1,$tmp2\t @cmovL_cmpN_reg_reg\n\t"
             "CMOV $dst,$src\t @cmovL_cmpN_reg_reg"
         %}
  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    Register dst = $dst$$Register;
    Register src = $src$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, op2, dst, src, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}


instruct cmovL_cmpD_reg_reg(mRegL dst, mRegL src, regD tmp1, regD tmp2, cmpOp cop, regD tmp3, regD tmp4) %{
  match(Set dst (CMoveL (Binary cop (CmpD tmp1 tmp2)) (Binary dst src)));
  effect(TEMP tmp3, TEMP tmp4);
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovL_cmpD_reg_reg\n"
             "\tCMOV  $dst,$src \t @cmovL_cmpD_reg_reg"
         %}
  ins_encode %{
    FloatRegister reg_op1 = as_FloatRegister($tmp1$$reg);
    FloatRegister reg_op2 = as_FloatRegister($tmp2$$reg);
    FloatRegister tmp1 = $tmp3$$FloatRegister;
    FloatRegister tmp2 = $tmp4$$FloatRegister;
    Register dst = as_Register($dst$$reg);
    Register src = as_Register($src$$reg);
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(reg_op1, reg_op2, dst, src, tmp1, tmp2, (MacroAssembler::CMCompare) flag, false /* is_float */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovD_cmpD_reg_reg(regD dst, regD src, regD tmp1, regD tmp2, cmpOp cop ) %{
  match(Set dst (CMoveD (Binary cop (CmpD tmp1 tmp2)) (Binary dst src)));
  ins_cost(200);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovD_cmpD_reg_reg\n"
             "\tCMOV  $dst,$src \t @cmovD_cmpD_reg_reg"
         %}
  ins_encode %{
    FloatRegister reg_op1 = as_FloatRegister($tmp1$$reg);
    FloatRegister reg_op2 = as_FloatRegister($tmp2$$reg);
    FloatRegister dst = as_FloatRegister($dst$$reg);
    FloatRegister src = as_FloatRegister($src$$reg);
    int flag = $cop$$cmpcode;

    __ cmp_cmov(reg_op1, reg_op2, dst, src, (MacroAssembler::CMCompare) flag, false /* is_float */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovD_cmpF_reg_reg(regD dst, regD src, regF tmp1, regF tmp2, cmpOp cop ) %{
  match(Set dst (CMoveD (Binary cop (CmpF tmp1 tmp2)) (Binary dst src)));
  ins_cost(200);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovD_cmpF_reg_reg\n"
             "\tCMOV  $dst,$src \t @cmovD_cmpF_reg_reg"
         %}
  ins_encode %{
    FloatRegister reg_op1 = as_FloatRegister($tmp1$$reg);
    FloatRegister reg_op2 = as_FloatRegister($tmp2$$reg);
    FloatRegister dst = as_FloatRegister($dst$$reg);
    FloatRegister src = as_FloatRegister($src$$reg);
    int flag = $cop$$cmpcode;

    __ cmp_cmov(reg_op1, reg_op2, dst, src, (MacroAssembler::CMCompare) flag, true /* is_float */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovF_cmpI_reg_reg(regF dst, regF src, mRegI tmp1, mRegI tmp2, cmpOp cop) %{
  match(Set dst (CMoveF (Binary cop (CmpI tmp1 tmp2)) (Binary dst src)));
  ins_cost(200);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovF_cmpI_reg_reg\n"
             "\tCMOV  $dst, $src \t @cmovF_cmpI_reg_reg"
         %}

  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    FloatRegister dst = as_FloatRegister($dst$$reg);
    FloatRegister src = as_FloatRegister($src$$reg);
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, op2, dst, src, (MacroAssembler::CMCompare) flag);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovD_cmpN_reg_reg(regD dst, regD src, mRegN tmp1, mRegN tmp2, cmpOp cop) %{
  match(Set dst (CMoveD (Binary cop (CmpN tmp1 tmp2)) (Binary dst src)));
  ins_cost(200);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovD_cmpN_reg_reg\n"
             "\tCMOV  $dst, $src \t @cmovD_cmpN_reg_reg"
         %}

  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    FloatRegister dst = as_FloatRegister($dst$$reg);
    FloatRegister src = as_FloatRegister($src$$reg);
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, op2, dst, src, (MacroAssembler::CMCompare) flag, false /* is_signed */);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovF_cmpL_reg_reg(regF dst, regF src, mRegL tmp1, mRegL tmp2, cmpOp cop) %{
  match(Set dst (CMoveF (Binary cop (CmpL tmp1 tmp2)) (Binary dst src)));
  ins_cost(200);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovF_cmpL_reg_reg\n"
             "\tCMOV  $dst, $src \t @cmovF_cmpL_reg_reg"
         %}

  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    FloatRegister dst = as_FloatRegister($dst$$reg);
    FloatRegister src = as_FloatRegister($src$$reg);
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, op2, dst, src, (MacroAssembler::CMCompare) flag);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovD_cmpI_reg_reg(regD dst, regD src, mRegI tmp1, mRegI tmp2, cmpOp cop) %{
  match(Set dst (CMoveD (Binary cop (CmpI tmp1 tmp2)) (Binary dst src)));
  ins_cost(200);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovD_cmpI_reg_reg\n"
             "\tCMOV  $dst, $src \t @cmovD_cmpI_reg_reg"
         %}

  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    FloatRegister dst = as_FloatRegister($dst$$reg);
    FloatRegister src = as_FloatRegister($src$$reg);
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(op1, op2, dst, src, (MacroAssembler::CMCompare) flag);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmovD_cmpLorP_reg_reg(regD dst, regD src, mRegLorP tmp1, mRegLorP tmp2, cmpOp cop) %{
  match(Set dst (CMoveD (Binary cop (CmpP tmp1 tmp2)) (Binary dst src)));
  match(Set dst (CMoveD (Binary cop (CmpL tmp1 tmp2)) (Binary dst src)));
  ins_cost(200);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovD_cmpLorP_reg_reg\n"
             "\tCMOV  $dst, $src \t @cmovD_cmpLorP_reg_reg"
         %}

  ins_encode %{
    Register op1 = $tmp1$$Register;
    Register op2 = $tmp2$$Register;
    FloatRegister dst = as_FloatRegister($dst$$reg);
    FloatRegister src = as_FloatRegister($src$$reg);
    int     flag = $cop$$cmpcode;

    // Use signed comparison here, because the most significant bit of the
    // user-space virtual address must be 0.
    __ cmp_cmov(op1, op2, dst, src, (MacroAssembler::CMCompare) flag);
  %}

  ins_pipe( pipe_slow );
%}

//FIXME
instruct cmovI_cmpF_reg_reg(mRegI dst, mRegI src, regF tmp1, regF tmp2, cmpOp cop, regD tmp3, regD tmp4) %{
  match(Set dst (CMoveI (Binary cop (CmpF tmp1 tmp2)) (Binary dst src)));
  effect(TEMP tmp3, TEMP tmp4);
  ins_cost(80);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovI_cmpF_reg_reg\n"
             "\tCMOV  $dst,$src \t @cmovI_cmpF_reg_reg"
         %}

  ins_encode %{
    FloatRegister reg_op1 = $tmp1$$FloatRegister;
    FloatRegister reg_op2 = $tmp2$$FloatRegister;
    FloatRegister tmp1 = $tmp3$$FloatRegister;
    FloatRegister tmp2 = $tmp4$$FloatRegister;
    Register dst = $dst$$Register;
    Register src = $src$$Register;
    int     flag = $cop$$cmpcode;

    __ cmp_cmov(reg_op1, reg_op2, dst, src, tmp1, tmp2, (MacroAssembler::CMCompare) flag, true /* is_float */);
  %}
  ins_pipe( pipe_slow );
%}

instruct cmovF_cmpF_reg_reg(regF dst, regF src, regF tmp1, regF tmp2, cmpOp cop ) %{
  match(Set dst (CMoveF (Binary cop (CmpF tmp1 tmp2)) (Binary dst src)));
  ins_cost(200);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovF_cmpF_reg_reg\n"
             "\tCMOV  $dst,$src \t @cmovF_cmpF_reg_reg"
         %}

  ins_encode %{
    FloatRegister reg_op1 = $tmp1$$FloatRegister;
    FloatRegister reg_op2 = $tmp2$$FloatRegister;
    FloatRegister dst = $dst$$FloatRegister;
    FloatRegister src = $src$$FloatRegister;
    int flag = $cop$$cmpcode;

    __ cmp_cmov(reg_op1, reg_op2, dst, src, (MacroAssembler::CMCompare) flag, true /* is_float */);
  %}
  ins_pipe( pipe_slow );
%}

instruct cmovF_cmpD_reg_reg(regF dst, regF src, regD tmp1, regD tmp2, cmpOp cop ) %{
  match(Set dst (CMoveF (Binary cop (CmpD tmp1 tmp2)) (Binary dst src)));
  ins_cost(200);
  format %{
             "CMP$cop  $tmp1, $tmp2\t  @cmovF_cmpD_reg_reg\n"
             "\tCMOV  $dst,$src \t @cmovF_cmpD_reg_reg"
         %}

  ins_encode %{
    FloatRegister reg_op1 = $tmp1$$FloatRegister;
    FloatRegister reg_op2 = $tmp2$$FloatRegister;
    FloatRegister dst = $dst$$FloatRegister;
    FloatRegister src = $src$$FloatRegister;
    int flag = $cop$$cmpcode;

    __ cmp_cmov(reg_op1, reg_op2, dst, src, (MacroAssembler::CMCompare) flag, false /* is_float */);
  %}
  ins_pipe( pipe_slow );
%}

// Manifest a CmpL result in an integer register.  Very painful.
// This is the test to avoid.
instruct cmpL3_reg_zero(mRegI dst, mRegL src1, immL_0 zero) %{
  match(Set dst (CmpL3 src1 zero));
  match(Set dst (CmpL3 (CastLL src1) zero));
  ins_cost(1000);
  format %{ "cmpL3  $dst, $src1, zero @ cmpL3_reg_zero" %}
  ins_encode %{
    Register opr1 = as_Register($src1$$reg);
    Register dst  = as_Register($dst$$reg);
    __ slt(AT, opr1, R0);
    __ slt(dst, R0, opr1);
    __ sub_d(dst, dst, AT);
  %}
  ins_pipe( pipe_slow );
%}

// Manifest a CmpU result in an integer register.  Very painful.
// This is the test to avoid.
instruct cmpU3_reg_reg(mRegI dst, mRegI src1, mRegI src2) %{
  match(Set dst (CmpU3 src1 src2));
  format %{ "cmpU3  $dst, $src1, $src2 @ cmpU3_reg_reg" %}
  ins_encode %{
    Register opr1 = as_Register($src1$$reg);
    Register opr2 = as_Register($src2$$reg);
    Register dst  = as_Register($dst$$reg);

    __ sltu(AT, opr1, opr2);
    __ sltu(dst, opr2, opr1);
    __ sub_d(dst, dst, AT);
  %}
  ins_pipe( pipe_slow );
%}

instruct cmpL3_reg_reg(mRegI dst, mRegL src1, mRegL src2) %{
  match(Set dst (CmpL3 src1 src2));
  ins_cost(1000);
  format %{ "cmpL3  $dst, $src1, $src2 @ cmpL3_reg_reg" %}
  ins_encode %{
    Register opr1 = as_Register($src1$$reg);
    Register opr2 = as_Register($src2$$reg);
    Register dst  = as_Register($dst$$reg);

    __ slt(AT, opr1, opr2);
    __ slt(dst, opr2, opr1);
    __ sub_d(dst, dst, AT);
  %}
  ins_pipe( pipe_slow );
%}

// Manifest a CmpUL result in an integer register.  Very painful.
// This is the test to avoid.
instruct cmpUL3_reg_reg(mRegI dst, mRegLorI2L src1, mRegLorI2L src2) %{
  match(Set dst (CmpUL3 src1 src2));
  format %{ "cmpUL3  $dst, $src1, $src2 @ cmpUL3_reg_reg" %}
  ins_encode %{
    Register opr1 = as_Register($src1$$reg);
    Register opr2 = as_Register($src2$$reg);
    Register dst  = as_Register($dst$$reg);

    __ sltu(AT, opr1, opr2);
    __ sltu(dst, opr2, opr1);
    __ sub_d(dst, dst, AT);
  %}
  ins_pipe( pipe_slow );
%}

//
// less_rsult     = -1
// greater_result =  1
// equal_result   =  0
// nan_result     = -1
//
instruct cmpF3_reg_reg(mRegI dst, regF src1, regF src2) %{
  match(Set dst (CmpF3 src1 src2));
  ins_cost(1000);
  format %{ "cmpF3  $dst, $src1, $src2 @ cmpF3_reg_reg" %}
  ins_encode %{
    FloatRegister src1 = as_FloatRegister($src1$$reg);
    FloatRegister src2 = as_FloatRegister($src2$$reg);
    Register dst = as_Register($dst$$reg);

    if (src1 == src2) {
      __ fcmp_cun_s(FCC0, src1, src2);
      if (UseCF2GR) {
        __ movcf2gr(dst, FCC0);
      } else {
        __ movcf2fr(fscratch, FCC0);
        __ movfr2gr_s(dst, fscratch);
      }
      __ sub_w(dst, R0, dst);
    } else {
      __ fcmp_clt_s(FCC0, src2, src1);
      __ fcmp_cult_s(FCC1, src1, src2);
      if (UseCF2GR) {
        __ movcf2gr(dst, FCC0);
        __ movcf2gr(AT, FCC1);
      } else {
        __ movcf2fr(fscratch, FCC0);
        __ movfr2gr_s(dst, fscratch);
        __ movcf2fr(fscratch, FCC1);
        __ movfr2gr_s(AT, fscratch);
      }
      __ sub_d(dst, dst, AT);
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct cmpD3_reg_reg(mRegI dst, regD src1, regD src2) %{
  match(Set dst (CmpD3 src1 src2));
  ins_cost(1000);
  format %{ "cmpD3  $dst, $src1, $src2 @ cmpD3_reg_reg" %}
  ins_encode %{
    FloatRegister src1 = as_FloatRegister($src1$$reg);
    FloatRegister src2 = as_FloatRegister($src2$$reg);
    Register dst = as_Register($dst$$reg);

    if (src1 == src2) {
      __ fcmp_cun_d(FCC0, src1, src2);
      if (UseCF2GR) {
        __ movcf2gr(dst, FCC0);
      } else {
        __ movcf2fr(fscratch, FCC0);
        __ movfr2gr_s(dst, fscratch);
      }
      __ sub_d(dst, R0, dst);
    } else {
      __ fcmp_clt_d(FCC0, src2, src1);
      __ fcmp_cult_d(FCC1, src1, src2);
      if (UseCF2GR) {
        __ movcf2gr(dst, FCC0);
        __ movcf2gr(AT, FCC1);
      } else {
        __ movcf2fr(fscratch, FCC0);
        __ movfr2gr_s(dst, fscratch);
        __ movcf2fr(fscratch, FCC1);
        __ movfr2gr_s(AT, fscratch);
      }
      __ sub_d(dst, dst, AT);
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct clear_array(a2RegL cnt, a0_RegP base, Universe dummy, a1RegL value) %{
  match(Set dummy (ClearArray cnt base));
  effect(TEMP value, USE_KILL cnt, USE_KILL base);

  format %{ "CLEAR_ARRAY base = $base, cnt = $cnt @ clear_array" %}
  ins_encode %{
    // Assume cnt is the number of bytes in an array to be cleared,
    // and base points to the starting address of the array.
    __ move($value$$Register, R0);
    __ trampoline_call(RuntimeAddress(StubRoutines::la::arrayof_jlong_fill()));
  %}

  ins_pipe( pipe_slow );
%}

instruct string_compareL(a4_RegP str1, mA5RegI cnt1, a6_RegP str2, mA7RegI cnt2, mRegI result, mRegL tmp1, mRegL tmp2, regF vtmp1, regF vtmp2) %{
  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL);
  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
  effect(TEMP_DEF result, TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2);

  format %{ "String Compare byte[] $str1[len: $cnt1], $str2[len: $cnt2] tmp1:$tmp1, tmp2:$tmp2, vtmp1:$vtmp1, vtmp2:$vtmp2 -> $result @ string_compareL" %}
  ins_encode %{
    __ string_compare($str1$$Register, $str2$$Register,
                      $cnt1$$Register, $cnt2$$Register, $result$$Register,
                      StrIntrinsicNode::LL, $tmp1$$Register, $tmp2$$Register,
                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister);
  %}

  ins_pipe( pipe_slow );
%}

instruct string_compareU(a4_RegP str1, mA5RegI cnt1, a6_RegP str2, mA7RegI cnt2, mRegI result, mRegL tmp1, mRegL tmp2, regF vtmp1, regF vtmp2) %{
  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU);
  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
  effect(TEMP_DEF result, TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2);

  format %{ "String Compare char[] $str1[len: $cnt1], $str2[len: $cnt2] tmp1:$tmp1, tmp2:$tmp2, vtmp1:$vtmp1, vtmp2:$vtmp2 -> $result @ string_compareU" %}
  ins_encode %{
    __ string_compare($str1$$Register, $str2$$Register,
                      $cnt1$$Register, $cnt2$$Register, $result$$Register,
                      StrIntrinsicNode::UU, $tmp1$$Register, $tmp2$$Register,
                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister);
  %}

  ins_pipe( pipe_slow );
%}

instruct string_compareLU(a4_RegP str1, mA5RegI cnt1, a6_RegP str2, mA7RegI cnt2, mRegI result, mRegL tmp1, mRegL tmp2, regF vtmp1, regF vtmp2) %{
  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU);
  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
  effect(TEMP_DEF result, TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2);

  format %{ "String Compare byte[] $str1[len: $cnt1], $str2[len: $cnt2] tmp1:$tmp1, tmp2:$tmp2, vtmp1:$vtmp1, vtmp2:$vtmp2 -> $result @ string_compareLU" %}
  ins_encode %{
    __ string_compare($str1$$Register, $str2$$Register,
                      $cnt1$$Register, $cnt2$$Register, $result$$Register,
                      StrIntrinsicNode::LU, $tmp1$$Register, $tmp2$$Register,
                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister);
  %}

  ins_pipe( pipe_slow );
%}

instruct string_compareUL(a4_RegP str1, mA5RegI cnt1, a6_RegP str2, mA7RegI cnt2, mRegI result, mRegL tmp1, mRegL tmp2, regF vtmp1, regF vtmp2) %{
  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL);
  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
  effect(TEMP_DEF result, TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2);

  format %{ "String Compare byte[] $str1[len: $cnt1], $str2[len: $cnt2] tmp1:$tmp1, tmp2:$tmp2, vtmp1:$vtmp1, vtmp2:$vtmp2 -> $result @ string_compareUL" %}
  ins_encode %{
    __ string_compare($str1$$Register, $str2$$Register,
                      $cnt1$$Register, $cnt2$$Register, $result$$Register,
                      StrIntrinsicNode::UL, $tmp1$$Register, $tmp2$$Register,
                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister);
  %}

  ins_pipe( pipe_slow );
%}

instruct string_indexofUU(a4_RegP str1, mA5RegI cnt1, a6_RegP str2, mA7RegI cnt2,
                          mT8RegI result)
%{
  predicate(((StrIndexOfNode*)n)->encoding() == StrIntrinsicNode::UU);
  match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
  effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2);

  format %{ "String IndexOf $str1,$cnt1,$str2,$cnt2 -> $result (UU)" %}
  ins_encode %{
    __ string_indexof($str1$$Register, $str2$$Register,
                      $cnt1$$Register, $cnt2$$Register,
                      $result$$Register, StrIntrinsicNode::UU);
  %}
  ins_pipe( pipe_slow );
%}

instruct string_indexofLL(a4_RegP str1, mA5RegI cnt1, a6_RegP str2, mA7RegI cnt2,
                          mT8RegI result)
%{
  predicate(((StrIndexOfNode*)n)->encoding() == StrIntrinsicNode::LL);
  match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
  effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2);

  format %{ "String IndexOf $str1,$cnt1,$str2,$cnt2 -> $result (LL)" %}
  ins_encode %{
    __ string_indexof($str1$$Register, $str2$$Register,
                      $cnt1$$Register, $cnt2$$Register,
                      $result$$Register, StrIntrinsicNode::LL);
  %}
  ins_pipe( pipe_slow );
%}

instruct string_indexofUL(a4_RegP str1, mA5RegI cnt1, a6_RegP str2, mA7RegI cnt2,
                          mT8RegI result)
%{
  predicate(((StrIndexOfNode*)n)->encoding() == StrIntrinsicNode::UL);
  match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
  effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2);
  format %{ "String IndexOf $str1,$cnt1,$str2,$cnt2 -> $result (UL)" %}

  ins_encode %{
    __ string_indexof($str1$$Register, $str2$$Register,
                      $cnt1$$Register, $cnt2$$Register,
                      $result$$Register, StrIntrinsicNode::UL);
  %}
  ins_pipe( pipe_slow );
%}

instruct string_indexof_conUU(a4_RegP str1, mA5RegI cnt1, a6_RegP str2, immI_1_4 int_cnt2,
                              mT8RegI result)
%{
  predicate(((StrIndexOfNode*)n)->encoding() == StrIntrinsicNode::UU);
  match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
  effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt1);

  format %{ "String IndexOf $str1,$cnt1,$str2,$int_cnt2 -> $result (UU)" %}

  ins_encode %{
    int icnt2 = (int)$int_cnt2$$constant;
    __ string_indexof_linearscan($str1$$Register, $str2$$Register,
                                 $cnt1$$Register, noreg,
                                 icnt2, $result$$Register, StrIntrinsicNode::UU);
  %}
  ins_pipe( pipe_slow );
%}

instruct string_indexof_conLL(a4_RegP str1, mA5RegI cnt1, a6_RegP str2, immI_1_4 int_cnt2,
                              mT8RegI result)
%{
  predicate(((StrIndexOfNode*)n)->encoding() == StrIntrinsicNode::LL);
  match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
  effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt1);

  format %{ "String IndexOf $str1,$cnt1,$str2,$int_cnt2 -> $result (LL)" %}
  ins_encode %{
    int icnt2 = (int)$int_cnt2$$constant;
    __ string_indexof_linearscan($str1$$Register, $str2$$Register,
                                 $cnt1$$Register, noreg,
                                 icnt2, $result$$Register, StrIntrinsicNode::LL);
  %}
  ins_pipe( pipe_slow );
%}

instruct string_indexof_conUL(a4_RegP str1, mA5RegI cnt1, a6_RegP str2, immI_1 int_cnt2,
                              mT8RegI result)
%{
  predicate(((StrIndexOfNode*)n)->encoding() == StrIntrinsicNode::UL);
  match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
  effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt1);

  format %{ "String IndexOf $str1,$cnt1,$str2,$int_cnt2 -> $result (UL)" %}
  ins_encode %{
    int icnt2 = (int)$int_cnt2$$constant;
    __ string_indexof_linearscan($str1$$Register, $str2$$Register,
                                 $cnt1$$Register, noreg,
                                 icnt2, $result$$Register, StrIntrinsicNode::UL);
  %}
  ins_pipe( pipe_slow );
%}

instruct string_indexof_char(a4_RegP str1, mA5RegI cnt1, mA6RegI ch, mRegI result, mRegL tmp1, mRegL tmp2, mRegL tmp3) %{
  predicate(((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::U);
  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));
  effect(USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP_DEF result, TEMP tmp1, TEMP tmp2, TEMP tmp3);

  format %{ "StringUTF16 IndexOf char[] $str1, len:$cnt1, char:$ch, res:$result, tmp1:$tmp1, tmp2:$tmp2, tmp3:$tmp3 -> $result @ string_indexof_char" %}

  ins_encode %{
    __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register,
                           $result$$Register, $tmp1$$Register, $tmp2$$Register,
                           $tmp3$$Register);
  %}

  ins_pipe( pipe_slow );
%}

instruct stringL_indexof_char(a4_RegP str1, mA5RegI cnt1, mA6RegI ch, mRegI result, mRegL tmp1, mRegL tmp2, mRegL tmp3) %{
  predicate(((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::L);
  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));
  effect(USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP_DEF result, TEMP tmp1, TEMP tmp2, TEMP tmp3);

  format %{ "StringLatin1 IndexOf char[] $str1, len:$cnt1, char:$ch, res:$result, tmp1:$tmp1, tmp2:$tmp2, tmp3:$tmp3 -> $result @ stringL_indexof_char" %}

  ins_encode %{
    __ stringL_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register,
                            $result$$Register, $tmp1$$Register, $tmp2$$Register,
                            $tmp3$$Register);
  %}

  ins_pipe( pipe_slow );
%}

instruct count_positives(mRegP src, mRegI len, mRegI result,
                         mRegL tmp1, mRegL tmp2) %{
  match(Set result (CountPositives src len));
  effect(TEMP_DEF result, TEMP tmp1, TEMP tmp2);

  format %{ "count positives byte[] src:$src, len:$len -> $result TEMP($tmp1, $tmp2) @ count_positives" %}

  ins_encode %{
    __ count_positives($src$$Register, $len$$Register, $result$$Register,
                       $tmp1$$Register, $tmp2$$Register);
  %}

  ins_pipe( pipe_slow );
%}

// fast char[] to byte[] compression
instruct string_compress(a2_RegP src, mRegP dst, mRegI len, mRegI result,
                         mRegL tmp1, mRegL tmp2, mRegL tmp3,
                         regF vtemp1, regF vtemp2, regF vtemp3, regF vtemp4)
%{
  predicate(UseLSX);
  match(Set result (StrCompressedCopy src (Binary dst len)));
  effect(TEMP_DEF result, TEMP tmp1, TEMP tmp2, TEMP tmp3,
         TEMP vtemp1, TEMP vtemp2, TEMP vtemp3, TEMP vtemp4, USE_KILL src);

  format %{ "String Compress $src,$dst -> $result @ string_compress " %}

  ins_encode %{
    __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,
                           $result$$Register, $tmp1$$Register,
                           $tmp2$$Register, $tmp3$$Register,
                           $vtemp1$$FloatRegister, $vtemp2$$FloatRegister,
                           $vtemp3$$FloatRegister, $vtemp4$$FloatRegister);
  %}

  ins_pipe( pipe_slow );
%}

// byte[] to char[] inflation
instruct string_inflate(Universe dummy, a4_RegP src, a5_RegP dst, mA6RegI len,
                        mRegL tmp1, mRegL tmp2, regF vtemp1, regF vtemp2)
%{
  predicate(UseLSX);
  match(Set dummy (StrInflatedCopy src (Binary dst len)));
  effect(TEMP tmp1, TEMP tmp2, TEMP vtemp1, TEMP vtemp2,
         USE_KILL src, USE_KILL dst, USE_KILL len);

  format %{ "String Inflate $src, $dst, len:$len "
            "TEMP($tmp1, $tmp2, $vtemp1, $vtemp2) @ string_inflate " %}

  ins_encode %{
    __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,
                          $tmp1$$Register, $tmp2$$Register,
                          $vtemp1$$FloatRegister, $vtemp2$$FloatRegister);
  %}

  ins_pipe( pipe_slow );
%}

// intrinsic optimization
instruct string_equals(a4_RegP str1, a5_RegP str2, mA6RegI cnt, mRegI result, mRegL tmp1, mRegL tmp2) %{
  match(Set result (StrEquals (Binary str1 str2) cnt));
  effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt, TEMP_DEF result, TEMP tmp1, TEMP tmp2);

  format %{ "String Equal $str1, $str2, len:$cnt -> $result TEMP($tmp1, $tmp2) @ string_equals" %}
  ins_encode %{
    __ arrays_equals($str1$$Register, $str2$$Register,
                     $cnt$$Register, $tmp1$$Register, $tmp2$$Register, $result$$Register,
                     false/* is_char */, false/* is_array */);
  %}

  ins_pipe( pipe_slow );
%}

instruct array_equalsB(a4_RegP ary1, a5_RegP ary2, mRegI result, mRegL tmp0, mRegL tmp1, mRegL tmp2) %{
  predicate(((AryEqNode*)n)->encoding() == StrIntrinsicNode::LL);
  match(Set result (AryEq ary1 ary2));
  effect(USE_KILL ary1, USE_KILL ary2, TEMP_DEF result, TEMP tmp0, TEMP tmp1, TEMP tmp2);

  format %{ "Array Equals byte[] $ary1,$ary2 -> $result TEMP($tmp0, $tmp1, $tmp2) @ array_equalsB" %}
  ins_encode %{
    __ arrays_equals($ary1$$Register, $ary2$$Register,
                     $tmp0$$Register, $tmp1$$Register, $tmp2$$Register, $result$$Register,
                     false/* is_char */, true/* is_array */);
  %}

  ins_pipe( pipe_slow );
%}

instruct array_equalsC(a4_RegP ary1, a5_RegP ary2, mRegI result, mRegL tmp0, mRegL tmp1, mRegL tmp2) %{
  predicate(((AryEqNode*)n)->encoding() == StrIntrinsicNode::UU);
  match(Set result (AryEq ary1 ary2));
  effect(USE_KILL ary1, USE_KILL ary2, TEMP_DEF result, TEMP tmp0, TEMP tmp1, TEMP tmp2);

  format %{ "Array Equals char[] $ary1,$ary2 -> $result TEMP($tmp0, $tmp1, $tmp2) @ array_equalsC" %}
  ins_encode %{
    __ arrays_equals($ary1$$Register, $ary2$$Register,
                     $tmp0$$Register, $tmp1$$Register, $tmp2$$Register, $result$$Register,
                     true/* is_char */, true/* is_array */);
  %}

  ins_pipe( pipe_slow );
%}

// encode char[] to byte[] in ISO_8859_1
instruct encode_iso_array(a2_RegP src, mRegP dst, mRegI len, mRegI result,
                          mRegL tmp1, mRegL tmp2, mRegL tmp3,
                          regF vtemp1, regF vtemp2, regF vtemp3, regF vtemp4)
%{
  predicate(UseLSX && !((EncodeISOArrayNode*)n)->is_ascii());
  match(Set result (EncodeISOArray src (Binary dst len)));
  effect(TEMP_DEF result, TEMP tmp1, TEMP tmp2, TEMP tmp3,
         TEMP vtemp1, TEMP vtemp2, TEMP vtemp3, TEMP vtemp4, USE_KILL src);

  format %{ "Encode ISO array $src,$dst,$len -> $result @ encode_iso_array" %}

  ins_encode %{
    __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,
                        $result$$Register, $tmp1$$Register,
                        $tmp2$$Register, $tmp3$$Register, false,
                        $vtemp1$$FloatRegister, $vtemp2$$FloatRegister,
                        $vtemp3$$FloatRegister, $vtemp4$$FloatRegister);
  %}

  ins_pipe( pipe_slow );
%}

// encode char[] to byte[] in ASCII
instruct encode_ascii_array(a2_RegP src, mRegP dst, mRegI len, mRegI result,
                            mRegL tmp1, mRegL tmp2, mRegL tmp3,
                            regF vtemp1, regF vtemp2, regF vtemp3, regF vtemp4)
%{
  predicate(UseLSX && ((EncodeISOArrayNode*)n)->is_ascii());
  match(Set result (EncodeISOArray src (Binary dst len)));
  effect(TEMP_DEF result, TEMP tmp1, TEMP tmp2, TEMP tmp3,
         TEMP vtemp1, TEMP vtemp2, TEMP vtemp3, TEMP vtemp4, USE_KILL src);

  format %{ "Encode ASCII array $src,$dst,$len -> $result @ encode_ascii_array" %}

  ins_encode %{
    __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,
                        $result$$Register, $tmp1$$Register,
                        $tmp2$$Register, $tmp3$$Register, true,
                        $vtemp1$$FloatRegister, $vtemp2$$FloatRegister,
                        $vtemp3$$FloatRegister, $vtemp4$$FloatRegister);
  %}

  ins_pipe( pipe_slow );
%}

//----------Arithmetic Instructions-------------------------------------------
//----------Addition Instructions---------------------------------------------
instruct addI_Reg_Reg(mRegI dst, mRegIorL2I src1, mRegIorL2I src2) %{
  match(Set dst (AddI src1 src2));

  format %{ "add   $dst, $src1, $src2 #@addI_Reg_Reg" %}
  ins_encode %{
    Register  dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;
    __ add_w(dst, src1, src2);
  %}
  ins_pipe( ialu_reg_reg );
%}

instruct addI_Reg_imm(mRegI dst, mRegIorL2I src1,  immI12 src2) %{
  match(Set dst (AddI src1 src2));
  match(Set dst (AddI (CastII src1) src2));

  format %{ "add    $dst, $src1, $src2 #@addI_Reg_imm12" %}
  ins_encode %{
    Register  dst = $dst$$Register;
    Register src1 = $src1$$Register;
    int       imm = $src2$$constant;

    __ addi_w(dst, src1, imm);
  %}
  ins_pipe( ialu_reg_reg );
%}

instruct addI_salI_Reg_Reg_immI_1_4(mRegI dst, mRegI src1, mRegI src2, immI_1_4 shift) %{
  match(Set dst (AddI src1 (LShiftI src2 shift)));

  format %{ "alsl    $dst, $src1, $src2, $shift #@addI_salI_Reg_Reg_immI_1_4" %}
  ins_encode %{
    Register  dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;
    int        sh = $shift$$constant;
    __ alsl_w(dst, src2, src1, sh - 1);
  %}
  ins_pipe( ialu_reg_reg );
%}

instruct addP_reg_reg(mRegP dst, mRegP src1, mRegLorI2L src2) %{
  match(Set dst (AddP src1 src2));

  format %{ "ADD    $dst, $src1, $src2 #@addP_reg_reg" %}

  ins_encode %{
    Register  dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;
    __ add_d(dst, src1, src2);
  %}

  ins_pipe( ialu_reg_reg );
%}

instruct addP_reg_imm12(mRegP dst, mRegP src1,  immL12 src2) %{
  match(Set dst (AddP src1 src2));

  format %{ "ADD   $dst, $src1, $src2 #@addP_reg_imm12" %}
  ins_encode %{
    Register src1 = $src1$$Register;
    long     src2 = $src2$$constant;
    Register  dst = $dst$$Register;

    __ addi_d(dst, src1, src2);
  %}
  ins_pipe( ialu_reg_imm );
%}

instruct addP_salL_Reg_RegI2L_immI_1_4(mRegP dst, mRegP src1, mRegI src2, immI_1_4 shift) %{
  match(Set dst (AddP src1 (LShiftL (ConvI2L src2) shift)));

  format %{ "alsl    $dst, $src1, $src2, $shift #@addP_salL_Reg_RegI2L_immI_1_4" %}

  ins_encode %{
    Register  dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;
    int        sh = $shift$$constant;
    __ alsl_d(dst, src2, src1, sh - 1);
  %}

  ins_pipe( ialu_reg_reg );
%}

// Add Long Register with Register
instruct addL_Reg_Reg(mRegL dst, mRegLorI2L src1, mRegLorI2L src2) %{
  match(Set dst (AddL src1 src2));
  ins_cost(200);
  format %{ "ADD    $dst, $src1, $src2 #@addL_Reg_Reg\t" %}

  ins_encode %{
    Register dst_reg = as_Register($dst$$reg);
    Register src1_reg = as_Register($src1$$reg);
    Register src2_reg = as_Register($src2$$reg);

    __ add_d(dst_reg, src1_reg, src2_reg);
  %}

  ins_pipe( ialu_reg_reg );
%}

instruct addL_Reg_imm(mRegL dst, mRegLorI2L src1, immL12 src2)
%{
  match(Set dst (AddL src1 src2));

  format %{ "ADD    $dst, $src1, $src2 #@addL_Reg_imm " %}
  ins_encode %{
    Register dst_reg  = as_Register($dst$$reg);
    Register src1_reg = as_Register($src1$$reg);
    int      src2_imm = $src2$$constant;

    __ addi_d(dst_reg, src1_reg, src2_imm);
  %}

  ins_pipe( ialu_reg_imm );
%}

//----------Abs Instructions-------------------------------------------

// Integer Absolute Instructions
instruct absI_rReg(mRegI dst, mRegI src)
%{
  match(Set dst (AbsI src));
  effect(TEMP dst);
  format %{ "AbsI $dst, $src" %}
  ins_encode %{
    Register dst = $dst$$Register;
    Register src = $src$$Register;

    __ srai_w(AT, src, 31);
    __ xorr(dst, src, AT);
    __ sub_w(dst, dst, AT);
  %}

  ins_pipe( ialu_reg_imm );
%}

// Long Absolute Instructions
instruct absL_rReg(mRegL dst, mRegLorI2L src)
%{
  match(Set dst (AbsL src));
  effect(TEMP dst);
  format %{ "AbsL $dst, $src" %}
  ins_encode %{
    Register dst = $dst$$Register;
    Register src = $src$$Register;

    __ srai_d(AT, src, 63);
    __ xorr(dst, src, AT);
    __ sub_d(dst, dst, AT);
  %}

  ins_pipe( ialu_reg_reg );
%}

//----------Subtraction Instructions-------------------------------------------
// Integer Subtraction Instructions
instruct subI_Reg_Reg(mRegI dst, mRegIorL2I src1, mRegIorL2I src2) %{
  match(Set dst (SubI src1 src2));
  ins_cost(100);

  format %{ "sub    $dst, $src1, $src2 #@subI_Reg_Reg" %}
  ins_encode %{
    Register  dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;
    __ sub_w(dst, src1, src2);
  %}
  ins_pipe( ialu_reg_reg );
%}

instruct subI_Reg_immI_M2047_2048(mRegI dst, mRegIorL2I src1,  immI_M2047_2048 src2) %{
  match(Set dst (SubI src1 src2));
  ins_cost(80);

  format %{ "sub    $dst, $src1, $src2 #@subI_Reg_immI_M2047_2048" %}
  ins_encode %{
    Register  dst = $dst$$Register;
    Register src1 = $src1$$Register;
    __ addi_w(dst, src1, -1 * $src2$$constant);
  %}
  ins_pipe( ialu_reg_imm );
%}

instruct negI_Reg(mRegI dst, immI_0 zero,  mRegIorL2I src) %{
  match(Set dst (SubI zero src));
  ins_cost(80);

  format %{ "neg    $dst, $src #@negI_Reg" %}
  ins_encode %{
    Register  dst = $dst$$Register;
    Register  src = $src$$Register;
    __ sub_w(dst, R0, src);
  %}
  ins_pipe( ialu_reg_reg );
%}

instruct negL_Reg(mRegL dst, immL_0 zero,  mRegLorI2L src) %{
  match(Set dst (SubL zero src));
  ins_cost(80);

  format %{ "neg    $dst, $src #@negL_Reg" %}
  ins_encode %{
    Register  dst = $dst$$Register;
    Register  src = $src$$Register;
    __ sub_d(dst, R0, src);
  %}
  ins_pipe( ialu_reg_reg );
%}

instruct subL_Reg_immL_M2047_2048(mRegL dst, mRegL src1,  immL_M2047_2048 src2) %{
  match(Set dst (SubL src1 src2));
  ins_cost(80);

  format %{ "sub    $dst, $src1, $src2 #@subL_Reg_immL_M2047_2048" %}
  ins_encode %{
    Register  dst = $dst$$Register;
    Register src1 = $src1$$Register;
    __ addi_d(dst, src1, -1 * $src2$$constant);
  %}
  ins_pipe( ialu_reg_imm );
%}

// Subtract Long Register with Register.
instruct subL_Reg_Reg(mRegL dst, mRegLorI2L src1, mRegLorI2L src2) %{
  match(Set dst (SubL src1 src2));
  ins_cost(100);
  format %{ "SubL    $dst, $src1, $src2 @ subL_Reg_Reg" %}
  ins_encode %{
    Register dst  = as_Register($dst$$reg);
    Register src1 = as_Register($src1$$reg);
    Register src2 = as_Register($src2$$reg);

    __ sub_d(dst, src1, src2);
  %}
  ins_pipe( ialu_reg_reg );
%}

// Integer MOD with Register
instruct modI_Reg_Reg(mRegI dst, mRegIorL2I src1, mRegIorL2I src2) %{
  match(Set dst (ModI src1 src2));
  ins_cost(300);
  format %{ "modi   $dst, $src1, $src2 @ modI_Reg_Reg" %}
  ins_encode %{
    Register  dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;

    __ mod_w(dst, src1, src2);
  %}

  ins_pipe( ialu_div );
%}

instruct umodI_Reg_Reg(mRegI dst, mRegIorL2I src1, mRegIorL2I src2) %{
  match(Set dst (UModI src1 src2));
  format %{ "mod.wu   $dst, $src1, $src2 @ umodI_Reg_Reg" %}
  ins_encode %{
    Register  dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;

    __ mod_wu(dst, src1, src2);
  %}

  //ins_pipe( ialu_mod );
  ins_pipe( ialu_reg_reg );
%}

instruct umodL_Reg_Reg(mRegL dst, mRegLorI2L src1, mRegLorI2L src2) %{
  match(Set dst (UModL src1 src2));
  format %{ "mod.du   $dst, $src1, $src2 @ umodL_Reg_Reg" %}
  ins_encode %{
    Register  dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;

    __ mod_du(dst, src1, src2);
  %}

  //ins_pipe( ialu_mod );
  ins_pipe( ialu_reg_reg );
%}

instruct modL_reg_reg(mRegL dst, mRegLorI2L src1, mRegLorI2L src2) %{
  match(Set dst (ModL src1 src2));
  format %{ "modL  $dst, $src1, $src2 @modL_reg_reg" %}

  ins_encode %{
    Register dst = as_Register($dst$$reg);
    Register op1 = as_Register($src1$$reg);
    Register op2 = as_Register($src2$$reg);

    __ mod_d(dst, op1, op2);
  %}
  ins_pipe( ialu_reg_reg );
%}

instruct mulI_Reg_Reg(mRegI dst, mRegI src1, mRegI src2) %{
  match(Set dst (MulI src1 src2));

  ins_cost(300);
  format %{ "mul   $dst, $src1, $src2 @ mulI_Reg_Reg" %}
  ins_encode %{
     Register src1 = $src1$$Register;
     Register src2 = $src2$$Register;
     Register dst  = $dst$$Register;

     __ mul_w(dst, src1, src2);
  %}
  ins_pipe( ialu_mult );
%}

instruct divI_Reg_Reg(mRegI dst, mRegI src1, mRegI src2) %{
  match(Set dst (DivI src1 src2));

  ins_cost(300);
  format %{ "div   $dst, $src1, $src2 @ divI_Reg_Reg" %}
  ins_encode %{
     Register src1 = $src1$$Register;
     Register src2 = $src2$$Register;
     Register dst  = $dst$$Register;

    __ div_w(dst, src1, src2);

  %}
  ins_pipe( ialu_div );
%}

// =================== DivMod nodes ==========================
//
// Since we already have the `div` result here,
// combining the `mul` and the `sub` to calculate
// the remainder is more efficient than
// applying the `mod` instruction directly.
//
instruct divmodI_Reg_Reg(mT1RegI div, mT2RegI mod, mRegI src1, mRegI src2) %{
  match(DivModI src1 src2);
  effect(TEMP_DEF div, TEMP_DEF mod);

  format %{ "divmodI  $div..$mod, $src1, $src2 @ divmodI_Reg_Reg" %}

  ins_encode %{
     Register src1 = $src1$$Register;
     Register src2 = $src2$$Register;
     Register div  = $div$$Register;
     Register mod  = $mod$$Register;

    __ div_w(div, src1, src2);
    __ mul_w(mod, div, src2);
    __ sub_w(mod, src1, mod);
  %}

  ins_pipe( ialu_div );
%}

instruct udivmodI_Reg_Reg(mT1RegI div, mT2RegI mod, mRegI src1, mRegI src2) %{
  match(UDivModI src1 src2);
  effect(TEMP_DEF div, TEMP_DEF mod);

  format %{ "udivmodI  $div..$mod, $src1, $src2 @ udivmodI_Reg_Reg" %}

  ins_encode %{
     Register src1 = $src1$$Register;
     Register src2 = $src2$$Register;
     Register div  = $div$$Register;
     Register mod  = $mod$$Register;

    __ div_wu(div, src1, src2);
    __ mul_w(mod, div, src2);
    __ sub_w(mod, src1, mod);
  %}

  ins_pipe( ialu_div );
%}

instruct divmodL_Reg_Reg(t1RegL div, t2RegL mod, mRegL src1, mRegL src2) %{
  match(DivModL src1 src2);
  effect(TEMP_DEF div, TEMP_DEF mod);

  format %{ "divmodL  $div..$mod, $src1, $src2 @ divmodL_Reg_Reg" %}

  ins_encode %{
     Register src1 = $src1$$Register;
     Register src2 = $src2$$Register;
     Register div  = $div$$Register;
     Register mod  = $mod$$Register;

    __ div_d(div, src1, src2);
    __ mul_d(mod, div, src2);
    __ sub_d(mod, src1, mod);
  %}

  ins_pipe( ialu_div );
%}

instruct udivmodL_Reg_Reg(t1RegL div, t2RegL mod, mRegL src1, mRegL src2) %{
  match(UDivModL src1 src2);
  effect(TEMP_DEF div, TEMP_DEF mod);

  format %{ "udivmodL $div..$mod, $src1, $src2 @ udivmodL_Reg_Reg" %}

  ins_encode %{
     Register src1 = $src1$$Register;
     Register src2 = $src2$$Register;
     Register div  = $div$$Register;
     Register mod  = $mod$$Register;

    __ div_du(div, src1, src2);
    __ mul_d(mod, div, src2);
    __ sub_d(mod, src1, mod);
  %}

  ins_pipe( ialu_div );
%}

// =================== End of DivMod nodes ==========================

instruct udivI_Reg_Reg(mRegI dst, mRegI src1, mRegI src2) %{
  match(Set dst (UDivI src1 src2));

  format %{ "udivI   $dst, $src1, $src2 @ udivI_Reg_Reg" %}
  ins_encode %{
     Register src1 = $src1$$Register;
     Register src2 = $src2$$Register;
     Register dst  = $dst$$Register;

    __ div_wu(dst, src1, src2);

  %}
  ins_pipe( ialu_div );
%}

instruct divF_Reg_Reg(regF dst, regF src1, regF src2) %{
  match(Set dst (DivF src1 src2));

  ins_cost(300);
  format %{ "divF   $dst, $src1, $src2 @ divF_Reg_Reg" %}
  ins_encode %{
     FloatRegister src1 = $src1$$FloatRegister;
     FloatRegister src2 = $src2$$FloatRegister;
     FloatRegister dst  = $dst$$FloatRegister;

    __ fdiv_s(dst, src1, src2);
  %}
  ins_pipe( fpu_div );
%}

instruct divD_Reg_Reg(regD dst, regD src1, regD src2) %{
  match(Set dst (DivD src1 src2));

  ins_cost(300);
  format %{ "divD   $dst, $src1, $src2 @ divD_Reg_Reg" %}
  ins_encode %{
     FloatRegister src1 = $src1$$FloatRegister;
     FloatRegister src2 = $src2$$FloatRegister;
     FloatRegister dst  = $dst$$FloatRegister;

    __ fdiv_d(dst, src1, src2);
  %}
  ins_pipe( fpu_div );
%}

instruct mulL_reg_reg(mRegL dst, mRegLorI2L src1, mRegLorI2L src2) %{
  match(Set dst (MulL src1 src2));
  format %{ "mulL  $dst, $src1, $src2 @mulL_reg_reg" %}
  ins_encode %{
    Register dst = as_Register($dst$$reg);
    Register op1 = as_Register($src1$$reg);
    Register op2 = as_Register($src2$$reg);

    __ mul_d(dst, op1, op2);
  %}
  ins_pipe( fpu_arith );
%}

instruct mulHiL_reg_reg(mRegL dst, mRegL src1, mRegL src2) %{
  match(Set dst (MulHiL src1 src2));
  format %{ "mulHiL  $dst, $src1, $src2 @mulL_reg_reg" %}
  ins_encode %{
    Register dst = as_Register($dst$$reg);
    Register op1 = as_Register($src1$$reg);
    Register op2 = as_Register($src2$$reg);

    __ mulh_d(dst, op1, op2);
  %}
  ins_pipe( fpu_arith);
%}

instruct umulHiL_reg_reg(mRegL dst, mRegL src1, mRegL src2) %{
  match(Set dst (UMulHiL src1 src2));
  format %{ "mulh.du  $dst, $src1, $src2 @umulHiL_reg_reg" %}

  ins_encode %{
    __ mulh_du($dst$$Register, $src1$$Register, $src2$$Register);
  %}
  ins_pipe( ialu_mult );
%}

instruct divL_reg_reg(mRegL dst, mRegL src1, mRegL src2) %{
  match(Set dst (DivL src1 src2));
  format %{ "divL  $dst, $src1, $src2 @divL_reg_reg" %}

  ins_encode %{
    Register dst = as_Register($dst$$reg);
    Register op1 = as_Register($src1$$reg);
    Register op2 = as_Register($src2$$reg);

    __ div_d(dst, op1, op2);
  %}
  ins_pipe( ialu_div );
%}

instruct udivL_reg_reg(mRegL dst, mRegLorI2L src1, mRegLorI2L src2) %{
  match(Set dst (UDivL src1 src2));
  format %{ "udivL  $dst, $src1, $src2 @udivL_reg_reg" %}

  ins_encode %{
    Register dst = as_Register($dst$$reg);
    Register op1 = as_Register($src1$$reg);
    Register op2 = as_Register($src2$$reg);

    __ div_du(dst, op1, op2);
  %}
  ins_pipe( ialu_div );
%}

instruct addF_reg_reg(regF dst, regF src1, regF src2) %{
  match(Set dst (AddF src1 src2));
  format %{ "AddF  $dst, $src1, $src2 @addF_reg_reg" %}
  ins_encode %{
    FloatRegister src1 = as_FloatRegister($src1$$reg);
    FloatRegister src2 = as_FloatRegister($src2$$reg);
    FloatRegister dst  = as_FloatRegister($dst$$reg);

    __ fadd_s(dst, src1, src2);
  %}
  ins_pipe( fpu_arith);
%}

instruct subF_reg_reg(regF dst, regF src1, regF src2) %{
  match(Set dst (SubF src1 src2));
  format %{ "SubF  $dst, $src1, $src2 @subF_reg_reg" %}
  ins_encode %{
    FloatRegister src1 = as_FloatRegister($src1$$reg);
    FloatRegister src2 = as_FloatRegister($src2$$reg);
    FloatRegister dst  = as_FloatRegister($dst$$reg);

    __ fsub_s(dst, src1, src2);
  %}
  ins_pipe( fpu_arith );
%}
instruct addD_reg_reg(regD dst, regD src1, regD src2) %{
  match(Set dst (AddD src1 src2));
  format %{ "AddD  $dst, $src1, $src2 @addD_reg_reg" %}
  ins_encode %{
    FloatRegister src1 = as_FloatRegister($src1$$reg);
    FloatRegister src2 = as_FloatRegister($src2$$reg);
    FloatRegister dst  = as_FloatRegister($dst$$reg);

    __ fadd_d(dst, src1, src2);
  %}
  ins_pipe( fpu_arith );
%}

instruct subD_reg_reg(regD dst, regD src1, regD src2) %{
  match(Set dst (SubD src1 src2));
  format %{ "SubD  $dst, $src1, $src2 @subD_reg_reg" %}
  ins_encode %{
    FloatRegister src1 = as_FloatRegister($src1$$reg);
    FloatRegister src2 = as_FloatRegister($src2$$reg);
    FloatRegister dst  = as_FloatRegister($dst$$reg);

    __ fsub_d(dst, src1, src2);
  %}
  ins_pipe( fpu_arith );
%}

instruct negF_reg(regF dst, regF src) %{
  match(Set dst (NegF src));
  format %{ "negF  $dst, $src @negF_reg" %}
  ins_encode %{
    FloatRegister src = as_FloatRegister($src$$reg);
    FloatRegister dst = as_FloatRegister($dst$$reg);

    __ fneg_s(dst, src);
  %}
  ins_pipe( fpu_absnegmov );
%}

instruct negD_reg(regD dst, regD src) %{
  match(Set dst (NegD src));
  format %{ "negD  $dst, $src @negD_reg" %}
  ins_encode %{
    FloatRegister src = as_FloatRegister($src$$reg);
    FloatRegister dst = as_FloatRegister($dst$$reg);

    __ fneg_d(dst, src);
  %}
  ins_pipe( fpu_absnegmov );
%}


instruct mulF_reg_reg(regF dst, regF src1, regF src2) %{
  match(Set dst (MulF src1 src2));
  format %{ "MULF  $dst, $src1, $src2 @mulF_reg_reg" %}
  ins_encode %{
    FloatRegister src1 = $src1$$FloatRegister;
    FloatRegister src2 = $src2$$FloatRegister;
    FloatRegister dst  = $dst$$FloatRegister;

    __ fmul_s(dst, src1, src2);
  %}
  ins_pipe( fpu_arith );
%}

// Mul two double precision floating point number
instruct mulD_reg_reg(regD dst, regD src1, regD src2) %{
  match(Set dst (MulD src1 src2));
  format %{ "MULD  $dst, $src1, $src2 @mulD_reg_reg" %}
  ins_encode %{
    FloatRegister src1 = $src1$$FloatRegister;
    FloatRegister src2 = $src2$$FloatRegister;
    FloatRegister dst  = $dst$$FloatRegister;

    __ fmul_d(dst, src1, src2);
  %}
  ins_pipe( fpu_arith );
%}

instruct absF_reg(regF dst, regF src) %{
  match(Set dst (AbsF src));
  ins_cost(100);
  format %{ "absF  $dst, $src @absF_reg" %}
  ins_encode %{
    FloatRegister src = as_FloatRegister($src$$reg);
    FloatRegister dst = as_FloatRegister($dst$$reg);

    __ fabs_s(dst, src);
  %}
  ins_pipe( fpu_absnegmov );
%}


// intrinsics for math_native.
// AbsD  SqrtD  CosD  SinD  TanD  LogD  Log10D

instruct absD_reg(regD dst, regD src) %{
  match(Set dst (AbsD src));
  ins_cost(100);
  format %{ "absD  $dst, $src @absD_reg" %}
  ins_encode %{
    FloatRegister src = as_FloatRegister($src$$reg);
    FloatRegister dst = as_FloatRegister($dst$$reg);

    __ fabs_d(dst, src);
  %}
  ins_pipe( fpu_absnegmov );
%}

instruct sqrtD_reg(regD dst, regD src) %{
  match(Set dst (SqrtD src));
  ins_cost(100);
  format %{ "SqrtD  $dst, $src @sqrtD_reg" %}
  ins_encode %{
    FloatRegister src = as_FloatRegister($src$$reg);
    FloatRegister dst = as_FloatRegister($dst$$reg);

    __ fsqrt_d(dst, src);
  %}
  ins_pipe( fpu_div );
%}

instruct sqrtF_reg(regF dst, regF src) %{
  match(Set dst (ConvD2F (SqrtD (ConvF2D src))));
  ins_cost(100);
  format %{ "SqrtF  $dst, $src @sqrtF_reg" %}
  ins_encode %{
    FloatRegister src = as_FloatRegister($src$$reg);
    FloatRegister dst = as_FloatRegister($dst$$reg);

    __ fsqrt_s(dst, src);
  %}
  ins_pipe( fpu_div );
%}

// src1 * src2 + src3
instruct maddF_reg_reg(regF dst, regF src1, regF src2, regF src3) %{
  predicate(UseFMA);
  match(Set dst (FmaF src3 (Binary src1 src2)));

  format %{ "fmadd_s  $dst, $src1, $src2, $src3" %}

  ins_encode %{
    __ fmadd_s(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg),
               as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));
  %}

  ins_pipe( fpu_arith3 );
%}

// src1 * src2 + src3
instruct maddD_reg_reg(regD dst, regD src1, regD src2, regD src3) %{
  predicate(UseFMA);
  match(Set dst (FmaD src3 (Binary src1 src2)));

  format %{ "fmadd_d  $dst, $src1, $src2, $src3" %}

  ins_encode %{
    __ fmadd_d(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg),
               as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));
  %}

  ins_pipe( fpu_arith3 );
%}

// src1 * src2 - src3
instruct msubF_reg_reg(regF dst, regF src1, regF src2, regF src3, immF_0 zero) %{
  predicate(UseFMA);
  match(Set dst (FmaF (NegF src3) (Binary src1 src2)));

  format %{ "fmsub_s $dst, $src1, $src2, $src3" %}

  ins_encode %{
    __ fmsub_s(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg),
               as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));
  %}

  ins_pipe( fpu_arith3 );
%}

// src1 * src2 - src3
instruct msubD_reg_reg(regD dst, regD src1, regD src2, regD src3, immD_0 zero) %{
  predicate(UseFMA);
  match(Set dst (FmaD (NegD src3) (Binary src1 src2)));

  format %{ "fmsub_d  $dst, $src1, $src2, $src3" %}

  ins_encode %{
    __ fmsub_d(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg),
               as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));
  %}

  ins_pipe( fpu_arith3 );
%}

// -src1 * src2 - src3
instruct mnaddF_reg_reg(regF dst, regF src1, regF src2, regF src3, immF_0 zero) %{
  predicate(UseFMA);
  match(Set dst (FmaF (NegF src3) (Binary (NegF src1) src2)));
  match(Set dst (FmaF (NegF src3) (Binary src1 (NegF src2))));

  format %{ "fnmadds  $dst, $src1, $src2, $src3" %}

  ins_encode %{
    __ fnmadd_s(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg),
                as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));
  %}

  ins_pipe( fpu_arith3 );
%}

// -src1 * src2 - src3
instruct mnaddD_reg_reg(regD dst, regD src1, regD src2, regD src3, immD_0 zero) %{
  predicate(UseFMA);
  match(Set dst (FmaD (NegD src3) (Binary (NegD src1) src2)));
  match(Set dst (FmaD (NegD src3) (Binary src1 (NegD src2))));

  format %{ "fnmaddd   $dst, $src1, $src2, $src3" %}

  ins_encode %{
    __ fnmadd_d(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg),
                as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));
  %}

  ins_pipe( fpu_arith3 );
%}

// -src1 * src2 + src3
instruct mnsubF_reg_reg(regF dst, regF src1, regF src2, regF src3) %{
  predicate(UseFMA);
  match(Set dst (FmaF src3 (Binary (NegF src1) src2)));
  match(Set dst (FmaF src3 (Binary src1 (NegF src2))));

  format %{ "fnmsubs  $dst, $src1, $src2, $src3" %}

  ins_encode %{
    __ fnmsub_s(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg),
                as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));
  %}

  ins_pipe( fpu_arith3 );
%}

// -src1 * src2 + src3
instruct mnsubD_reg_reg(regD dst, regD src1, regD src2, regD src3) %{
  predicate(UseFMA);
  match(Set dst (FmaD src3 (Binary (NegD src1) src2)));
  match(Set dst (FmaD src3 (Binary src1 (NegD src2))));

  format %{ "fnmsubd   $dst, $src1, $src2, $src3" %}

  ins_encode %{
    __ fnmsub_d(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg),
                as_FloatRegister($src2$$reg), as_FloatRegister($src3$$reg));
  %}

  ins_pipe( fpu_arith3 );
%}

instruct copySignF_reg(regF dst, regF src1, regF src2) %{
  match(Set dst (CopySignF src1 src2));
  effect(TEMP_DEF dst, USE src1, USE src2);

  format %{ "fcopysign_s  $dst $src1 $src2 @ copySignF_reg" %}

  ins_encode %{
    __ fcopysign_s($dst$$FloatRegister,
                   $src1$$FloatRegister,
                   $src2$$FloatRegister);
  %}

  ins_pipe( fpu_arith );
%}

instruct copySignD_reg(regD dst, regD src1, regD src2, immD_0 zero) %{
  match(Set dst (CopySignD src1 (Binary src2 zero)));
  effect(TEMP_DEF dst, USE src1, USE src2);

  format %{ "fcopysign_d  $dst $src1 $src2 @ copySignD_reg" %}

  ins_encode %{
    __ fcopysign_d($dst$$FloatRegister,
                   $src1$$FloatRegister,
                   $src2$$FloatRegister);
  %}

  ins_pipe( fpu_arith );
%}

instruct signumF_reg(regF dst, regF src, regF zero, regF one, regF tmp) %{
  match(Set dst (SignumF src (Binary zero one)));
  effect(TEMP_DEF dst, TEMP tmp);
  format %{ "signumF    $dst, $src, $zero, $one\t# TEMP($tmp) @signumF_reg" %}
  ins_encode %{
    __ fcmp_clt_s(FCC0, $zero$$FloatRegister, $src$$FloatRegister);
    __ fsel($dst$$FloatRegister, $src$$FloatRegister, $one$$FloatRegister, FCC0);
    __ fcmp_clt_s(FCC0, $src$$FloatRegister, $zero$$FloatRegister);
    __ fneg_s($tmp$$FloatRegister, $one$$FloatRegister);
    __ fsel($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister, FCC0);
  %}
  ins_pipe( pipe_slow );
%}

instruct signumD_reg(regD dst, regD src, regD zero, regD one, regD tmp) %{
  match(Set dst (SignumD src (Binary zero one)));
  effect(TEMP_DEF dst, TEMP tmp);
  format %{ "signumF    $dst, $src, $zero, $one\t# TEMP($tmp) @signumD_reg" %}
  ins_encode %{
    __ fcmp_clt_d(FCC0, $zero$$FloatRegister, $src$$FloatRegister);
    __ fsel($dst$$FloatRegister, $src$$FloatRegister, $one$$FloatRegister, FCC0);
    __ fcmp_clt_d(FCC0, $src$$FloatRegister, $zero$$FloatRegister);
    __ fneg_d($tmp$$FloatRegister, $one$$FloatRegister);
    __ fsel($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister, FCC0);
  %}
  ins_pipe( pipe_slow );
%}

//----------------------------------Logical Instructions----------------------
//__________________________________Integer Logical Instructions-------------

//And Instuctions
// And Register with Immediate
instruct andI_Reg_imm_0_4095(mRegI dst, mRegI src1,  immI_0_4095 src2) %{
  match(Set dst (AndI src1 src2));
  ins_cost(60);

  format %{ "and  $dst, $src1, $src2 #@andI_Reg_imm_0_4095" %}
  ins_encode %{
    Register dst = $dst$$Register;
    Register src = $src1$$Register;
    int      val = $src2$$constant;

    __ andi(dst, src, val);

  %}
  ins_pipe( ialu_reg_imm );
%}

instruct andI_Reg_immI_nonneg_mask(mRegI dst, mRegI src1,  immI_nonneg_mask mask) %{
  match(Set dst (AndI src1 mask));
  ins_cost(60);

  format %{ "and  $dst, $src1, $mask #@andI_Reg_immI_nonneg_mask" %}
  ins_encode %{
    Register dst = $dst$$Register;
    Register src = $src1$$Register;
    int      val = $mask$$constant;
    int     size = Assembler::count_trailing_ones(val);

    __ bstrpick_w(dst, src, size-1, 0);
  %}
  ins_pipe( ialu_reg_imm );
%}

instruct andL_Reg_immL_nonneg_mask(mRegL dst, mRegL src1,  immL_nonneg_mask mask) %{
  match(Set dst (AndL src1 mask));
  ins_cost(60);

  format %{ "and  $dst, $src1, $mask #@andL_Reg_immL_nonneg_mask" %}
  ins_encode %{
    Register dst = $dst$$Register;
    Register src = $src1$$Register;
    long    val = $mask$$constant;
    int     size = Assembler::count_trailing_ones(val);

    __ bstrpick_d(dst, src, size-1, 0);
  %}
  ins_pipe( ialu_reg_imm );
%}

instruct xorI_Reg_imm_0_4095(mRegI dst, mRegI src1,  immI_0_4095 src2) %{
  match(Set dst (XorI src1 src2));
  ins_cost(60);

  format %{ "xori  $dst, $src1, $src2 #@xorI_Reg_imm_0_4095" %}
  ins_encode %{
    Register dst = $dst$$Register;
    Register src = $src1$$Register;
    int      val = $src2$$constant;

       __ xori(dst, src, val);
  %}
  ins_pipe( ialu_reg_imm );
%}

instruct xorI_Reg_immI_M1(mRegI dst, mRegIorL2I src1,  immI_M1 M1) %{
  match(Set dst (XorI src1 M1));
  ins_cost(60);

  format %{ "xor  $dst, $src1, $M1 #@xorI_Reg_immI_M1" %}
  ins_encode %{
    Register dst = $dst$$Register;
    Register src = $src1$$Register;

    __ orn(dst, R0, src);
  %}
  ins_pipe( ialu_reg_reg );
%}

instruct xorL_Reg_imm_0_4095(mRegL dst, mRegL src1,  immL_0_4095 src2) %{
  match(Set dst (XorL src1 src2));
  ins_cost(60);

  format %{ "xori  $dst, $src1, $src2 #@xorL_Reg_imm_0_4095" %}
  ins_encode %{
    Register dst = $dst$$Register;
    Register src = $src1$$Register;
    int      val = $src2$$constant;

    __ xori(dst, src, val);
  %}
  ins_pipe( ialu_reg_imm );
%}

instruct andI_Reg_Reg(mRegI dst, mRegI src1,  mRegI src2) %{
  match(Set dst (AndI src1 src2));

  format %{ "and    $dst, $src1, $src2 #@andI_Reg_Reg" %}
  ins_encode %{
    Register dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;

    __ andr(dst, src1, src2);
  %}
  ins_pipe( ialu_reg_reg );
%}

instruct andnI_Reg_nReg(mRegI dst, mRegI src1,  mRegI src2, immI_M1 M1) %{
  match(Set dst (AndI src1 (XorI src2 M1)));

  format %{ "andn   $dst, $src1, $src2 #@andnI_Reg_nReg" %}
  ins_encode %{
    Register dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;

    __ andn(dst, src1, src2);
  %}
  ins_pipe( ialu_reg_reg );
%}

instruct ornI_Reg_nReg(mRegI dst, mRegI src1,  mRegI src2, immI_M1 M1) %{
  match(Set dst (OrI src1 (XorI src2 M1)));

  format %{ "orn    $dst, $src1, $src2 #@ornI_Reg_nReg" %}
  ins_encode %{
    Register dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;

    __ orn(dst, src1, src2);
  %}
  ins_pipe( ialu_reg_reg );
%}

instruct ornI_nReg_Reg(mRegI dst, mRegI src1,  mRegI src2, immI_M1 M1) %{
  match(Set dst (OrI (XorI src1 M1) src2));

  format %{ "orn    $dst, $src2, $src1 #@ornI_nReg_Reg" %}
  ins_encode %{
    Register dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;

    __ orn(dst, src2, src1);
  %}
  ins_pipe( ialu_reg_reg );
%}

// And Long Register with Register
instruct andL_Reg_Reg(mRegL dst, mRegL src1, mRegLorI2L src2) %{
  match(Set dst (AndL src1 src2));
  format %{ "AND    $dst, $src1, $src2 @ andL_Reg_Reg\n\t" %}
  ins_encode %{
    Register dst_reg = as_Register($dst$$reg);
    Register src1_reg = as_Register($src1$$reg);
    Register src2_reg = as_Register($src2$$reg);

    __ andr(dst_reg, src1_reg, src2_reg);
  %}
  ins_pipe( ialu_reg_reg );
%}

instruct andL_Reg_imm_0_4095(mRegL dst, mRegL src1,  immL_0_4095 src2) %{
  match(Set dst (AndL src1 src2));
  ins_cost(60);

  format %{ "and  $dst, $src1, $src2 #@andL_Reg_imm_0_4095" %}
  ins_encode %{
    Register dst = $dst$$Register;
    Register src = $src1$$Register;
    long     val = $src2$$constant;

    __ andi(dst, src, val);
  %}
  ins_pipe( ialu_reg_imm );
%}

instruct andL2I_Reg_imm_0_4095(mRegI dst, mRegL src1,  immL_0_4095 src2) %{
  match(Set dst (ConvL2I (AndL src1 src2)));
  ins_cost(60);

  format %{ "and  $dst, $src1, $src2 #@andL2I_Reg_imm_0_4095" %}
  ins_encode %{
    Register dst = $dst$$Register;
    Register src = $src1$$Register;
    long     val = $src2$$constant;

    __ andi(dst, src, val);
  %}
  ins_pipe( ialu_reg_imm );
%}

instruct andI_Reg_immI_zeroins_mask(mRegI dst,  immI_zeroins_mask mask) %{
  match(Set dst (AndI dst mask));
  ins_cost(60);

  format %{ "and  $dst, $dst, $mask #@andI_Reg_immI_zeroins_mask" %}
  ins_encode %{
    Register dst = $dst$$Register;
    int      val = $mask$$constant;
    int      msb = 31 - Assembler::count_leading_ones(val);
    int      lsb = Assembler::count_trailing_ones(val);

    __ bstrins_w(dst, R0, msb, lsb);
  %}
  ins_pipe( ialu_reg_imm );
%}

instruct andL_Reg_immL_zeroins_mask(mRegL dst,  immL_zeroins_mask mask) %{
  match(Set dst (AndL dst mask));
  ins_cost(60);

  format %{ "and  $dst, $dst, $mask #@andL_Reg_immL_zeroins_mask" %}
  ins_encode %{
    Register dst = $dst$$Register;
    long     val = $mask$$constant;
    int      msb = 63 - Assembler::count_leading_ones(val);
    int      lsb = Assembler::count_trailing_ones(val);

    __ bstrins_d(dst, R0, msb, lsb);
  %}
  ins_pipe( ialu_reg_imm );
%}

// Or Long Register with Register
instruct orL_Reg_Reg(mRegL dst, mRegLorI2L src1, mRegLorI2L src2) %{
  match(Set dst (OrL src1 src2));
  format %{ "OR    $dst, $src1, $src2 @ orL_Reg_Reg\t" %}
  ins_encode %{
    Register dst_reg  = $dst$$Register;
    Register src1_reg = $src1$$Register;
    Register src2_reg = $src2$$Register;

    __ orr(dst_reg, src1_reg, src2_reg);
  %}
  ins_pipe( ialu_reg_reg );
%}

instruct orL_Reg_P2XReg(mRegL dst, mRegP src1, mRegLorI2L src2) %{
  match(Set dst (OrL (CastP2X src1) src2));
  format %{ "OR    $dst, $src1, $src2 @ orL_Reg_P2XReg\t" %}
  ins_encode %{
    Register dst_reg  = $dst$$Register;
    Register src1_reg = $src1$$Register;
    Register src2_reg = $src2$$Register;

    __ orr(dst_reg, src1_reg, src2_reg);
  %}
  ins_pipe( ialu_reg_reg );
%}

// Xor Long Register with Register

instruct xorL_Reg_Reg(mRegL dst, mRegLorI2L src1, mRegLorI2L src2) %{
  match(Set dst (XorL src1 src2));
  format %{ "XOR    $dst, $src1, $src2 @ xorL_Reg_Reg\t" %}
  ins_encode %{
    Register dst_reg = as_Register($dst$$reg);
    Register src1_reg = as_Register($src1$$reg);
    Register src2_reg = as_Register($src2$$reg);

    __ xorr(dst_reg, src1_reg, src2_reg);
  %}
  ins_pipe( ialu_reg_reg );
%}

instruct xorL_Reg_P2XReg(mRegL dst, mRegP src1, mRegLorI2L src2) %{
  match(Set dst (XorL (CastP2X src1) src2));
  format %{ "XOR    $dst, $src1, $src2 @ xorL_Reg_P2XReg\t" %}
  ins_encode %{
    __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
  %}
  ins_pipe( ialu_reg_reg );
%}

// Shift Left by 5-bit immediate
instruct salI_Reg_imm(mRegI dst, mRegIorL2I src, immIU5 shift) %{
  match(Set dst (LShiftI src shift));

  format %{ "SHL    $dst, $src, $shift #@salI_Reg_imm" %}
  ins_encode %{
    Register src = $src$$Register;
    Register dst = $dst$$Register;
    int    shamt = $shift$$constant;

    __ slli_w(dst, src, shamt);
  %}
  ins_pipe( ialu_reg_imm );
%}

instruct salI_Reg_imm_and_M65536(mRegI dst, mRegI src, immI_16 shift, immI_M65536 mask) %{
  match(Set dst (AndI (LShiftI src shift) mask));

  format %{ "SHL    $dst, $src, $shift #@salI_Reg_imm_and_M65536" %}
  ins_encode %{
    Register src = $src$$Register;
    Register dst = $dst$$Register;

    __ slli_w(dst, src, 16);
  %}
  ins_pipe( ialu_reg_imm );
%}

// Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.
// This idiom is used by the compiler the i2s bytecode.
instruct i2s(mRegI dst, mRegI src, immI_16 sixteen)
%{
  match(Set dst (RShiftI (LShiftI src sixteen) sixteen));

  format %{ "i2s  $dst, $src\t# @i2s" %}
  ins_encode %{
    Register src = $src$$Register;
    Register dst = $dst$$Register;

    __ ext_w_h(dst, src);
  %}
  ins_pipe( ialu_reg_reg );
%}

// Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.
// This idiom is used by the compiler for the i2b bytecode.
instruct i2b(mRegI dst, mRegI src, immI_24 twentyfour)
%{
  match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));

  format %{ "i2b  $dst, $src\t# @i2b" %}
  ins_encode %{
    Register src = $src$$Register;
    Register dst = $dst$$Register;

    __ ext_w_b(dst, src);
  %}
  ins_pipe( ialu_reg_reg );
%}


instruct salI_RegL2I_imm(mRegI dst, mRegL src, immIU5 shift) %{
  match(Set dst (LShiftI (ConvL2I src) shift));

  format %{ "SHL    $dst, $src, $shift #@salI_RegL2I_imm" %}
  ins_encode %{
    Register src = $src$$Register;
    Register dst = $dst$$Register;
    int    shamt = $shift$$constant;

    __ slli_w(dst, src, shamt);
  %}
  ins_pipe( ialu_reg_imm );
%}

// Shift Left by 8-bit immediate
instruct salI_Reg_Reg(mRegI dst, mRegIorL2I src, mRegI shift) %{
  match(Set dst (LShiftI src shift));

  format %{ "SHL    $dst, $src, $shift #@salI_Reg_Reg" %}
  ins_encode %{
    Register src = $src$$Register;
    Register dst = $dst$$Register;
    Register shamt = $shift$$Register;
    __ sll_w(dst, src, shamt);
  %}
  ins_pipe( ialu_reg_reg );
%}


// Shift Left Long 6-bit immI
instruct salL_Reg_imm(mRegL dst, mRegLorI2L src, immIU6 shift) %{
  match(Set dst (LShiftL src shift));
  ins_cost(100);
  format %{ "salL    $dst, $src, $shift @ salL_Reg_imm" %}
  ins_encode %{
    Register src_reg = as_Register($src$$reg);
    Register dst_reg = as_Register($dst$$reg);
    int      shamt = $shift$$constant;

    __ slli_d(dst_reg, src_reg, shamt);
  %}
  ins_pipe( ialu_reg_imm );
%}

// Shift Left Long
instruct salL_Reg_Reg(mRegL dst, mRegLorI2L src, mRegI shift) %{
  match(Set dst (LShiftL src shift));
  ins_cost(100);
  format %{ "salL    $dst, $src, $shift @ salL_Reg_Reg" %}
  ins_encode %{
    Register src_reg = as_Register($src$$reg);
    Register dst_reg = as_Register($dst$$reg);

    __ sll_d(dst_reg, src_reg, $shift$$Register);
  %}
  ins_pipe( ialu_reg_reg );
%}

// Shift Right Long 6-bit
instruct sarL_Reg_imm(mRegL dst, mRegLorI2L src, immIU6 shift) %{
  match(Set dst (RShiftL src shift));
  ins_cost(100);
  format %{ "sarL    $dst, $src, $shift @ sarL_Reg_imm" %}
  ins_encode %{
    Register src_reg = as_Register($src$$reg);
    Register dst_reg = as_Register($dst$$reg);
    int      shamt = $shift$$constant;

    __ srai_d(dst_reg, src_reg, shamt);
  %}
  ins_pipe( ialu_reg_imm );
%}

instruct sarL2I_Reg_immI_32_63(mRegI dst, mRegLorI2L src, immI_32_63 shift) %{
  match(Set dst (ConvL2I (RShiftL src shift)));
  ins_cost(100);
  format %{ "sarL    $dst, $src, $shift @ sarL2I_Reg_immI_32_63" %}
  ins_encode %{
    Register src_reg = as_Register($src$$reg);
    Register dst_reg = as_Register($dst$$reg);
    int      shamt   = $shift$$constant;

    __ srai_d(dst_reg, src_reg, shamt);
  %}
  ins_pipe( ialu_reg_imm );
%}

// Shift Right Long arithmetically
instruct sarL_Reg_Reg(mRegL dst, mRegLorI2L src, mRegI shift) %{
  match(Set dst (RShiftL src shift));
  ins_cost(100);
  format %{ "sarL    $dst, $src, $shift @ sarL_Reg_Reg" %}
  ins_encode %{
    Register src_reg = as_Register($src$$reg);
    Register dst_reg = as_Register($dst$$reg);

    __ sra_d(dst_reg, src_reg, $shift$$Register);
  %}
  ins_pipe( ialu_reg_reg );
%}

// Shift Right Long logically
instruct slrL_Reg_Reg(mRegL dst, mRegL src, mRegI shift) %{
  match(Set dst (URShiftL src shift));
  ins_cost(100);
  format %{ "slrL    $dst, $src, $shift @ slrL_Reg_Reg" %}
  ins_encode %{
    Register src_reg = as_Register($src$$reg);
    Register dst_reg = as_Register($dst$$reg);

    __ srl_d(dst_reg, src_reg, $shift$$Register);
  %}
  ins_pipe( ialu_reg_reg );
%}

instruct slrL_Reg_immI_0_31(mRegL dst, mRegLorI2L src, immI_0_31 shift) %{
  match(Set dst (URShiftL src shift));
  ins_cost(80);
  format %{ "slrL    $dst, $src, $shift @ slrL_Reg_immI_0_31" %}
  ins_encode %{
    Register src_reg = as_Register($src$$reg);
    Register dst_reg = as_Register($dst$$reg);
    int        shamt = $shift$$constant;

    __ srli_d(dst_reg, src_reg, shamt);
  %}
  ins_pipe( ialu_reg_imm );
%}

instruct slrL_Reg_immI_0_31_and_max_int(mRegI dst, mRegLorI2L src, immI_0_31 shift, immI_MaxI max_int) %{
  match(Set dst (AndI (ConvL2I (URShiftL src shift)) max_int));
  ins_cost(80);
  format %{ "bstrpick_d    $dst, $src, $shift+30, shift @ slrL_Reg_immI_0_31_and_max_int" %}
  ins_encode %{
    Register src_reg = as_Register($src$$reg);
    Register dst_reg = as_Register($dst$$reg);
    int        shamt = $shift$$constant;

    __ bstrpick_d(dst_reg, src_reg, shamt+30, shamt);
  %}
  ins_pipe( ialu_reg_imm );
%}

instruct slrL_P2XReg_immI_0_31(mRegL dst, mRegP src, immI_0_31 shift) %{
  match(Set dst (URShiftL (CastP2X src) shift));
  ins_cost(80);
  format %{ "slrL    $dst, $src, $shift @ slrL_P2XReg_immI_0_31" %}
  ins_encode %{
    Register src_reg = as_Register($src$$reg);
    Register dst_reg = as_Register($dst$$reg);
    int        shamt = $shift$$constant;

    __ srli_d(dst_reg, src_reg, shamt);
  %}
  ins_pipe( ialu_reg_imm );
%}

instruct slrL_Reg_immI_32_63(mRegL dst, mRegLorI2L src, immI_32_63 shift) %{
  match(Set dst (URShiftL src shift));
  ins_cost(80);
  format %{ "slrL    $dst, $src, $shift @ slrL_Reg_immI_32_63" %}
  ins_encode %{
    Register src_reg = as_Register($src$$reg);
    Register dst_reg = as_Register($dst$$reg);
    int        shamt = $shift$$constant;

    __ srli_d(dst_reg, src_reg, shamt);
  %}
  ins_pipe( ialu_reg_imm );
%}

instruct slrL_Reg_immI_convL2I(mRegI dst, mRegLorI2L src, immI_32_63 shift) %{
  match(Set dst (ConvL2I (URShiftL src shift)));
  predicate(n->in(1)->in(2)->get_int() > 32);
  ins_cost(80);
  format %{ "slrL    $dst, $src, $shift @ slrL_Reg_immI_convL2I" %}
  ins_encode %{
    Register src_reg = as_Register($src$$reg);
    Register dst_reg = as_Register($dst$$reg);
    int        shamt = $shift$$constant;

    __ srli_d(dst_reg, src_reg, shamt);
  %}
  ins_pipe( ialu_reg_imm );
%}

instruct slrL_P2XReg_immI_32_63(mRegL dst, mRegP src, immI_32_63 shift) %{
  match(Set dst (URShiftL (CastP2X src) shift));
  ins_cost(80);
  format %{ "slrL    $dst, $src, $shift @ slrL_P2XReg_immI_32_63" %}
  ins_encode %{
    Register src_reg = as_Register($src$$reg);
    Register dst_reg = as_Register($dst$$reg);
    int        shamt = $shift$$constant;

    __ srli_d(dst_reg, src_reg, shamt);
  %}
  ins_pipe( ialu_reg_imm );
%}

// Xor Instructions
// Xor Register with Register
instruct xorI_Reg_Reg(mRegI dst, mRegI src1, mRegI src2) %{
  match(Set dst (XorI src1 src2));

  format %{ "XOR    $dst, $src1, $src2 #@xorI_Reg_Reg" %}

  ins_encode %{
    Register  dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;
    __ xorr(dst, src1, src2);
  %}

  ins_pipe( ialu_reg_reg );
%}

// Or Instructions
instruct orI_Reg_imm(mRegI dst, mRegI src1, immI_0_4095 src2) %{
  match(Set dst (OrI src1 src2));

  format %{ "OR     $dst, $src1, $src2 #@orI_Reg_imm" %}
  ins_encode %{
    __ ori($dst$$Register, $src1$$Register, $src2$$constant);
  %}

  ins_pipe( ialu_reg_imm );
%}

// Or Register with Register
instruct orI_Reg_Reg(mRegI dst, mRegI src1, mRegI src2) %{
  match(Set dst (OrI src1 src2));

  format %{ "OR     $dst, $src1, $src2 #@orI_Reg_Reg" %}
  ins_encode %{
    Register  dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;
    __ orr(dst, src1, src2);
  %}

  ins_pipe( ialu_reg_reg );
%}

instruct rotI_shr_logical_Reg(mRegI dst, mRegI src, immI_0_31 rshift, immI_0_31 lshift, immI_1 one) %{
  match(Set dst (OrI (URShiftI src rshift) (LShiftI (AndI src one) lshift)));
  predicate(32 == ((n->in(1)->in(2)->get_int() + n->in(2)->in(2)->get_int())));

  format %{ "rotri_w     $dst, $src, 1 ...\n\t"
            "srli_w      $dst, $dst, ($rshift-1) @ rotI_shr_logical_Reg" %}
  ins_encode %{
    Register   dst = $dst$$Register;
    Register   src = $src$$Register;
    int     rshift = $rshift$$constant;

    __ rotri_w(dst, src, 1);
    if (rshift - 1) {
      __ srli_w(dst, dst, rshift - 1);
    }
  %}

  ins_pipe( ialu_reg_reg );
%}

instruct orI_Reg_castP2X(mRegL dst, mRegL src1, mRegP src2) %{
  match(Set dst (OrI src1 (CastP2X src2)));

  format %{ "OR     $dst, $src1, $src2 #@orI_Reg_castP2X" %}
  ins_encode %{
    Register  dst = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;
    __ orr(dst, src1, src2);
  %}

  ins_pipe( ialu_reg_reg );
%}

// Logical Shift Right by 5-bit immediate
instruct shr_logical_Reg_imm(mRegI dst, mRegI src, immIU5 shift) %{
  match(Set dst (URShiftI src shift));
  //effect(KILL cr);

  format %{ "SRLI_W    $dst, $src, $shift #@shr_logical_Reg_imm" %}
  ins_encode %{
    Register src = $src$$Register;
    Register dst = $dst$$Register;
    int    shift = $shift$$constant;

    __ srli_w(dst, src, shift);
  %}
  ins_pipe( ialu_reg_imm );
%}

instruct shr_logical_Reg_imm_nonneg_mask(mRegI dst, mRegI src, immI_0_31 shift, immI_nonneg_mask mask) %{
  match(Set dst (AndI (URShiftI src shift) mask));

  format %{ "bstrpick_w    $dst, $src, $shift+one-bits($mask)-1, shift #@shr_logical_Reg_imm_nonneg_mask" %}
  ins_encode %{
    Register src = $src$$Register;
    Register dst = $dst$$Register;
    int      pos = $shift$$constant;
    int      val = $mask$$constant;
    int     size = Assembler::count_trailing_ones(val);

    __ bstrpick_w(dst, src, pos+size-1, pos);
  %}
  ins_pipe( ialu_reg_imm );
%}

instruct rolI_Reg_immI_0_31(mRegI dst, mRegI src, immI_0_31 lshift, immI_0_31 rshift)
%{
  predicate(0 == ((n->in(1)->in(2)->get_int() + n->in(2)->in(2)->get_int()) & 0x1f));
  match(Set dst (OrI (LShiftI src lshift) (URShiftI src rshift)));

  ins_cost(100);
  format %{ "rotri_w    $dst, $src, $rshift #@rolI_Reg_immI_0_31" %}
  ins_encode %{
    Register dst = $dst$$Register;
    Register src = $src$$Register;
    int      sa  = $rshift$$constant;

    __ rotri_w(dst, src, sa);
  %}
  ins_pipe( ialu_reg_imm );
%}

instruct rolL_Reg_immI_0_31(mRegL dst, mRegLorI2L src, immI_32_63 lshift, immI_0_31 rshift)
%{
  predicate(0 == ((n->in(1)->in(2)->get_int() + n->in(2)->in(2)->get_int()) & 0x3f));
  match(Set dst (OrL (LShiftL src lshift) (URShiftL src rshift)));

  ins_cost(100);
  format %{ "rotri_d    $dst, $src, $rshift #@rolL_Reg_immI_0_31" %}
  ins_encode %{
    Register dst = $dst$$Register;
    Register src = $src$$Register;
    int      sa  = $rshift$$constant;

    __ rotri_d(dst, src, sa);
  %}
  ins_pipe( ialu_reg_imm );
%}

instruct rolL_Reg_immI_32_63(mRegL dst, mRegLorI2L src, immI_0_31 lshift, immI_32_63 rshift)
%{
  predicate(0 == ((n->in(1)->in(2)->get_int() + n->in(2)->in(2)->get_int()) & 0x3f));
  match(Set dst (OrL (LShiftL src lshift) (URShiftL src rshift)));

  ins_cost(100);
  format %{ "rotri_d    $dst, $src, $rshift #@rolL_Reg_immI_32_63" %}
  ins_encode %{
    Register dst = $dst$$Register;
    Register src = $src$$Register;
    int      sa  = $rshift$$constant;

    __ rotri_d(dst, src, sa);
  %}
  ins_pipe( ialu_reg_imm );
%}

instruct rorI_Reg_immI_0_31(mRegI dst, mRegI src, immI_0_31 rshift, immI_0_31 lshift)
%{
  predicate(0 == ((n->in(1)->in(2)->get_int() + n->in(2)->in(2)->get_int()) & 0x1f));
  match(Set dst (OrI (URShiftI src rshift) (LShiftI src lshift)));

  ins_cost(100);
  format %{ "rotri_w    $dst, $src, $rshift #@rorI_Reg_immI_0_31" %}
  ins_encode %{
    Register dst = $dst$$Register;
    Register src = $src$$Register;
    int      sa  = $rshift$$constant;

    __ rotri_w(dst, src, sa);
  %}
  ins_pipe( ialu_reg_imm );
%}

instruct rorL_Reg_immI_0_31(mRegL dst, mRegLorI2L src, immI_0_31 rshift, immI_32_63 lshift)
%{
  predicate(0 == ((n->in(1)->in(2)->get_int() + n->in(2)->in(2)->get_int()) & 0x3f));
  match(Set dst (OrL (URShiftL src rshift) (LShiftL src lshift)));

  ins_cost(100);
  format %{ "rotri_d    $dst, $src, $rshift #@rorL_Reg_immI_0_31" %}
  ins_encode %{
    Register dst = $dst$$Register;
    Register src = $src$$Register;
    int      sa  = $rshift$$constant;

    __ rotri_d(dst, src, sa);
  %}
  ins_pipe( ialu_reg_imm );
%}

instruct rorL_Reg_immI_32_63(mRegL dst, mRegLorI2L src, immI_32_63 rshift, immI_0_31 lshift)
%{
  predicate(0 == ((n->in(1)->in(2)->get_int() + n->in(2)->in(2)->get_int()) & 0x3f));
  match(Set dst (OrL (URShiftL src rshift) (LShiftL src lshift)));

  ins_cost(100);
  format %{ "rotri_d    $dst, $src, $rshift #@rorL_Reg_immI_32_63" %}
  ins_encode %{
    Register dst = $dst$$Register;
    Register src = $src$$Register;
    int      sa  = $rshift$$constant;

    __ rotri_d(dst, src, sa);
  %}
  ins_pipe( ialu_reg_imm );
%}

// Rotate Shift Left
instruct rolI_reg(mRegI dst, mRegI src, mRegI shift)
%{
  match(Set dst (RotateLeft src shift));

  format %{ "rotl_w    $dst, $src, $shift @ rolI_reg" %}

  ins_encode %{
     __ sub_w(AT, R0, $shift$$Register);
     __ rotr_w($dst$$Register, $src$$Register, AT);
  %}

  ins_pipe( ialu_reg_reg );
%}

instruct rolL_reg(mRegL dst, mRegL src, mRegI shift)
%{
  match(Set dst (RotateLeft src shift));

  format %{ "rotl_d    $dst, $src, $shift @ rolL_reg" %}

  ins_encode %{
     __ sub_d(AT, R0, $shift$$Register);
     __ rotr_d($dst$$Register, $src$$Register, AT);
  %}

  ins_pipe( ialu_reg_reg );
%}

// Rotate Shift Right
instruct rorI_imm(mRegI dst, mRegI src, immI shift)
%{
  match(Set dst (RotateRight src shift));

  format %{ "rotri_w    $dst, $src, $shift @ rorI_imm" %}

  ins_encode %{
     __ rotri_w($dst$$Register, $src$$Register, $shift$$constant/* & 0x1f*/);
  %}

  ins_pipe( ialu_reg_imm );
%}

instruct rorI_reg(mRegI dst, mRegI src, mRegI shift)
%{
  match(Set dst (RotateRight src shift));

  format %{ "rotr_w    $dst, $src, $shift @ rorI_reg" %}

  ins_encode %{
     __ rotr_w($dst$$Register, $src$$Register, $shift$$Register);
  %}

  ins_pipe( ialu_reg_reg );
%}

instruct rorL_imm(mRegL dst, mRegL src, immI shift)
%{
  match(Set dst (RotateRight src shift));

  format %{ "rotri_d    $dst, $src, $shift @ rorL_imm" %}

  ins_encode %{
    __ rotri_d($dst$$Register, $src$$Register, $shift$$constant/* & 0x3f*/);
  %}

  ins_pipe( ialu_reg_imm );
%}

instruct rorL_reg(mRegL dst, mRegL src, mRegI shift)
%{
  match(Set dst (RotateRight src shift));

  format %{ "rotr_d    $dst, $src, $shift @ rorL_reg" %}

  ins_encode %{
    __ rotr_d($dst$$Register, $src$$Register, $shift$$Register);
  %}

  ins_pipe( ialu_reg_reg );
%}

// Logical Shift Right
instruct shr_logical_Reg_Reg(mRegI dst, mRegI src, mRegI shift) %{
  match(Set dst (URShiftI src shift));

  format %{ "SRL_W    $dst, $src, $shift #@shr_logical_Reg_Reg" %}
  ins_encode %{
    Register src = $src$$Register;
    Register dst = $dst$$Register;
    Register shift = $shift$$Register;
    __ srl_w(dst, src, shift);
  %}
  ins_pipe( ialu_reg_reg );
%}


instruct shr_arith_Reg_imm(mRegI dst, mRegI src, immIU5 shift) %{
  match(Set dst (RShiftI src shift));
 // effect(KILL cr);

  format %{ "SRAI_W    $dst, $src, $shift #@shr_arith_Reg_imm" %}
  ins_encode %{
    Register src = $src$$Register;
    Register dst = $dst$$Register;
    int    shift = $shift$$constant;
    __ srai_w(dst, src, shift);
  %}
  ins_pipe( ialu_reg_imm );
%}

instruct shr_arith_Reg_Reg(mRegI dst, mRegI src, mRegI shift) %{
  match(Set dst (RShiftI src shift));
 // effect(KILL cr);

  format %{ "SRA_W    $dst, $src, $shift #@shr_arith_Reg_Reg" %}
  ins_encode %{
    Register src = $src$$Register;
    Register dst = $dst$$Register;
    Register shift = $shift$$Register;
    __ sra_w(dst, src, shift);
  %}
  ins_pipe( ialu_reg_reg );
%}

//----------Convert Int to Boolean---------------------------------------------

instruct convI2B(mRegI dst, mRegI src) %{
  match(Set dst (Conv2B src));

  ins_cost(100);
  format %{ "convI2B    $dst, $src @ convI2B"  %}
  ins_encode %{
    Register dst = as_Register($dst$$reg);
    Register src = as_Register($src$$reg);

    __ sltu(dst, R0, src);
  %}

  ins_pipe( ialu_reg_reg );
%}

instruct convI2L_reg( mRegL dst, mRegI src) %{
  match(Set dst (ConvI2L src));

  ins_cost(100);
  format %{ "SLLI_W    $dst, $src @ convI2L_reg\t"  %}

  ins_encode %{
    Register dst = as_Register($dst$$reg);
    Register src = as_Register($src$$reg);

    if(dst != src) __ slli_w(dst, src, 0);
  %}
  ins_pipe( ialu_reg_imm );
%}

instruct convL2I_reg( mRegI dst, mRegLorI2L src ) %{
  match(Set dst (ConvL2I src));

  format %{ "MOV    $dst, $src @ convL2I_reg" %}
  ins_encode %{
    Register dst = as_Register($dst$$reg);
    Register src = as_Register($src$$reg);

    __ slli_w(dst, src, 0);
  %}

  ins_pipe( ialu_reg_imm );
%}

instruct convL2D_reg( regD dst, mRegL src ) %{
  match(Set dst (ConvL2D src));
  format %{ "convL2D    $dst, $src @ convL2D_reg" %}
  ins_encode %{
    Register src = as_Register($src$$reg);
    FloatRegister dst = as_FloatRegister($dst$$reg);

    __ movgr2fr_d(dst, src);
    __ ffint_d_l(dst, dst);
  %}

  ins_pipe( pipe_slow );
%}


// Convert double to int.
// If the double is NaN, stuff a zero in instead.
instruct convD2I_reg_reg(mRegI dst, regD src, regD tmp) %{
  match(Set dst (ConvD2I src));
  effect(USE src, TEMP tmp);

  format %{ "convd2i    $dst, $src, using $tmp as TEMP @ convD2I_reg_reg" %}

  ins_encode %{
    __ ftintrz_w_d($tmp$$FloatRegister, $src$$FloatRegister);
    __ movfr2gr_s($dst$$Register, $tmp$$FloatRegister);
  %}

  ins_pipe( pipe_slow );
%}

instruct convD2L_reg_reg(mRegL dst, regD src, regD tmp) %{
  match(Set dst (ConvD2L src));
  effect(USE src, TEMP tmp);

  format %{ "convd2l    $dst, $src, using $tmp as TEMP @ convD2L_reg_reg" %}

  ins_encode %{
    __ ftintrz_l_d($tmp$$FloatRegister, $src$$FloatRegister);
    __ movfr2gr_d($dst$$Register, $tmp$$FloatRegister);
  %}

  ins_pipe( pipe_slow );
%}

// Convert float to int.
// If the float is NaN, stuff a zero in instead.
instruct convF2I_reg_reg(mRegI dst, regF src, regF tmp) %{
  match(Set dst (ConvF2I src));
  effect(USE src, TEMP tmp);

  format %{ "convf2i    $dst, $src, using $tmp as TEMP @ convF2I_reg_reg" %}

  ins_encode %{
    __ ftintrz_w_s($tmp$$FloatRegister, $src$$FloatRegister);
    __ movfr2gr_s($dst$$Register, $tmp$$FloatRegister);
  %}

  ins_pipe( pipe_slow );
%}

instruct convF2L_reg_reg(mRegL dst, regF src, regF tmp) %{
  match(Set dst (ConvF2L src));
  effect(USE src, TEMP tmp);

  format %{ "convf2l    $dst, $src, using $tmp as TEMP @ convF2L_reg_reg" %}

  ins_encode %{
    __ ftintrz_l_s($tmp$$FloatRegister, $src$$FloatRegister);
    __ movfr2gr_d($dst$$Register, $tmp$$FloatRegister);
  %}

  ins_pipe( pipe_slow );
%}


instruct convL2F_reg( regF dst, mRegL src ) %{
  match(Set dst (ConvL2F src));
  format %{ "convl2f    $dst, $src @ convL2F_reg" %}
  ins_encode %{
    FloatRegister dst = $dst$$FloatRegister;
    Register src = as_Register($src$$reg);
    Label L;

    __ movgr2fr_d(dst, src);
    __ ffint_s_l(dst, dst);
  %}

  ins_pipe( pipe_slow );
%}

instruct convI2F_reg( regF dst, mRegI src ) %{
  match(Set dst (ConvI2F src));
  format %{ "convi2f    $dst, $src @ convI2F_reg" %}
  ins_encode %{
    Register      src = $src$$Register;
    FloatRegister dst = $dst$$FloatRegister;

    __ movgr2fr_w(dst, src);
    __ ffint_s_w(dst, dst);
  %}

  ins_pipe( pipe_slow );
%}

instruct convF2HF_reg_reg(mRegI dst, regF src, regF tmp) %{
  predicate(UseLSX);
  match(Set dst (ConvF2HF src));
  format %{ "fcvt_f2hf    $dst, $src\t# TMEP($tmp) @convF2HF_reg_reg" %}
  effect(TEMP tmp);
  ins_encode %{
      __ flt_to_flt16($dst$$Register, $src$$FloatRegister, $tmp$$FloatRegister);
  %}
  ins_pipe(pipe_slow);
%}

instruct convHF2F_reg_reg(regF dst, mRegI src, regF tmp) %{
  predicate(UseLSX);
  match(Set dst (ConvHF2F src));
  format %{ "fcvt_hf2f    $dst, $src\t# TMEP($tmp) @convHF2F_reg_reg" %}
  effect(TEMP tmp);
  ins_encode %{
      __ flt16_to_flt($dst$$FloatRegister, $src$$Register, $tmp$$FloatRegister);
  %}
  ins_pipe(pipe_slow);
%}

instruct round_float_reg(mRegI dst, regF src, regF vtemp1)
%{
  match(Set dst (RoundF src));
  effect(TEMP_DEF dst, TEMP vtemp1);
  format %{ "round_float    $dst, $src\t# "
            "TEMP($vtemp1) @round_float_reg" %}
  ins_encode %{
    __ java_round_float($dst$$Register,
                        $src$$FloatRegister,
                        $vtemp1$$FloatRegister);
  %}
  ins_pipe( pipe_slow );
%}

instruct round_double_reg(mRegL dst, regD src, regD vtemp1)
%{
  match(Set dst (RoundD src));
  effect(TEMP_DEF dst, TEMP vtemp1);
  format %{ "round_double    $dst, $src\t# "
            "TEMP($vtemp1) @round_double_reg" %}
  ins_encode %{
    __ java_round_double($dst$$Register,
                         $src$$FloatRegister,
                         $vtemp1$$FloatRegister);
  %}
  ins_pipe( pipe_slow );
%}

instruct roundD(regD dst, regD src, immI rmode) %{
  predicate(UseLSX);
  match(Set dst (RoundDoubleMode src rmode));
  format %{ "frint    $dst, $src, $rmode\t# @roundD" %}
  ins_encode %{
    switch ($rmode$$constant) {
      case RoundDoubleModeNode::rmode_rint:  __ vfrintrne_d($dst$$FloatRegister, $src$$FloatRegister); break;
      case RoundDoubleModeNode::rmode_floor: __ vfrintrm_d($dst$$FloatRegister, $src$$FloatRegister);  break;
      case RoundDoubleModeNode::rmode_ceil:  __ vfrintrp_d($dst$$FloatRegister, $src$$FloatRegister);  break;
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct cmpLTMask_immI_0( mRegI dst, mRegI p, immI_0 zero ) %{
  match(Set dst (CmpLTMask p zero));
  ins_cost(100);

  format %{ "srai_w    $dst, $p, 31 @ cmpLTMask_immI_0" %}
    ins_encode %{
       Register src = $p$$Register;
       Register dst = $dst$$Register;

       __ srai_w(dst, src, 31);
    %}
    ins_pipe( ialu_reg_imm );
%}


instruct cmpLTMask( mRegI dst, mRegI p, mRegI q ) %{
  match(Set dst (CmpLTMask p q));
  ins_cost(400);

  format %{ "cmpLTMask    $dst, $p, $q @ cmpLTMask" %}
  ins_encode %{
    Register p   = $p$$Register;
    Register q   = $q$$Register;
    Register dst = $dst$$Register;

    __ slt(dst, p, q);
    __ sub_d(dst, R0, dst);
    %}
  ins_pipe( ialu_reg_reg );
%}

instruct convP2B(mRegI dst, mRegP src) %{
  match(Set dst (Conv2B src));

  ins_cost(100);
  format %{ "convP2B    $dst, $src @ convP2B"  %}
  ins_encode %{
    Register dst = as_Register($dst$$reg);
    Register src = as_Register($src$$reg);

    __ sltu(dst, R0, src);
  %}

  ins_pipe( pipe_slow );
%}


instruct convI2D_reg_reg(regD dst, mRegI src) %{
  match(Set dst (ConvI2D src));
  format %{ "conI2D $dst, $src @convI2D_reg" %}
  ins_encode %{
    Register      src = $src$$Register;
    FloatRegister dst = $dst$$FloatRegister;
    __ movgr2fr_w(dst ,src);
    __ ffint_d_w(dst, dst);
    %}
  ins_pipe( pipe_slow );
%}

instruct convF2D_reg_reg(regD dst, regF src) %{
  match(Set dst (ConvF2D src));
  format %{ "convF2D  $dst, $src\t# @convF2D_reg_reg" %}
  ins_encode %{
    FloatRegister dst = $dst$$FloatRegister;
    FloatRegister src = $src$$FloatRegister;

    __ fcvt_d_s(dst, src);
  %}
  ins_pipe( fpu_cvt );
%}

instruct convD2F_reg_reg(regF dst, regD src) %{
  match(Set dst (ConvD2F src));
  format %{ "convD2F  $dst, $src\t# @convD2F_reg_reg" %}
  ins_encode %{
    FloatRegister dst = $dst$$FloatRegister;
    FloatRegister src = $src$$FloatRegister;

    __ fcvt_s_d(dst, src);
  %}
  ins_pipe( fpu_cvt );
%}


// Convert oop pointer into compressed form
instruct encodeHeapOop(mRegN dst, mRegP src) %{
  predicate(n->bottom_type()->make_ptr()->ptr() != TypePtr::NotNull);
  match(Set dst (EncodeP src));
  format %{ "encode_heap_oop $dst,$src" %}
  ins_encode %{
    Register src = $src$$Register;
    Register dst = $dst$$Register;

    __ encode_heap_oop(dst, src);
  %}
  ins_pipe( pipe_slow );
%}

instruct encodeHeapOop_not_null(mRegN dst, mRegP src) %{
  predicate(n->bottom_type()->make_ptr()->ptr() == TypePtr::NotNull);
  match(Set dst (EncodeP src));
  format %{ "encode_heap_oop_not_null $dst,$src @ encodeHeapOop_not_null" %}
  ins_encode %{
    __ encode_heap_oop_not_null($dst$$Register, $src$$Register);
  %}
  ins_pipe( pipe_slow );
%}

instruct decodeHeapOop(mRegP dst, mRegN src) %{
  predicate(n->bottom_type()->is_ptr()->ptr() != TypePtr::NotNull &&
            n->bottom_type()->is_ptr()->ptr() != TypePtr::Constant);
  match(Set dst (DecodeN src));
  format %{ "decode_heap_oop $dst,$src @ decodeHeapOop" %}
  ins_encode %{
    Register s = $src$$Register;
    Register d = $dst$$Register;

    __ decode_heap_oop(d, s);
  %}
  ins_pipe( pipe_slow );
%}

instruct decodeHeapOop_not_null(mRegP dst, mRegN src) %{
  predicate(n->bottom_type()->is_ptr()->ptr() == TypePtr::NotNull ||
            n->bottom_type()->is_ptr()->ptr() == TypePtr::Constant);
  match(Set dst (DecodeN src));
  format %{ "decode_heap_oop_not_null $dst,$src @ decodeHeapOop_not_null" %}
  ins_encode %{
    Register s = $src$$Register;
    Register d = $dst$$Register;
    if (s != d) {
      __ decode_heap_oop_not_null(d, s);
    } else {
      __ decode_heap_oop_not_null(d);
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct encodeKlass_not_null(mRegN dst, mRegP src) %{
  match(Set dst (EncodePKlass src));
  format %{ "encode_heap_oop_not_null $dst,$src @ encodeKlass_not_null" %}
  ins_encode %{
    __ encode_klass_not_null($dst$$Register, $src$$Register);
  %}
  ins_pipe( pipe_slow );
%}

instruct decodeKlass_not_null(mRegP dst, mRegN src) %{
  match(Set dst (DecodeNKlass src));
  format %{ "decode_heap_klass_not_null $dst,$src" %}
  ins_encode %{
    Register s = $src$$Register;
    Register d = $dst$$Register;
    if (s != d) {
      __ decode_klass_not_null(d, s);
    } else {
      __ decode_klass_not_null(d);
    }
  %}
  ins_pipe( pipe_slow );
%}

// ============================================================================
// This name is KNOWN by the ADLC and cannot be changed.
// The ADLC forces a 'TypeRawPtr::BOTTOM' output type
// for this guy.
instruct tlsLoadP(javaThread_RegP dst)
%{
  match(Set dst (ThreadLocal));

  ins_cost(0);

  format %{ " -- \t// $dst=Thread::current(), empty encoding, #@tlsLoadP" %}

  size(0);

  ins_encode( /*empty*/ );

  ins_pipe( empty );
%}


instruct checkCastPP( mRegP dst ) %{
  match(Set dst (CheckCastPP dst));

  format %{ "#checkcastPP of $dst (empty encoding) #@chekCastPP" %}
  ins_encode( /*empty encoding*/ );
  ins_pipe( empty );
%}

instruct castPP(mRegP dst)
%{
  match(Set dst (CastPP dst));

  size(0);
  format %{ "# castPP of $dst" %}
  ins_encode(/* empty encoding */);
  ins_pipe( empty );
%}

instruct castII( mRegI dst ) %{
  match(Set dst (CastII dst));
  format %{ "#castII of $dst  empty encoding" %}
  ins_encode( /*empty encoding*/ );
  ins_cost(0);
  ins_pipe( empty );
%}

instruct castLL(mRegL dst)
%{
  match(Set dst (CastLL dst));

  size(0);
  format %{ "# castLL of $dst" %}
  ins_encode(/* empty encoding */);
  ins_cost(0);
  ins_pipe( empty );
%}

instruct castFF(regF dst) %{
  match(Set dst (CastFF dst));
  size(0);
  format %{ "# castFF of $dst" %}
  ins_encode(/*empty*/);
  ins_pipe( empty );
%}

instruct castDD(regD dst) %{
  match(Set dst (CastDD dst));
  size(0);
  format %{ "# castDD of $dst" %}
  ins_encode(/*empty*/);
  ins_pipe( empty );
%}

instruct castVV(vReg dst) %{
  match(Set dst (CastVV dst));
  size(0);
  format %{ "# castVV of $dst" %}
  ins_encode(/*empty*/);
  ins_pipe( empty );
%}

// Return Instruction
// Remove the return address & jump to it.
instruct Ret() %{
  match(Return);
  format %{ "RET #@Ret" %}

  ins_encode %{
   __ jr(RA);
  %}

  ins_pipe( pipe_jump );
%}



// Tail Jump; remove the return address; jump to target.
// TailCall above leaves the return address around.
// TailJump is used in only one place, the rethrow_Java stub (fancy_jump=2).
// ex_oop (Exception Oop) is needed in %o0 at the jump. As there would be a
// "restore" before this instruction (in Epilogue), we need to materialize it
// in %i0.
//FIXME
instruct tailjmpInd(mRegP jump_target, a0_RegP ex_oop, mA1RegI exception_pc) %{
  match( TailJump jump_target ex_oop );
  ins_cost(200);
  format %{ "Jmp     $jump_target  ; ex_oop = $ex_oop #@tailjmpInd" %}
  ins_encode %{
    Register target = $jump_target$$Register;

    // A0, A1 are indicated in:
    //     [stubGenerator_loongarch.cpp] generate_forward_exception()
    //     [runtime_loongarch.cpp] OptoRuntime::generate_exception_blob()
    __ move($exception_pc$$Register, RA);
    __ jr(target);
  %}
  ins_pipe( pipe_jump );
%}

// ============================================================================
// Procedure Call/Return Instructions
// Call Java Static Instruction
// Note: If this code changes, the corresponding ret_addr_offset() and
//       compute_padding() functions will have to be adjusted.
instruct CallStaticJavaDirect(method meth) %{
  match(CallStaticJava);
  effect(USE meth);

  ins_cost(300);
  format %{ "CALL,static #@CallStaticJavaDirect " %}
  ins_encode( Java_Static_Call( meth ) );
  ins_pipe( pipe_slow );
  ins_pc_relative(1);
  ins_alignment(4);
%}

// Call Java Dynamic Instruction
// Note: If this code changes, the corresponding ret_addr_offset() and
//       compute_padding() functions will have to be adjusted.
instruct CallDynamicJavaDirect(method meth) %{
  match(CallDynamicJava);
  effect(USE meth);

  ins_cost(300);
  format %{"MOV IC_Klass, #Universe::non_oop_word()\n\t"
           "CallDynamic @ CallDynamicJavaDirect" %}
  ins_encode( Java_Dynamic_Call( meth ) );
  ins_pipe( pipe_slow );
  ins_pc_relative(1);
  ins_alignment(4);
%}

instruct CallLeafNoFPDirect(method meth) %{
  match(CallLeafNoFP);
  effect(USE meth);

  ins_cost(300);
  format %{ "CALL_LEAF_NOFP,runtime " %}
  ins_encode(Java_To_Runtime(meth));
  ins_pipe( pipe_slow );
  ins_pc_relative(1);
  ins_alignment(4);
%}

// Prefetch instructions for allocation.

instruct prefetchAlloc(memory mem) %{
  match(PrefetchAllocation mem);
  ins_cost(125);
  format %{ "preld $mem\t# Prefetch allocation @ prefetchAlloc" %}
  ins_encode %{
    int  base = $mem$$base;
    int  index = $mem$$index;
    int  disp = $mem$$disp;

    if (index != -1) {
      __ add_d(AT, as_Register(base), as_Register(index));
      __ preld(8, AT, disp);
    } else {
      __ preld(8, as_Register(base), disp);
    }
  %}
  ins_pipe( pipe_prefetch );
%}

// Call runtime without safepoint
instruct CallLeafDirect(method meth) %{
  match(CallLeaf);
  effect(USE meth);

  ins_cost(300);
  format %{ "CALL_LEAF,runtime #@CallLeafDirect " %}
  ins_encode(Java_To_Runtime(meth));
  ins_pipe( pipe_slow );
  ins_pc_relative(1);
  ins_alignment(4);
%}

// Load Char (16bit unsigned)
instruct loadUS(mRegI dst, memory mem) %{
  match(Set dst (LoadUS mem));

  ins_cost(125);
  format %{ "loadUS  $dst,$mem @ loadC" %}
  ins_encode %{
    __ loadstore_enc($dst$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_U_SHORT);
  %}
  ins_pipe( ialu_load );
%}

instruct loadUS_convI2L(mRegL dst, memory mem) %{
  match(Set dst (ConvI2L (LoadUS mem)));

  ins_cost(125);
  format %{ "loadUS  $dst,$mem @ loadUS_convI2L" %}
  ins_encode %{
    __ loadstore_enc($dst$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_U_SHORT);
  %}
  ins_pipe( ialu_load );
%}

// Store Char (16bit unsigned)
instruct storeC(memory mem, mRegIorL2I src) %{
  match(Set mem (StoreC mem src));

  ins_cost(125);
  format %{ "storeC  $src, $mem @ storeC" %}
  ins_encode %{
    __ loadstore_enc($src$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::STORE_CHAR);
  %}
  ins_pipe( ialu_store );
%}

instruct storeC_0(memory mem, immI_0 zero) %{
  match(Set mem (StoreC mem zero));

  ins_cost(125);
  format %{ "storeC  $zero, $mem @ storeC_0" %}
  ins_encode %{
     __ loadstore_enc(R0, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::STORE_SHORT);
  %}
  ins_pipe( ialu_store );
%}


instruct loadConF_immF_0(regF dst, immF_0 zero) %{
  match(Set dst zero);
  ins_cost(100);

  format %{ "mov  $dst, zero @ loadConF_immF_0\n"%}
  ins_encode %{
    FloatRegister dst = $dst$$FloatRegister;

    __ movgr2fr_w(dst, R0);
  %}
  ins_pipe( fpu_movgrfr );
%}


instruct loadConF(regF dst, immF src) %{
  match(Set dst src);
  ins_cost(125);

  format %{ "fld_s  $dst, $constantoffset[$constanttablebase] # load FLOAT $src from table @ loadConF" %}
  ins_encode %{
    int con_offset = $constantoffset($src);

    if (Assembler::is_simm(con_offset, 12)) {
      __ fld_s($dst$$FloatRegister, $constanttablebase, con_offset);
    } else {
      __ li(AT, con_offset);
      __ fldx_s($dst$$FloatRegister, $constanttablebase, AT);
    }
  %}
  ins_pipe( fpu_load );
%}

instruct loadConFVec(regF dst, immFVec src) %{
  match(Set dst src);
  ins_cost(50);

  format %{ "vldi  $dst, $src # load FLOAT $src @ loadConFVec" %}
  ins_encode %{
    int val = Assembler::get_vec_imm($src$$constant);

    __ vldi($dst$$FloatRegister, val);
  %}
  ins_pipe( fpu_load );
%}


instruct loadConD_immD_0(regD dst, immD_0 zero) %{
  match(Set dst zero);
  ins_cost(100);

  format %{ "mov  $dst, zero @ loadConD_immD_0"%}
  ins_encode %{
    FloatRegister dst = as_FloatRegister($dst$$reg);

    __ movgr2fr_d(dst, R0);
  %}
  ins_pipe( fpu_movgrfr );
%}

instruct loadConD(regD dst, immD src) %{
  match(Set dst src);
  ins_cost(125);

  format %{ "fld_d  $dst, $constantoffset[$constanttablebase] # load DOUBLE $src from table @ loadConD" %}
  ins_encode %{
    int con_offset = $constantoffset($src);

    if (Assembler::is_simm(con_offset, 12)) {
      __ fld_d($dst$$FloatRegister, $constanttablebase, con_offset);
    } else {
      __ li(AT, con_offset);
      __ fldx_d($dst$$FloatRegister, $constanttablebase, AT);
    }
  %}
  ins_pipe( fpu_load );
%}

instruct loadConDVec(regD dst, immDVec src) %{
  match(Set dst src);
  ins_cost(50);

  format %{ "vldi  $dst, $src # load DOUBLE $src @ loadConDVec" %}
  ins_encode %{
    int val = Assembler::get_vec_imm($src$$constant);

    __ vldi($dst$$FloatRegister, val);
  %}
  ins_pipe( fpu_load );
%}

// Store register Float value (it is faster than store from FPU register)
instruct storeF_reg( memory mem, regF src) %{
  match(Set mem (StoreF mem src));

  ins_cost(50);
  format %{ "store   $mem, $src\t# store float @ storeF_reg" %}
  ins_encode %{
    __ loadstore_enc($src$$FloatRegister, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::STORE_FLOAT);
  %}
  ins_pipe( fpu_store );
%}

instruct storeF_immF_0( memory mem, immF_0 zero) %{
  match(Set mem (StoreF mem zero));

  ins_cost(40);
  format %{ "store   $mem, zero\t# store float @ storeF_immF_0" %}
  ins_encode %{
    __ loadstore_enc(R0, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::STORE_INT);
  %}
  ins_pipe( ialu_store );
%}

// Load Double
instruct loadD(regD dst, memory mem) %{
  match(Set dst (LoadD mem));

  ins_cost(150);
  format %{ "loadD   $dst, $mem #@loadD" %}
  ins_encode %{
    __ loadstore_enc($dst$$FloatRegister, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_DOUBLE);
  %}
  ins_pipe( fpu_load );
%}

// Load Double - UNaligned
instruct loadD_unaligned(regD dst, memory mem ) %{
  match(Set dst (LoadD_unaligned mem));
  ins_cost(250);
  // FIXME: Need more effective ldl/ldr
  format %{ "loadD_unaligned   $dst, $mem #@loadD_unaligned" %}
  ins_encode %{
    __ loadstore_enc($dst$$FloatRegister, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_DOUBLE);
  %}
  ins_pipe( fpu_load );
%}

instruct storeD_reg( memory mem, regD src) %{
  match(Set mem (StoreD mem src));

  ins_cost(50);
  format %{ "store   $mem, $src\t# store float @ storeD_reg" %}
  ins_encode %{
    __ loadstore_enc($src$$FloatRegister, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::STORE_DOUBLE);
  %}
  ins_pipe( fpu_store );
%}

instruct storeD_immD_0( memory mem, immD_0 zero) %{
  match(Set mem (StoreD mem zero));

  ins_cost(40);
  format %{ "store   $mem, zero\t# store float @ storeD_immD_0" %}
  ins_encode %{
    __ loadstore_enc(R0, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::STORE_LONG);
  %}
  ins_pipe( ialu_store );
%}

instruct loadSSI(mRegI dst, stackSlotI src)
%{
  match(Set dst src);

  ins_cost(125);
  format %{ "ld_w    $dst, $src\t# int stk @ loadSSI" %}
  ins_encode %{
    guarantee( Assembler::is_simm($src$$disp, 12), "disp too long (loadSSI) !");
    __ ld_w($dst$$Register, SP, $src$$disp);
  %}
  ins_pipe( ialu_load );
%}

instruct storeSSI(stackSlotI dst, mRegI src)
%{
  match(Set dst src);

  ins_cost(100);
  format %{ "st_w    $dst, $src\t# int stk @ storeSSI" %}
  ins_encode %{
    guarantee( Assembler::is_simm($dst$$disp, 12), "disp too long (storeSSI) !");
    __ st_w($src$$Register, SP, $dst$$disp);
  %}
  ins_pipe( ialu_store );
%}

instruct loadSSL(mRegL dst, stackSlotL src)
%{
  match(Set dst src);

  ins_cost(125);
  format %{ "ld_d    $dst, $src\t# long stk @ loadSSL" %}
  ins_encode %{
    guarantee( Assembler::is_simm($src$$disp, 12), "disp too long (loadSSL) !");
    __ ld_d($dst$$Register, SP, $src$$disp);
  %}
  ins_pipe( ialu_load );
%}

instruct storeSSL(stackSlotL dst, mRegL src)
%{
  match(Set dst src);

  ins_cost(100);
  format %{ "st_d    $dst, $src\t# long stk @ storeSSL" %}
  ins_encode %{
    guarantee( Assembler::is_simm($dst$$disp, 12), "disp too long (storeSSL) !");
    __ st_d($src$$Register, SP, $dst$$disp);
  %}
  ins_pipe( ialu_store );
%}

instruct loadSSP(mRegP dst, stackSlotP src)
%{
  match(Set dst src);

  ins_cost(125);
  format %{ "ld_d    $dst, $src\t# ptr stk @ loadSSP" %}
  ins_encode %{
    guarantee( Assembler::is_simm($src$$disp, 12), "disp too long (loadSSP) !");
    __ ld_d($dst$$Register, SP, $src$$disp);
  %}
  ins_pipe( ialu_load );
%}

instruct storeSSP(stackSlotP dst, mRegP src)
%{
  match(Set dst src);

  ins_cost(100);
  format %{ "st_d    $dst, $src\t# ptr stk @ storeSSP" %}
  ins_encode %{
    guarantee( Assembler::is_simm($dst$$disp, 12), "disp too long (storeSSP) !");
    __ st_d($src$$Register, SP, $dst$$disp);
  %}
  ins_pipe( ialu_store );
%}

instruct loadSSF(regF dst, stackSlotF src)
%{
  match(Set dst src);

  ins_cost(125);
  format %{ "fld_s   $dst, $src\t# float stk @ loadSSF" %}
  ins_encode %{
    guarantee( Assembler::is_simm($src$$disp, 12), "disp too long (loadSSF) !");
    __ fld_s($dst$$FloatRegister, SP, $src$$disp);
  %}
  ins_pipe( fpu_load );
%}

instruct storeSSF(stackSlotF dst, regF src)
%{
  match(Set dst src);

  ins_cost(100);
  format %{ "fst_s    $dst, $src\t# float stk @ storeSSF" %}
  ins_encode %{
    guarantee( Assembler::is_simm($dst$$disp, 12), "disp too long (storeSSF) !");
    __ fst_s($src$$FloatRegister, SP, $dst$$disp);
  %}
  ins_pipe( fpu_store );
%}

// Use the same format since predicate() can not be used here.
instruct loadSSD(regD dst, stackSlotD src)
%{
  match(Set dst src);

  ins_cost(125);
  format %{ "fld_d   $dst, $src\t# double stk @ loadSSD" %}
  ins_encode %{
    guarantee( Assembler::is_simm($src$$disp, 12), "disp too long (loadSSD) !");
    __ fld_d($dst$$FloatRegister, SP, $src$$disp);
  %}
  ins_pipe( fpu_load );
%}

instruct storeSSD(stackSlotD dst, regD src)
%{
  match(Set dst src);

  ins_cost(100);
  format %{ "fst_d    $dst, $src\t# double stk @ storeSSD" %}
  ins_encode %{
    guarantee( Assembler::is_simm($dst$$disp, 12), "disp too long (storeSSD) !");
    __ fst_d($src$$FloatRegister, SP, $dst$$disp);
  %}
  ins_pipe( fpu_store );
%}

instruct cmpFastLock(FlagsReg cr, no_CR_mRegP object, no_CR_mRegP box, no_CR_mRegP tmp1, no_CR_mRegP tmp2) %{
  match(Set cr (FastLock object box));
  effect(TEMP tmp1, TEMP tmp2);

  format %{ "FASTLOCK $cr <-- $object, $box, $tmp1, $tmp2 #@ cmpFastLock" %}

  ins_encode %{
    __ fast_lock_c2($object$$Register, $box$$Register, $cr$$Register, $tmp1$$Register, $tmp2$$Register);
  %}

  ins_pipe( pipe_slow );
%}

instruct cmpFastUnlock(FlagsReg cr, no_CR_mRegP object, no_CR_mRegP box, no_CR_mRegP tmp1, no_CR_mRegP tmp2) %{
  match(Set cr (FastUnlock object box));
  effect(TEMP tmp1, TEMP tmp2);

  format %{ "FASTUNLOCK $cr <-- $object, $box, $tmp1, $tmp2 #@ cmpFastUnlock" %}

  ins_encode %{
    __ fast_unlock_c2($object$$Register, $box$$Register, $cr$$Register, $tmp1$$Register, $tmp2$$Register);
  %}

  ins_pipe( pipe_slow );
%}

// Store card-mark Immediate 0
instruct storeImmCM(memory mem, immI_0 zero) %{
  match(Set mem (StoreCM mem zero));

  ins_cost(150);
  format %{ "st_b $mem, zero\t! card-mark imm0" %}
  ins_encode %{
    __ loadstore_enc(R0, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::STORE_BYTE);
  %}
  ins_pipe( pipe_serial );
%}

// Die now
instruct ShouldNotReachHere( )
%{
  match(Halt);
  ins_cost(300);

  // Use the following format syntax
  format %{ "stop; #@ShouldNotReachHere" %}
  ins_encode %{
    if (is_reachable()) {
      __ stop(_halt_reason);
    }
  %}

  ins_pipe( pipe_jump );
%}

instruct leaP12Narrow(mRegP dst, indOffset12Narrow mem)
%{
  predicate(CompressedOops::shift() == 0);
  match(Set dst mem);

  ins_cost(110);
  format %{ "leaq    $dst, $mem\t# ptr off12narrow @ leaP12Narrow" %}
  ins_encode %{
    Register  dst  = $dst$$Register;
    Register  base = as_Register($mem$$base);
    int       disp = $mem$$disp;

    __ addi_d(dst, base, disp);
  %}
  ins_pipe( ialu_reg_imm );
%}

instruct leaPIdxScale(mRegP dst, mRegP reg, mRegLorI2L lreg, immI_0_3 scale)
%{
  match(Set dst (AddP reg (LShiftL lreg scale)));

  ins_cost(110);
  format %{ "leaq    $dst, [$reg + $lreg << $scale]\t# @ leaPIdxScale" %}
  ins_encode %{
    Register  dst   = $dst$$Register;
    Register  base  = $reg$$Register;
    Register  index = $lreg$$Register;
    int       scale = $scale$$constant;

    if (scale == 0) {
       __ add_d($dst$$Register, $reg$$Register, index);
    } else {
       __ alsl_d(dst, index, base, scale - 1);
    }
 %}

  ins_pipe( ialu_reg_imm );
%}


// ============================================================================
// The 2nd slow-half of a subtype check.  Scan the subklass's 2ndary superklass
// array for an instance of the superklass.  Set a hidden internal cache on a
// hit (cache is checked with exposed code in gen_subtype_check()).  Return
// NZ for a miss or zero for a hit.  The encoding ALSO sets flags.
instruct partialSubtypeCheck( mRegP result, mRegP sub, mRegP super, mRegI tmp2,  mRegI tmp ) %{
  match(Set result (PartialSubtypeCheck sub super));
  effect(TEMP tmp, TEMP tmp2);
  ins_cost(1100);  // slightly larger than the next version
  format %{ "partialSubtypeCheck result=$result, sub=$sub, super=$super, tmp=$tmp, tmp2=$tmp2" %}

  ins_encode( enc_PartialSubtypeCheck(result, sub, super, tmp, tmp2) );
  ins_pipe( pipe_slow );
%}

instruct partialSubtypeCheckVsZero_long( mRegP sub, mRegP super, mRegP tmp1, mRegP tmp2, immP_0 zero, cmpOpEqNe cmp, label lbl) %{
  match(If cmp (CmpP (PartialSubtypeCheck sub super) zero));
  effect(USE lbl, TEMP tmp1, TEMP tmp2);
  format %{ "partialSubtypeCheckVsZero_long b$cmp (sub=$sub, super=$super) R0, $lbl using $tmp1,$tmp2 as TEMP" %}

  ins_encode %{
    Label miss;
    Label*   success = $lbl$$label;
    int     flag = $cmp$$cmpcode;

    if (flag == 0x01) { //equal
      __ check_klass_subtype_slow_path<true>($sub$$Register, $super$$Register, $tmp1$$Register, $tmp2$$Register, success, &miss);
    } else { //no_equal
      __ check_klass_subtype_slow_path<true>($sub$$Register, $super$$Register, $tmp1$$Register, $tmp2$$Register, &miss, success);
    }
    __ bind(miss);
  %}

  ins_pipe( pipe_serial );
%}

instruct partialSubtypeCheckVsZero_short( mRegP sub, mRegP super, mRegP tmp1, mRegP tmp2, immP_0 zero, cmpOpEqNe cmp, label lbl) %{
  match(If cmp (CmpP (PartialSubtypeCheck sub super) zero));
  effect(USE lbl, TEMP tmp1, TEMP tmp2);
  format %{ "partialSubtypeCheckVsZero_short b$cmp (sub=$sub, super=$super) R0, $lbl using $tmp1,$tmp2 as TEMP" %}

  ins_encode %{
    Label miss;
    Label*   success = $lbl$$label;
    int     flag = $cmp$$cmpcode;

    if (flag == 0x01) { //equal
      __ check_klass_subtype_slow_path<false>($sub$$Register, $super$$Register, $tmp1$$Register, $tmp2$$Register, success, &miss, true);
    } else { //no_equal
      __ check_klass_subtype_slow_path<false>($sub$$Register, $super$$Register, $tmp1$$Register, $tmp2$$Register, &miss, success, true);
    }
    __ bind(miss);
  %}

  ins_pipe( pipe_serial );
  ins_short_branch(1);
%}

instruct compareAndSwapB(mRegI res, memory_exclusive mem_ptr, mRegI oldval, mRegI newval) %{
  predicate(UseAMCAS);
  match(Set res (CompareAndSwapB mem_ptr (Binary oldval newval)));
  effect(TEMP_DEF res);
  ins_cost(3 * MEMORY_REF_COST);
  format %{ "CMPXCHG $newval, [$mem_ptr], $oldval @ compareAndSwapB" %}
  ins_encode %{
    Register newval = $newval$$Register;
    Register oldval = $oldval$$Register;
    Register res    = $res$$Register;
    Address  addr(as_Register($mem_ptr$$base), $mem_ptr$$disp);

    __ cmpxchg8(addr, oldval, newval, res, true /* sign */, false /* retold */, true /* acquire */);
  %}
  ins_pipe( long_memory_op );
%}

instruct compareAndSwapS(mRegI res, memory_exclusive mem_ptr, mRegI oldval, mRegI newval) %{
  predicate(UseAMCAS);
  match(Set res (CompareAndSwapS mem_ptr (Binary oldval newval)));
  effect(TEMP_DEF res);
  ins_cost(3 * MEMORY_REF_COST);
  format %{ "CMPXCHG $newval, [$mem_ptr], $oldval @ compareAndSwapS" %}
  ins_encode %{
    Register newval = $newval$$Register;
    Register oldval = $oldval$$Register;
    Register res    = $res$$Register;
    Address  addr(as_Register($mem_ptr$$base), $mem_ptr$$disp);

    __ cmpxchg16(addr, oldval, newval, res, true /* sign */, false /* retold */, true /* acquire */);
  %}
  ins_pipe( long_memory_op );
%}

instruct compareAndSwapI(mRegI res, memory_exclusive mem_ptr, mRegI oldval, mRegI newval) %{
  match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
  effect(TEMP_DEF res);
  ins_cost(3 * MEMORY_REF_COST);
  format %{ "CMPXCHG $newval, [$mem_ptr], $oldval @ compareAndSwapI" %}
  ins_encode %{
    Register newval = $newval$$Register;
    Register oldval = $oldval$$Register;
    Register res    = $res$$Register;
    Address  addr(as_Register($mem_ptr$$base), $mem_ptr$$disp);

    __ cmpxchg32(addr, oldval, newval, res, true /* sign */, false /* retold*/, true /* acquire */);
  %}
  ins_pipe( long_memory_op );
%}

instruct compareAndSwapL(mRegI res, memory_exclusive mem_ptr, mRegL oldval, mRegL newval) %{
  predicate(VM_Version::supports_cx8());
  match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
  effect(TEMP_DEF res);
  ins_cost(3 * MEMORY_REF_COST);
  format %{ "CMPXCHG $newval, [$mem_ptr], $oldval @ compareAndSwapL" %}
  ins_encode %{
    Register newval = $newval$$Register;
    Register oldval = $oldval$$Register;
    Register res    = $res$$Register;
    Address  addr(as_Register($mem_ptr$$base), $mem_ptr$$disp);

    __ cmpxchg(addr, oldval, newval, res, false, true /* acquire */);
  %}
  ins_pipe( long_memory_op );
%}

instruct compareAndSwapP(mRegI res,  memory_exclusive mem_ptr, mRegP oldval, mRegP newval) %{
  match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
  effect(TEMP_DEF res);
  predicate(n->as_LoadStore()->barrier_data() == 0);
  ins_cost(3 * MEMORY_REF_COST);
  format %{ "CMPXCHG $newval, [$mem_ptr], $oldval @ compareAndSwapP" %}
  ins_encode %{
    Register newval = $newval$$Register;
    Register oldval = $oldval$$Register;
    Register res    = $res$$Register;
    Address  addr(as_Register($mem_ptr$$base), $mem_ptr$$disp);

    __ cmpxchg(addr, oldval, newval, res, false, true /* acquire */);
  %}
  ins_pipe( long_memory_op );
%}

instruct compareAndSwapN(mRegI res, indirect mem_ptr, mRegN oldval, mRegN newval) %{
  match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));
  effect(TEMP_DEF res);
  ins_cost(3 * MEMORY_REF_COST);
  format %{ "CMPXCHG $newval, [$mem_ptr], $oldval @ compareAndSwapN" %}
  ins_encode %{
    Register newval = $newval$$Register;
    Register oldval = $oldval$$Register;
    Register res    = $res$$Register;
    Address  addr(as_Register($mem_ptr$$base), $mem_ptr$$disp);

    __ cmpxchg32(addr, oldval, newval, res, false, false, true /* acquire */);
  %}
  ins_pipe( long_memory_op );
%}

instruct get_and_setB(indirect mem, mRegI newv, mRegI prev) %{
  predicate(UseAMBH);
  match(Set prev (GetAndSetB mem newv));
  effect(TEMP_DEF prev);
  ins_cost(2 * MEMORY_REF_COST);
  format %{ "amswap_db_b $prev, $newv, [$mem] @get_and_setB" %}
  ins_encode %{
    Register prev = $prev$$Register;
    Register newv = $newv$$Register;
    Register addr = as_Register($mem$$base);

    __ amswap_db_b(prev, newv, addr);
  %}
  ins_pipe( pipe_serial );
%}

instruct get_and_setS(indirect mem, mRegI newv, mRegI prev) %{
  predicate(UseAMBH);
  match(Set prev (GetAndSetS mem newv));
  effect(TEMP_DEF prev);
  ins_cost(2 * MEMORY_REF_COST);
  format %{ "amswap_db_s $prev, $newv, [$mem] @get_and_setS" %}
  ins_encode %{
    Register prev = $prev$$Register;
    Register newv = $newv$$Register;
    Register addr = as_Register($mem$$base);

    __ amswap_db_h(prev, newv, addr);
  %}
  ins_pipe( pipe_serial );
%}

instruct get_and_setI(indirect mem, mRegI newv, mRegI prev) %{
  match(Set prev (GetAndSetI mem newv));
  effect(TEMP_DEF prev);
  ins_cost(2 * MEMORY_REF_COST);
  format %{ "amswap_db_w $prev, $newv, [$mem] @get_and_setI" %}
  ins_encode %{
    Register prev = $prev$$Register;
    Register newv = $newv$$Register;
    Register addr = as_Register($mem$$base);

    __ amswap_db_w(prev, newv, addr);
  %}
  ins_pipe( pipe_serial );
%}

instruct get_and_setL(indirect mem, mRegL newv, mRegL prev) %{
  match(Set prev (GetAndSetL mem newv));
  effect(TEMP_DEF prev);
  ins_cost(2 * MEMORY_REF_COST);
  format %{ "amswap_db_d $prev, $newv, [$mem] @get_and_setL" %}
  ins_encode %{
    Register prev = $prev$$Register;
    Register newv = $newv$$Register;
    Register addr = as_Register($mem$$base);

    __ amswap_db_d(prev, newv, addr);
  %}
  ins_pipe( pipe_serial );
%}

instruct get_and_setN(indirect mem, mRegN newv, mRegN prev) %{
  match(Set prev (GetAndSetN mem newv));
  ins_cost(2 * MEMORY_REF_COST);
  format %{ "amswap_db_w $prev, $newv, [$mem] @get_and_setN" %}
  ins_encode %{
    Register prev = $prev$$Register;
    Register newv = $newv$$Register;
    Register addr = as_Register($mem$$base);

    __ amswap_db_w(AT, newv, addr);
    __ bstrpick_d(prev, AT, 31, 0);
  %}
  ins_pipe( pipe_serial );
%}

instruct get_and_setP(indirect mem, mRegP newv, mRegP prev) %{
  match(Set prev (GetAndSetP mem newv));
  effect(TEMP_DEF prev);
  ins_cost(2 * MEMORY_REF_COST);
  format %{ "amswap_db_d $prev, $newv, [$mem] @get_and_setP" %}
  ins_encode %{
    Register prev = $prev$$Register;
    Register newv = $newv$$Register;
    Register addr = as_Register($mem$$base);

    __ amswap_db_d(prev, newv, addr);
  %}
  ins_pipe( pipe_serial );
%}

instruct get_and_addL(indirect mem, mRegL newval, mRegL incr) %{
  match(Set newval (GetAndAddL mem incr));
  effect(TEMP_DEF newval);
  ins_cost(2 * MEMORY_REF_COST + 1);
  format %{ "amadd_db_d $newval, [$mem], $incr @get_and_addL" %}
  ins_encode %{
    Register newv = $newval$$Register;
    Register incr = $incr$$Register;
    Register addr = as_Register($mem$$base);

    __ amadd_db_d(newv, incr, addr);
  %}
  ins_pipe( pipe_serial );
%}

instruct get_and_addL_no_res(indirect mem, Universe dummy, mRegL incr) %{
  predicate(n->as_LoadStore()->result_not_used());
  match(Set dummy (GetAndAddL mem incr));
  ins_cost(2 * MEMORY_REF_COST);
  format %{ "amadd_db_d [$mem], $incr @get_and_addL_no_res" %}
  ins_encode %{
    __ amadd_db_d(R0, $incr$$Register, as_Register($mem$$base));
  %}
  ins_pipe( pipe_serial );
%}

instruct get_and_addI(indirect mem, mRegI newval, mRegIorL2I incr) %{
  match(Set newval (GetAndAddI mem incr));
  effect(TEMP_DEF newval);
  ins_cost(2 * MEMORY_REF_COST + 1);
  format %{ "amadd_db_w $newval, [$mem], $incr @get_and_addI" %}
  ins_encode %{
    Register newv = $newval$$Register;
    Register incr = $incr$$Register;
    Register addr = as_Register($mem$$base);

    __ amadd_db_w(newv, incr, addr);
  %}
  ins_pipe( pipe_serial );
%}

instruct get_and_addI_no_res(indirect mem, Universe dummy, mRegIorL2I incr) %{
  predicate(n->as_LoadStore()->result_not_used());
  match(Set dummy (GetAndAddI mem incr));
  ins_cost(2 * MEMORY_REF_COST);
  format %{ "amadd_db_w [$mem], $incr @get_and_addI_no_res" %}
  ins_encode %{
    __ amadd_db_w(R0, $incr$$Register, as_Register($mem$$base));
  %}
  ins_pipe( pipe_serial );
%}

instruct get_and_addB(indirect mem, mRegI newval, mRegIorL2I incr) %{
  predicate(UseAMBH);
  match(Set newval (GetAndAddB mem incr));
  effect(TEMP_DEF newval);
  ins_cost(2 * MEMORY_REF_COST + 1);
  format %{ "amadd_db_b $newval, [$mem], $incr @get_and_addB" %}
  ins_encode %{
    Register newv = $newval$$Register;
    Register incr = $incr$$Register;
    Register addr = as_Register($mem$$base);

    __ amadd_db_b(newv, incr, addr);
  %}
  ins_pipe( pipe_serial );
%}

instruct get_and_addB_no_res(indirect mem, Universe dummy, mRegIorL2I incr) %{
  predicate(UseAMBH);
  predicate(n->as_LoadStore()->result_not_used());
  match(Set dummy (GetAndAddB mem incr));
  ins_cost(2 * MEMORY_REF_COST);
  format %{ "amadd_db_b [$mem], $incr @get_and_addB_no_res" %}
  ins_encode %{
    __ amadd_db_b(R0, $incr$$Register, as_Register($mem$$base));
  %}
  ins_pipe( pipe_serial );
%}

instruct get_and_addS(indirect mem, mRegI newval, mRegIorL2I incr) %{
  predicate(UseAMBH);
  match(Set newval (GetAndAddS mem incr));
  effect(TEMP_DEF newval);
  ins_cost(2 * MEMORY_REF_COST + 1);
  format %{ "amadd_db_s $newval, [$mem], $incr @get_and_addS" %}
  ins_encode %{
    Register newv = $newval$$Register;
    Register incr = $incr$$Register;
    Register addr = as_Register($mem$$base);

    __ amadd_db_h(newv, incr, addr);
  %}
  ins_pipe( pipe_serial );
%}

instruct get_and_addS_no_res(indirect mem, Universe dummy, mRegIorL2I incr) %{
  predicate(UseAMBH);
  predicate(n->as_LoadStore()->result_not_used());
  match(Set dummy (GetAndAddS mem incr));
  ins_cost(2 * MEMORY_REF_COST);
  format %{ "amadd_db_s [$mem], $incr @get_and_addS_no_res" %}
  ins_encode %{
    __ amadd_db_h(R0, $incr$$Register, as_Register($mem$$base));
  %}
  ins_pipe( pipe_serial );
%}

instruct compareAndExchangeB(mRegI res, memory_exclusive mem, mRegI oldval, mRegI newval) %{
  predicate(UseAMCAS);
  match(Set res (CompareAndExchangeB mem (Binary oldval newval)));
  ins_cost(2 * MEMORY_REF_COST);
  effect(TEMP_DEF res);
  format %{
    "cmpxchg8 $res = $mem, $oldval, $newval\t# if $mem == $oldval then $mem <-- $newval @compareAndExchangeB"
  %}
  ins_encode %{
    Register newval = $newval$$Register;
    Register oldval = $oldval$$Register;
    Register res    = $res$$Register;
    Address  addr(as_Register($mem$$base), $mem$$disp);

    __ cmpxchg8(addr, oldval, newval, res, true /* sign */, false /* retold */, true /* acquire */, false /* weak */, true /* exchange */);
  %}
  ins_pipe( pipe_slow );
%}

instruct compareAndExchangeS(mRegI res, memory_exclusive mem, mRegI oldval, mRegI newval) %{
  predicate(UseAMCAS);
  match(Set res (CompareAndExchangeS mem (Binary oldval newval)));
  ins_cost(2 * MEMORY_REF_COST);
  effect(TEMP_DEF res);
  format %{
    "cmpxchg16 $res = $mem, $oldval, $newval\t# if $mem == $oldval then $mem <-- $newval @compareAndExchangeS"
  %}
  ins_encode %{
    Register newval = $newval$$Register;
    Register oldval = $oldval$$Register;
    Register res    = $res$$Register;
    Address  addr(as_Register($mem$$base), $mem$$disp);

    __ cmpxchg16(addr, oldval, newval, res, true /* sign */, false /* retold */, true /* acquire */, false /* weak */, true /* exchange */);
  %}
  ins_pipe( pipe_slow );
%}

instruct compareAndExchangeI(mRegI res, memory_exclusive mem, mRegI oldval, mRegI newval) %{

  match(Set res (CompareAndExchangeI mem (Binary oldval newval)));
  ins_cost(2 * MEMORY_REF_COST);
  effect(TEMP_DEF res);
  format %{
    "CMPXCHG $res = $mem, $oldval, $newval\t# if $mem == $oldval then $mem <-- $newval @compareAndExchangeI"
  %}
  ins_encode %{
    Register newval = $newval$$Register;
    Register oldval = $oldval$$Register;
    Register res    = $res$$Register;
    Address  addr(as_Register($mem$$base), $mem$$disp);

    __ cmpxchg32(addr, oldval, newval, res, true /* sign */, false /* retold */, true /* acquire */, false /* weak */, true /* exchange */);
  %}
  ins_pipe( pipe_slow );
%}

instruct compareAndExchangeL(mRegL res, memory_exclusive mem, mRegL oldval, mRegL newval) %{

  match(Set res (CompareAndExchangeL mem (Binary oldval newval)));
  ins_cost(2 * MEMORY_REF_COST);
  effect(TEMP_DEF res);
  format %{
    "CMPXCHG $res = $mem, $oldval, $newval\t# if $mem == $oldval then $mem <-- $newval @compareAndExchangeL"
  %}
  ins_encode %{
    Register newval = $newval$$Register;
    Register oldval = $oldval$$Register;
    Register res    = $res$$Register;
    Address  addr(as_Register($mem$$base), $mem$$disp);

    __ cmpxchg(addr, oldval, newval, res, false /* retold */, true /* acquire */, false /* weak */, true /* exchange */);
  %}
  ins_pipe( pipe_slow );
%}

instruct compareAndExchangeP(mRegP res, memory_exclusive mem, mRegP oldval, mRegP newval) %{
  predicate(n->as_LoadStore()->barrier_data() == 0);
  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));
  ins_cost(2 * MEMORY_REF_COST);
  effect(TEMP_DEF res);
  format %{
    "CMPXCHG $res = $mem, $oldval, $newval\t# if $mem == $oldval then $mem <-- $newval @compareAndExchangeP"
  %}
  ins_encode %{
    Register newval = $newval$$Register;
    Register oldval = $oldval$$Register;
    Register res    = $res$$Register;
    Address  addr(as_Register($mem$$base), $mem$$disp);

    __ cmpxchg(addr, oldval, newval, res, false /* retold */, true /* acquire */, false /* weak */, true /* exchange */);
  %}
  ins_pipe( pipe_slow );
%}

instruct compareAndExchangeN(mRegN res, memory_exclusive mem, mRegN oldval, mRegN newval) %{

  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));
  ins_cost(2 * MEMORY_REF_COST);
  effect(TEMP_DEF res);
  format %{
    "CMPXCHG $res = $mem, $oldval, $newval\t# if $mem == $oldval then $mem <-- $newval @compareAndExchangeN"
  %}
  ins_encode %{
    Register newval = $newval$$Register;
    Register oldval = $oldval$$Register;
    Register res    = $res$$Register;
    Address  addr(as_Register($mem$$base), $mem$$disp);

    __ cmpxchg32(addr, oldval, newval, res, false /* sign */, false /* retold */, true /* acquire */, false /* weak */, true /* exchange */);
  %}
  ins_pipe( pipe_slow );
%}

instruct weakCompareAndSwapB(mRegI res, memory_exclusive mem, mRegI oldval, mRegI newval) %{
  predicate(UseAMCAS);
  match(Set res (WeakCompareAndSwapB mem (Binary oldval newval)));
  effect(TEMP_DEF res);
  ins_cost(2 * MEMORY_REF_COST);
  format %{
    "CMPXCHG $res = $mem, $oldval, $newval\t# if $mem == $oldval then $mem <-- $newval @weakCompareAndSwapB"
  %}
  ins_encode %{
    Register newval = $newval$$Register;
    Register oldval = $oldval$$Register;
    Register res    = $res$$Register;
    Address  addr(as_Register($mem$$base), $mem$$disp);

    __ cmpxchg8(addr, oldval, newval, res, true /* sign */, false /* retold */, true /* acquire */, true /* weak */, false /* exchange */);
  %}
  ins_pipe( pipe_slow );
%}

instruct weakCompareAndSwapS(mRegI res, memory_exclusive mem, mRegI oldval, mRegI newval) %{
  predicate(UseAMCAS);
  match(Set res (WeakCompareAndSwapS mem (Binary oldval newval)));
  effect(TEMP_DEF res);
  ins_cost(2 * MEMORY_REF_COST);
  format %{
    "CMPXCHG $res = $mem, $oldval, $newval\t# if $mem == $oldval then $mem <-- $newval @weakCompareAndSwapS"
  %}
  ins_encode %{
    Register newval = $newval$$Register;
    Register oldval = $oldval$$Register;
    Register res    = $res$$Register;
    Address  addr(as_Register($mem$$base), $mem$$disp);

    __ cmpxchg16(addr, oldval, newval, res, true /* sign */, false /* retold */, true /* acquire */, true /* weak */, false /* exchange */);
  %}
  ins_pipe( pipe_slow );
%}

instruct weakCompareAndSwapI(mRegI res, memory_exclusive mem, mRegI oldval, mRegI newval) %{

  match(Set res (WeakCompareAndSwapI mem (Binary oldval newval)));
  effect(TEMP_DEF res);
  ins_cost(2 * MEMORY_REF_COST);
  format %{
    "CMPXCHG $res = $mem, $oldval, $newval\t# if $mem == $oldval then $mem <-- $newval @weakCompareAndSwapI"
  %}
  ins_encode %{
    Register newval = $newval$$Register;
    Register oldval = $oldval$$Register;
    Register res    = $res$$Register;
    Address  addr(as_Register($mem$$base), $mem$$disp);

    __ cmpxchg32(addr, oldval, newval, res, true /* sign */, false /* retold */, true /* acquire */, true /* weak */, false /* exchange */);
  %}
  ins_pipe( pipe_slow );
%}

instruct weakCompareAndSwapL(mRegI res, memory_exclusive mem, mRegL oldval, mRegL newval) %{

  match(Set res (WeakCompareAndSwapL mem (Binary oldval newval)));
  effect(TEMP_DEF res);
  ins_cost(2 * MEMORY_REF_COST);
  format %{
    "CMPXCHG $res = $mem, $oldval, $newval\t# if $mem == $oldval then $mem <-- $newval @WeakCompareAndSwapL"
  %}
  ins_encode %{
    Register newval = $newval$$Register;
    Register oldval = $oldval$$Register;
    Register res    = $res$$Register;
    Address  addr(as_Register($mem$$base), $mem$$disp);

    __ cmpxchg(addr, oldval, newval, res, false /* retold */, true /* acquire */, true /* weak */, false /* exchange */);
  %}
  ins_pipe( pipe_slow );
%}

instruct weakCompareAndSwapP(mRegI res,  memory_exclusive mem, mRegP oldval, mRegP newval) %{
  predicate((((CompareAndSwapNode*)n)->order() != MemNode::acquire && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst) && n->as_LoadStore()->barrier_data() == 0);
  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));
  effect(TEMP_DEF res);
  ins_cost(MEMORY_REF_COST);
  format %{
    "CMPXCHG $res = $mem, $oldval, $newval\t# if $mem == $oldval then $mem <-- $newval @weakCompareAndSwapP"
  %}
  ins_encode %{
    Register newval = $newval$$Register;
    Register oldval = $oldval$$Register;
    Register res    = $res$$Register;
    Address  addr(as_Register($mem$$base), $mem$$disp);

  __ cmpxchg(addr, oldval, newval, res, false /* retold */, false /* acquire */, true /* weak */, false /* exchange */);
  %}
  ins_pipe( pipe_slow );
%}

instruct weakCompareAndSwapP_acq(mRegI res,  memory_exclusive mem, mRegP oldval, mRegP newval) %{
  predicate(n->as_LoadStore()->barrier_data() == 0);
  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));
  effect(TEMP_DEF res);
  ins_cost(2 * MEMORY_REF_COST);
  format %{
    "CMPXCHG $res = $mem, $oldval, $newval\t# if $mem == $oldval then $mem <-- $newval @weakCompareAndSwapP"
  %}
  ins_encode %{
    Register newval = $newval$$Register;
    Register oldval = $oldval$$Register;
    Register res    = $res$$Register;
    Address  addr(as_Register($mem$$base), $mem$$disp);

    __ cmpxchg(addr, oldval, newval, res, false /* retold */, true /* acquire */, true /* weak */, false /* exchange */);
  %}
  ins_pipe( pipe_slow );
%}

instruct weakCompareAndSwapN(mRegI res, memory_exclusive mem, mRegN oldval, mRegN newval) %{

  match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));
  effect(TEMP_DEF res);
  ins_cost(2 * MEMORY_REF_COST);
  format %{
    "CMPXCHG $res = $mem, $oldval, $newval\t# if $mem == $oldval then $mem <-- $newval @weakCompareAndSwapN"
  %}
  ins_encode %{
    Register newval = $newval$$Register;
    Register oldval = $oldval$$Register;
    Register res    = $res$$Register;
    Address  addr(as_Register($mem$$base), $mem$$disp);

    __ cmpxchg32(addr, oldval, newval, res, false /* sign */, false /* retold */, true /* acquire */, true /* weak */, false /* exchange */);
  %}
  ins_pipe( pipe_slow );
%}

//----------Max and Min--------------------------------------------------------

// Min Register with Register (generic version)
instruct minI_Reg_Reg(mRegI dst, mRegI src) %{
  match(Set dst (MinI dst src));
  //effect(KILL flags);
  ins_cost(80);

  format %{ "MIN    $dst, $src @minI_Reg_Reg" %}
  ins_encode %{
    Register dst   = $dst$$Register;
    Register src   = $src$$Register;

    __ slt(AT, src, dst);
    __ masknez(dst, dst, AT);
    __ maskeqz(AT, src, AT);
    __ OR(dst, dst, AT);
  %}

  ins_pipe( pipe_slow );
%}

// Max Register with Register (generic version)
instruct maxI_Reg_Reg(mRegI dst, mRegI src) %{
  match(Set dst (MaxI dst src));
  ins_cost(80);

  format %{ "MAX    $dst, $src @maxI_Reg_Reg" %}

  ins_encode %{
    Register dst   = $dst$$Register;
    Register src   = $src$$Register;

    __ slt(AT, dst, src);
    __ masknez(dst, dst, AT);
    __ maskeqz(AT, src, AT);
    __ OR(dst, dst, AT);
  %}

  ins_pipe( pipe_slow );
%}

instruct maxI_Reg_zero(mRegI dst, immI_0 zero) %{
  match(Set dst (MaxI dst zero));
  ins_cost(50);

  format %{ "MAX    $dst, 0 @maxI_Reg_zero" %}

  ins_encode %{
    Register dst   = $dst$$Register;

    __ slt(AT, dst, R0);
    __ masknez(dst, dst, AT);
  %}

  ins_pipe( pipe_slow );
%}

// Math.max(FF)F
instruct maxF_reg_reg(regF dst, regF src1, regF src2) %{
  match(Set dst (MaxF src1 src2));
  effect(TEMP_DEF dst);

  format %{ "fmaxs   $dst, $src1, $src2 @maxF_reg_reg" %}
  ins_encode %{
    FloatRegister src1 = as_FloatRegister($src1$$reg);
    FloatRegister src2 = as_FloatRegister($src2$$reg);
    FloatRegister dst = as_FloatRegister($dst$$reg);

    __ fmax_s(dst, src1, src2);
    __ fcmp_cun_s(fcc0, src1, src1);
    __ fsel(dst, dst, src1, fcc0);
    __ fcmp_cun_s(fcc0, src2, src2);
    __ fsel(dst, dst, src2, fcc0);
  %}

  ins_pipe( pipe_slow );
%}

// Math.min(FF)F
instruct minF_reg_reg(regF dst, regF src1, regF src2) %{
  match(Set dst (MinF src1 src2));
  effect(TEMP_DEF dst);

  format %{ "fmins   $dst, $src1, $src2 @minF_reg_reg" %}
  ins_encode %{
    FloatRegister src1 = as_FloatRegister($src1$$reg);
    FloatRegister src2 = as_FloatRegister($src2$$reg);
    FloatRegister dst = as_FloatRegister($dst$$reg);

    __ fmin_s(dst, src1, src2);
    __ fcmp_cun_s(fcc0, src1, src1);
    __ fsel(dst, dst, src1, fcc0);
    __ fcmp_cun_s(fcc0, src2, src2);
    __ fsel(dst, dst, src2, fcc0);
  %}

  ins_pipe( pipe_slow );
%}

// Math.max(DD)D
instruct maxD_reg_reg(regD dst, regD src1, regD src2) %{
  match(Set dst (MaxD src1 src2));
  effect(TEMP_DEF dst);

  format %{ "fmaxd   $dst, $src1, $src2 @maxD_reg_reg" %}
  ins_encode %{
    FloatRegister src1 = as_FloatRegister($src1$$reg);
    FloatRegister src2 = as_FloatRegister($src2$$reg);
    FloatRegister dst = as_FloatRegister($dst$$reg);

    __ fmax_d(dst, src1, src2);
    __ fcmp_cun_d(fcc0, src1, src1);
    __ fsel(dst, dst, src1, fcc0);
    __ fcmp_cun_d(fcc0, src2, src2);
    __ fsel(dst, dst, src2, fcc0);
  %}

  ins_pipe( pipe_slow );
%}

// Math.min(DD)D
instruct minD_reg_reg(regD dst, regD src1, regD src2) %{
  match(Set dst (MinD src1 src2));
  effect(TEMP_DEF dst);

  format %{ "fmind   $dst, $src1, $src2 @minD_reg_reg" %}
  ins_encode %{
    FloatRegister src1 = as_FloatRegister($src1$$reg);
    FloatRegister src2 = as_FloatRegister($src2$$reg);
    FloatRegister dst = as_FloatRegister($dst$$reg);

    __ fmin_d(dst, src1, src2);
    __ fcmp_cun_d(fcc0, src1, src1);
    __ fsel(dst, dst, src1, fcc0);
    __ fcmp_cun_d(fcc0, src2, src2);
    __ fsel(dst, dst, src2, fcc0);
  %}

  ins_pipe( pipe_slow );
%}

// Float.isInfinite
instruct isInfiniteF_reg_reg(mRegI dst, regF src)
%{
  match(Set dst (IsInfiniteF src));
  format %{ "isInfinite    $dst, $src @isInfiniteF_reg_reg" %}
  ins_encode %{
    FloatRegister src = $src$$FloatRegister;
    Register      dst = $dst$$Register;

    __ fclass_s(fscratch, src);
    __ movfr2gr_s(dst, fscratch);
    __ andi(dst, dst, 0b0001000100);
    __ slt(dst, R0, dst);
  %}
  size(16);
  ins_pipe( pipe_slow );
%}

// Double.isInfinite
instruct isInfiniteD_reg_reg(mRegI dst, regD src)
%{
  match(Set dst (IsInfiniteD src));
  format %{ "isInfinite    $dst, $src @isInfiniteD_reg_reg" %}
  ins_encode %{
    FloatRegister src = $src$$FloatRegister;
    Register      dst = $dst$$Register;

    __ fclass_d(fscratch, src);
    __ movfr2gr_d(dst, fscratch);
    __ andi(dst, dst, 0b0001000100);
    __ slt(dst, R0, dst);
  %}
  size(16);
  ins_pipe( pipe_slow );
%}

instruct isInfiniteF_cmovI(mRegI dst, mRegI src1, mRegI src2, regF op, immI_0 zero, cmpOp cop)
%{
  match(Set dst (CMoveI (Binary cop (CmpI (IsInfiniteF op) zero)) (Binary src1 src2)));
  format %{ "isInfinite_cmovI    $dst, $src1, $src2, $op, $cop @isInfiniteF_cmovI" %}
  ins_encode %{
    Register      src1 = $src1$$Register;
    Register      src2 = $src2$$Register;
    Register      dst  = $dst$$Register;
    FloatRegister op   = $op$$FloatRegister;
    int         flag = $cop$$cmpcode;

    __ fclass_s(fscratch, op);
    __ movfr2gr_s(AT, fscratch);
    __ andi(AT, AT, 0b0001000100);
    switch(flag) {
      case 0x01: // EQ
        __ maskeqz(dst, src1, AT);
        __ masknez(AT, src2, AT);
        break;
      case 0x02: // NE
        __ masknez(dst, src1, AT);
        __ maskeqz(AT, src2, AT);
        break;
      default:
        ShouldNotReachHere();
    }
    __ orr(dst, dst, AT);
  %}
  size(24);
  ins_pipe( pipe_slow );
%}

instruct isInfiniteD_cmovI(mRegI dst, mRegI src1, mRegI src2, regD op, immI_0 zero, cmpOp cop)
%{
  match(Set dst (CMoveI (Binary cop (CmpI (IsInfiniteD op) zero)) (Binary src1 src2)));
  format %{ "isInfinite_cmovI    $dst, $src1, $src2, $op, $cop @isInfiniteD_cmovI" %}
  ins_encode %{
    Register      src1 = $src1$$Register;
    Register      src2 = $src2$$Register;
    Register      dst  = $dst$$Register;
    FloatRegister op   = $op$$FloatRegister;
    int           flag = $cop$$cmpcode;

    __ fclass_d(fscratch, op);
    __ movfr2gr_d(AT, fscratch);
    __ andi(AT, AT, 0b0001000100);
    switch(flag) {
      case 0x01: // EQ
        __ maskeqz(dst, src1, AT);
        __ masknez(AT, src2, AT);
        break;
      case 0x02: // NE
        __ masknez(dst, src1, AT);
        __ maskeqz(AT, src2, AT);
        break;
      default:
        ShouldNotReachHere();
    }
    __ orr(dst, dst, AT);
  %}
  size(24);
  ins_pipe( pipe_slow );
%}

// Float.isFinite
instruct isFiniteF_reg_reg(mRegI dst, regF src)
%{
  match(Set dst (IsFiniteF src));
  format %{ "isFinite    $dst, $src @isFiniteF_reg_reg" %}
  ins_encode %{
    FloatRegister src = $src$$FloatRegister;
    Register      dst = $dst$$Register;

    __ fclass_s(fscratch, src);
    __ movfr2gr_s(dst, fscratch);
    __ andi(dst, dst, 0b1110111000);
    __ slt(dst, R0, dst);
  %}
  size(16);
  ins_pipe( pipe_slow );
%}

// Double.isFinite
instruct isFiniteD_reg_reg(mRegI dst, regD src)
%{
  match(Set dst (IsFiniteD src));
  format %{ "isFinite    $dst, $src @isFiniteD_reg_reg" %}
  ins_encode %{
    FloatRegister src = $src$$FloatRegister;
    Register      dst = $dst$$Register;

    __ fclass_d(fscratch, src);
    __ movfr2gr_d(dst, fscratch);
    __ andi(dst, dst, 0b1110111000);
    __ slt(dst, R0, dst);
  %}
  size(16);
  ins_pipe( pipe_slow );
%}

instruct isFiniteF_cmovI(mRegI dst, mRegI src1, mRegI src2, regF op, immI_0 zero, cmpOp cop)
%{
  match(Set dst (CMoveI (Binary cop (CmpI (IsFiniteF op) zero)) (Binary src1 src2)));
  format %{ "isFinite_cmovI    $dst, $src1, $src2, $op, $cop @isFiniteF_cmovI" %}
  ins_encode %{
    Register      src1 = $src1$$Register;
    Register      src2 = $src2$$Register;
    Register      dst  = $dst$$Register;
    FloatRegister op   = $op$$FloatRegister;
    int         flag = $cop$$cmpcode;

    __ fclass_s(fscratch, op);
    __ movfr2gr_s(AT, fscratch);
    __ andi(dst, dst, 0b1110111000);
    switch(flag) {
      case 0x01: // EQ
        __ maskeqz(dst, src1, AT);
        __ masknez(AT, src2, AT);
        break;
      case 0x02: // NE
        __ masknez(dst, src1, AT);
        __ maskeqz(AT, src2, AT);
        break;
      default:
        ShouldNotReachHere();
    }
    __ orr(dst, dst, AT);
  %}
  size(24);
  ins_pipe( pipe_slow );
%}

instruct isFiniteD_cmovI(mRegI dst, mRegI src1, mRegI src2, regD op, immI_0 zero, cmpOp cop)
%{
  match(Set dst (CMoveI (Binary cop (CmpI (IsFiniteD op) zero)) (Binary src1 src2)));
  format %{ "isFinite_cmovI    $dst, $src1, $src2, $op, $cop @isFiniteD_cmovI" %}
  ins_encode %{
    Register      src1 = $src1$$Register;
    Register      src2 = $src2$$Register;
    Register      dst  = $dst$$Register;
    FloatRegister op   = $op$$FloatRegister;
    int           flag = $cop$$cmpcode;

    __ fclass_d(fscratch, op);
    __ movfr2gr_d(AT, fscratch);
    __ andi(dst, dst, 0b1110111000);
    switch(flag) {
      case 0x01: // EQ
        __ maskeqz(dst, src1, AT);
        __ masknez(AT, src2, AT);
        break;
      case 0x02: // NE
        __ masknez(dst, src1, AT);
        __ maskeqz(AT, src2, AT);
        break;
      default:
        ShouldNotReachHere();
    }
    __ orr(dst, dst, AT);
  %}
  size(24);
  ins_pipe( pipe_slow );
%}

instruct combine_i2l(mRegL dst, mRegI src1, immL_MaxUI mask, mRegI src2, immI_32 shift32)
%{
  match(Set dst (OrL (AndL (ConvI2L src1) mask) (LShiftL (ConvI2L src2) shift32)));

  format %{ "combine_i2l    $dst, $src2(H), $src1(L) @ combine_i2l" %}
  ins_encode %{
    Register dst  = $dst$$Register;
    Register src1 = $src1$$Register;
    Register src2 = $src2$$Register;

    if (src1 == dst) {
       __ bstrins_d(dst, src2, 63, 32);
    } else if (src2 == dst) {
       __ slli_d(dst, dst, 32);
       __ bstrins_d(dst, src1, 31, 0);
    } else {
       __ bstrpick_d(dst, src1, 31, 0);
       __ bstrins_d(dst, src2, 63, 32);
    }
  %}
  ins_pipe( pipe_slow );
%}

// Zero-extend convert int to long
instruct convI2L_reg_reg_zex(mRegL dst, mRegI src, immL_MaxUI mask)
%{
  match(Set dst (AndL (ConvI2L src) mask));

  format %{ "movl    $dst, $src\t# i2l zero-extend @ convI2L_reg_reg_zex" %}
  ins_encode %{
    Register dst = $dst$$Register;
    Register src = $src$$Register;

    __ bstrpick_d(dst, src, 31, 0);
  %}
  ins_pipe( ialu_reg_reg );
%}

instruct convL2I2L_reg_reg_zex(mRegL dst, mRegL src, immL_MaxUI mask)
%{
  match(Set dst (AndL (ConvI2L (ConvL2I src)) mask));

  format %{ "movl    $dst, $src\t# i2l zero-extend @ convL2I2L_reg_reg_zex" %}
  ins_encode %{
    Register dst = $dst$$Register;
    Register src = $src$$Register;

    __ bstrpick_d(dst, src, 31, 0);
  %}
  ins_pipe( ialu_reg_reg );
%}

// Match loading integer and casting it to unsigned int in long register.
// LoadI + ConvI2L + AndL 0xffffffff.
instruct loadUI2L_mask(mRegL dst, memory mem, immL_MaxUI mask) %{
  match(Set dst (AndL (ConvI2L (LoadI mem)) mask));

  format %{ "ld_wu     $dst, $mem \t// zero-extend to long @ loadUI2L_mask" %}
  ins_encode %{
    relocInfo::relocType disp_reloc = $mem->disp_reloc();
    assert(disp_reloc == relocInfo::none, "cannot have disp");
    __ loadstore_enc($dst$$Register, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_U_INT);
  %}
  ins_pipe( ialu_load );
%}

// ============================================================================
// Safepoint Instruction
instruct safePoint_poll_tls(mRegP poll) %{
  match(SafePoint poll);
  effect(USE poll);

  ins_cost(125);
  format %{ "ld_w AT, [$poll]\t"
            "Safepoint @ [$poll] : poll for GC" %}
  size(4);
  ins_encode %{
    Register poll_reg = $poll$$Register;

    __ block_comment("Safepoint:");
    __ relocate(relocInfo::poll_type);
    address pre_pc = __ pc();
    __ ld_w(AT, poll_reg, 0);
    assert(nativeInstruction_at(pre_pc)->is_safepoint_poll(), "must emit ld_w AT, [$poll]");
  %}

  ins_pipe( pipe_serial );
%}

//----------BSWAP Instructions-------------------------------------------------
instruct bytes_reverse_int(mRegI dst, mRegIorL2I src) %{
  match(Set dst (ReverseBytesI src));

  format %{ "RevB_I  $dst, $src" %}
  ins_encode %{
    __ bswap_w($dst$$Register, $src$$Register);
  %}
  ins_pipe( ialu_reg_reg );
%}

instruct bytes_reverse_long(mRegL dst, mRegL src) %{
  match(Set dst (ReverseBytesL src));

  format %{ "RevB_L  $dst, $src" %}
  ins_encode %{
    __ revb_d($dst$$Register, $src$$Register);
  %}
  ins_pipe( ialu_reg_reg );
%}

instruct bytes_reverse_unsigned_short(mRegI dst, mRegIorL2I src) %{
  match(Set dst (ReverseBytesUS src));

  format %{ "RevB_US  $dst, $src" %}
  ins_encode %{
    __ bswap_hu($dst$$Register, $src$$Register);
  %}
  ins_pipe( ialu_reg_reg );
%}

instruct bytes_reverse_short(mRegI dst, mRegIorL2I src) %{
  match(Set dst (ReverseBytesS src));

  format %{ "RevB_S  $dst, $src" %}
  ins_encode %{
    __ bswap_h($dst$$Register, $src$$Register);
  %}
  ins_pipe( ialu_reg_reg );
%}

//---------- Zeros Count Instructions ------------------------------------------
// CountLeadingZerosINode CountTrailingZerosINode
instruct countLeadingZerosI(mRegI dst, mRegIorL2I src) %{
  match(Set dst (CountLeadingZerosI src));

  format %{ "clz_w  $dst, $src\t# count leading zeros (int)" %}
  ins_encode %{
    __ clz_w($dst$$Register, $src$$Register);
  %}
  ins_pipe( ialu_reg_reg );
%}

instruct countLeadingZerosL(mRegI dst, mRegL src) %{
  match(Set dst (CountLeadingZerosL src));

  format %{ "clz_d  $dst, $src\t# count leading zeros (long)" %}
  ins_encode %{
    __ clz_d($dst$$Register, $src$$Register);
  %}
  ins_pipe( ialu_reg_reg );
%}

instruct countTrailingZerosI(mRegI dst, mRegIorL2I src) %{
  match(Set dst (CountTrailingZerosI src));

  format %{ "ctz_w    $dst, $src\t# count trailing zeros (int)" %}
  ins_encode %{
    __ ctz_w($dst$$Register, $src$$Register);
  %}
  ins_pipe( ialu_reg_reg );
%}

instruct countTrailingZerosL(mRegI dst, mRegL src) %{
  match(Set dst (CountTrailingZerosL src));

  format %{ "ctz_d    $dst, $src\t# count trailing zeros (long)" %}
  ins_encode %{
    __ ctz_d($dst$$Register, $src$$Register);
  %}
  ins_pipe( ialu_reg_reg );
%}

// --------------- Population Count Instructions ------------------------------
//
instruct popCountI(mRegI dst, mRegIorL2I src) %{
  predicate(UsePopCountInstruction);
  match(Set dst (PopCountI src));

  format %{ "vinsgr2vr_w    fscratch, $src, 0\n\t"
            "vpcnt_w        fscratch, fscratch\n\t"
            "vpickve2gr_wu  $dst, fscratch, 0\n\t# @popCountI" %}

  ins_encode %{
    __ vinsgr2vr_w(fscratch, $src$$Register, 0);
    __ vpcnt_w(fscratch, fscratch);
    __ vpickve2gr_wu($dst$$Register, fscratch, 0);
  %}

  ins_pipe( pipe_slow );
%}

instruct popCountI_mem(mRegI dst, memory mem) %{
  predicate(UsePopCountInstruction);
  match(Set dst (PopCountI (LoadI mem)));

  format %{ "fld_s          fscratch, $mem, 0\n\t"
            "vpcnt_w        fscratch, fscratch\n\t"
            "vpickve2gr_wu  $dst, fscratch, 0\n\t# @popCountI_mem" %}

  ins_encode %{
    __ loadstore_enc(fscratch, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_FLOAT);
    __ vpcnt_w(fscratch, fscratch);
    __ vpickve2gr_wu($dst$$Register, fscratch, 0);
  %}

  ins_pipe( pipe_slow );
%}

// Note: Long.bitCount(long) returns an int.
instruct popCountL(mRegI dst, mRegL src) %{
  predicate(UsePopCountInstruction);
  match(Set dst (PopCountL src));

  format %{ "vinsgr2vr_d    fscratch, $src, 0\n\t"
            "vpcnt_d        fscratch, fscratch\n\t"
            "vpickve2gr_wu  $dst, fscratch, 0\n\t# @popCountL" %}

  ins_encode %{
    __ vinsgr2vr_d(fscratch, $src$$Register, 0);
    __ vpcnt_d(fscratch, fscratch);
    __ vpickve2gr_wu($dst$$Register, fscratch, 0);
  %}

  ins_pipe( pipe_slow );
%}

instruct popCountL_mem(mRegI dst, memory mem) %{
  predicate(UsePopCountInstruction);
  match(Set dst (PopCountL (LoadL mem)));

  format %{ "fld_d          fscratch, $mem, 0\n\t"
            "vpcnt_d        fscratch, fscratch\n\t"
            "vpickve2gr_wu  $dst, fscratch, 0\n\t# @popCountL_mem" %}

  ins_encode %{
    __ loadstore_enc(fscratch, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_DOUBLE);
    __ vpcnt_d(fscratch, fscratch);
    __ vpickve2gr_wu($dst$$Register, fscratch, 0);
  %}

  ins_pipe( pipe_slow );
%}

// ====================VECTOR INSTRUCTIONS=====================================

// --------------------------------- Load -------------------------------------

instruct loadV(vReg dst, memory mem) %{
  match(Set dst (LoadVector mem));
  format %{ "(x)vload    $dst, $mem\t# @loadV" %}
  ins_encode %{
    switch (Matcher::vector_length_in_bytes(this)) {
      case  4: __ loadstore_enc($dst$$FloatRegister, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_FLOAT);   break;
      case  8: __ loadstore_enc($dst$$FloatRegister, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_DOUBLE);  break;
      case 16: __ loadstore_enc($dst$$FloatRegister, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_VECTORX); break;
      case 32: __ loadstore_enc($dst$$FloatRegister, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::LOAD_VECTORY); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// --------------------------------- Store ------------------------------------

instruct storeV(memory mem, vReg src) %{
  match(Set mem (StoreVector mem src));
  format %{ "(x)vstore    $src, $mem\t# @storeV" %}
  ins_encode %{
    switch (Matcher::vector_length_in_bytes(this, $src)) {
      case  4: __ loadstore_enc($src$$FloatRegister, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::STORE_FLOAT);   break;
      case  8: __ loadstore_enc($src$$FloatRegister, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::STORE_DOUBLE);  break;
      case 16: __ loadstore_enc($src$$FloatRegister, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::STORE_VECTORX); break;
      case 32: __ loadstore_enc($src$$FloatRegister, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp, C2_MacroAssembler::STORE_VECTORY); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// ------------------------------- Replicate ----------------------------------

instruct replV(vReg dst, mRegI src) %{
  match(Set dst (ReplicateB src));
  match(Set dst (ReplicateS src));
  match(Set dst (ReplicateI src));
  format %{ "(x)vreplgr2vr    $dst, $src\t# @replV" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_BYTE : __ xvreplgr2vr_b($dst$$FloatRegister, $src$$Register); break;
        case T_SHORT: __ xvreplgr2vr_h($dst$$FloatRegister, $src$$Register); break;
        case T_INT  : __ xvreplgr2vr_w($dst$$FloatRegister, $src$$Register); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_BYTE : __ vreplgr2vr_b($dst$$FloatRegister, $src$$Register); break;
        case T_SHORT: __ vreplgr2vr_h($dst$$FloatRegister, $src$$Register); break;
        case T_INT  : __ vreplgr2vr_w($dst$$FloatRegister, $src$$Register); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct replVL(vReg dst, mRegL src) %{
  match(Set dst (ReplicateL src));
  format %{ "(x)vreplgr2vr.d    $dst, $src\t# @replVL" %}
  ins_encode %{
    switch (Matcher::vector_length(this)) {
      case 2: __  vreplgr2vr_d($dst$$FloatRegister, $src$$Register); break;
      case 4: __ xvreplgr2vr_d($dst$$FloatRegister, $src$$Register); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct replVF(vReg dst, regF src) %{
  match(Set dst (ReplicateF src));
  format %{ "(x)vreplve0.w    $dst, $src\t# @replVF" %}
  ins_encode %{
    __ vreplvei_w($dst$$FloatRegister, $src$$FloatRegister, 0);
    switch (Matcher::vector_length(this)) {
      case 2:
      case 4: __  vreplvei_w($dst$$FloatRegister, $src$$FloatRegister, 0); break;
      case 8: __ xvreplve0_w($dst$$FloatRegister, $src$$FloatRegister);    break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct replVD(vReg dst, regD src) %{
  match(Set dst (ReplicateD src));
  format %{ "(x)vreplve0.d    $dst, $src\t# @replVD" %}
  ins_encode %{
    switch (Matcher::vector_length(this)) {
      case 2: __  vreplvei_d($dst$$FloatRegister, $src$$FloatRegister, 0); break;
      case 4: __ xvreplve0_d($dst$$FloatRegister, $src$$FloatRegister);    break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct replVB_imm(vReg dst, immI_M128_255 imm) %{
  match(Set dst (ReplicateB imm));
  format %{ "(x)vldi    $dst, $imm\t# @replVB_imm" %}
  ins_encode %{
    switch (Matcher::vector_length(this)) {
      case  4:
      case  8:
      case 16: __  vldi($dst$$FloatRegister, ($imm$$constant & 0xff)); break;
      case 32: __ xvldi($dst$$FloatRegister, ($imm$$constant & 0xff)); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct replV_imm(vReg dst, immI10 imm) %{
  match(Set dst (ReplicateS imm));
  match(Set dst (ReplicateI imm));
  format %{ "(x)vldi    $dst, $imm\t# @replV_imm" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_SHORT: __ xvldi($dst$$FloatRegister, (0b001 << 10 ) | ($imm$$constant & 0x3ff)); break;
        case T_INT  : __ xvldi($dst$$FloatRegister, (0b010 << 10 ) | ($imm$$constant & 0x3ff)); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_SHORT: __ vldi($dst$$FloatRegister, (0b001 << 10 ) | ($imm$$constant & 0x3ff)); break;
        case T_INT  : __ vldi($dst$$FloatRegister, (0b010 << 10 ) | ($imm$$constant & 0x3ff)); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct replVL_imm(vReg dst, immL10 imm) %{
  match(Set dst (ReplicateL imm));
  format %{ "(x)vldi    $dst, $imm\t# @replVL_imm" %}
  ins_encode %{
    switch (Matcher::vector_length(this)) {
      case 2: __  vldi($dst$$FloatRegister, (0b011 << 10 ) | ($imm$$constant & 0x3ff)); break;
      case 4: __ xvldi($dst$$FloatRegister, (0b011 << 10 ) | ($imm$$constant & 0x3ff)); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// --------------------------------- ADD --------------------------------------

instruct addV(vReg dst, vReg src1, vReg src2) %{
  match(Set dst (AddVB src1 src2));
  match(Set dst (AddVS src1 src2));
  match(Set dst (AddVI src1 src2));
  match(Set dst (AddVL src1 src2));
  match(Set dst (AddVF src1 src2));
  match(Set dst (AddVD src1 src2));
  format %{ "(x)vadd    $dst, $src1, $src2\t# @addV" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_BYTE  : __ xvadd_b ($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_SHORT : __ xvadd_h ($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_INT   : __ xvadd_w ($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_LONG  : __ xvadd_d ($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_FLOAT : __ xvfadd_s($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_DOUBLE: __ xvfadd_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_BYTE  : __ vadd_b ($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_SHORT : __ vadd_h ($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_INT   : __ vadd_w ($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_LONG  : __ vadd_d ($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_FLOAT : __ vfadd_s($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_DOUBLE: __ vfadd_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct addV_imm(vReg dst, vReg src, immIU5 imm) %{
  match(Set dst (AddVB src (ReplicateB imm)));
  match(Set dst (AddVS src (ReplicateS imm)));
  match(Set dst (AddVI src (ReplicateI imm)));
  format %{ "(x)vaddi    $dst, $src, $imm\t# @addV_imm" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_BYTE : __ xvaddi_bu($dst$$FloatRegister, $src$$FloatRegister, $imm$$constant); break;
        case T_SHORT: __ xvaddi_hu($dst$$FloatRegister, $src$$FloatRegister, $imm$$constant); break;
        case T_INT  : __ xvaddi_wu($dst$$FloatRegister, $src$$FloatRegister, $imm$$constant); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_BYTE : __ vaddi_bu($dst$$FloatRegister, $src$$FloatRegister, $imm$$constant); break;
        case T_SHORT: __ vaddi_hu($dst$$FloatRegister, $src$$FloatRegister, $imm$$constant); break;
        case T_INT  : __ vaddi_wu($dst$$FloatRegister, $src$$FloatRegister, $imm$$constant); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct addVL_imm(vReg dst, vReg src, immLU5 imm) %{
  match(Set dst (AddVL src (ReplicateL imm)));
  format %{ "(x)vaddi.du    $dst, $src, $imm\t# @addVL_imm" %}
  ins_encode %{
    switch (Matcher::vector_length(this)) {
      case 2: __  vaddi_du($dst$$FloatRegister, $src$$FloatRegister, $imm$$constant); break;
      case 4: __ xvaddi_du($dst$$FloatRegister, $src$$FloatRegister, $imm$$constant); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// --------------------------------- SUB --------------------------------------

instruct subV(vReg dst, vReg src1, vReg src2) %{
  match(Set dst (SubVB src1 src2));
  match(Set dst (SubVS src1 src2));
  match(Set dst (SubVI src1 src2));
  match(Set dst (SubVL src1 src2));
  match(Set dst (SubVF src1 src2));
  match(Set dst (SubVD src1 src2));
  format %{ "(x)vsub    $dst, $src1, $src2\t# @subV" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_BYTE  : __ xvsub_b ($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_SHORT : __ xvsub_h ($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_INT   : __ xvsub_w ($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_LONG  : __ xvsub_d ($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_FLOAT : __ xvfsub_s($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_DOUBLE: __ xvfsub_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_BYTE  : __ vsub_b ($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_SHORT : __ vsub_h ($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_INT   : __ vsub_w ($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_LONG  : __ vsub_d ($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_FLOAT : __ vfsub_s($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_DOUBLE: __ vfsub_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct subV_imm(vReg dst, vReg src, immIU5 imm) %{
  match(Set dst (SubVB src (ReplicateB imm)));
  match(Set dst (SubVS src (ReplicateB imm)));
  match(Set dst (SubVI src (ReplicateB imm)));
  format %{ "(x)vsubi    $dst, $src, $imm\t# @subV_imm" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_BYTE : __ xvsubi_bu($dst$$FloatRegister, $src$$FloatRegister, $imm$$constant); break;
        case T_SHORT: __ xvsubi_hu($dst$$FloatRegister, $src$$FloatRegister, $imm$$constant); break;
        case T_INT  : __ xvsubi_wu($dst$$FloatRegister, $src$$FloatRegister, $imm$$constant); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_BYTE : __ vsubi_bu($dst$$FloatRegister, $src$$FloatRegister, $imm$$constant); break;
        case T_SHORT: __ vsubi_hu($dst$$FloatRegister, $src$$FloatRegister, $imm$$constant); break;
        case T_INT  : __ vsubi_wu($dst$$FloatRegister, $src$$FloatRegister, $imm$$constant); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct subVL_imm(vReg dst, vReg src, immLU5 imm) %{
  match(Set dst (SubVL src (ReplicateL imm)));
  format %{ "(x)vsubi.du    $dst, $src, $imm\t# @subVL_imm" %}
  ins_encode %{
    switch (Matcher::vector_length(this)) {
      case 2: __  vsubi_du($dst$$FloatRegister, $src$$FloatRegister, $imm$$constant); break;
      case 4: __ xvsubi_du($dst$$FloatRegister, $src$$FloatRegister, $imm$$constant); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// --------------------------------- MUL --------------------------------------

instruct mulV(vReg dst, vReg src1, vReg src2) %{
  match(Set dst (MulVB src1 src2));
  match(Set dst (MulVS src1 src2));
  match(Set dst (MulVI src1 src2));
  match(Set dst (MulVL src1 src2));
  match(Set dst (MulVF src1 src2));
  match(Set dst (MulVD src1 src2));
  format %{ "(x)vmul    $dst, $src1, $src2\t# @mulV" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_BYTE  : __ xvmul_b ($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_SHORT : __ xvmul_h ($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_INT   : __ xvmul_w ($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_LONG  : __ xvmul_d ($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_FLOAT : __ xvfmul_s($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_DOUBLE: __ xvfmul_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_BYTE  : __ vmul_b ($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_SHORT : __ vmul_h ($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_INT   : __ vmul_w ($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_LONG  : __ vmul_d ($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_FLOAT : __ vfmul_s($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_DOUBLE: __ vfmul_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

// --------------------------------- DIV --------------------------------------

instruct divV(vReg dst, vReg src1, vReg src2) %{
  match(Set dst (DivVF src1 src2));
  match(Set dst (DivVD src1 src2));
  format %{ "(x)vfdiv    $dst, $src1, $src2\t# @divV" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_FLOAT : __ xvfdiv_s($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_DOUBLE: __ xvfdiv_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_FLOAT : __ vfdiv_s($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_DOUBLE: __ vfdiv_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

// --------------------------------- ABS --------------------------------------

instruct absV(vReg dst, vReg src) %{
  match(Set dst (AbsVB src));
  match(Set dst (AbsVS src));
  match(Set dst (AbsVI src));
  match(Set dst (AbsVL src));
  match(Set dst (AbsVF src));
  match(Set dst (AbsVD src));
  format %{ "(x)vabs    $dst, $src\t# @absV" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      if (!is_floating_point_type(Matcher::vector_element_basic_type(this)))
        __ xvxor_v(fscratch, fscratch, fscratch);
      switch(Matcher::vector_element_basic_type(this)) {
        case T_BYTE  : __ xvabsd_b($dst$$FloatRegister, $src$$FloatRegister, fscratch); break;
        case T_SHORT : __ xvabsd_h($dst$$FloatRegister, $src$$FloatRegister, fscratch); break;
        case T_INT   : __ xvabsd_w($dst$$FloatRegister, $src$$FloatRegister, fscratch); break;
        case T_LONG  : __ xvabsd_d($dst$$FloatRegister, $src$$FloatRegister, fscratch); break;
        case T_FLOAT : __ xvbitclri_w($dst$$FloatRegister, $src$$FloatRegister, 0x1f);  break;
        case T_DOUBLE: __ xvbitclri_d($dst$$FloatRegister, $src$$FloatRegister, 0x3f);  break;
        default:
          ShouldNotReachHere();
      }
    } else {
      if (!is_floating_point_type(Matcher::vector_element_basic_type(this)))
        __ vxor_v(fscratch, fscratch, fscratch);
      switch(Matcher::vector_element_basic_type(this)) {
        case T_BYTE  : __ vabsd_b($dst$$FloatRegister, $src$$FloatRegister, fscratch); break;
        case T_SHORT : __ vabsd_h($dst$$FloatRegister, $src$$FloatRegister, fscratch); break;
        case T_INT   : __ vabsd_w($dst$$FloatRegister, $src$$FloatRegister, fscratch); break;
        case T_LONG  : __ vabsd_d($dst$$FloatRegister, $src$$FloatRegister, fscratch); break;
        case T_FLOAT : __ vbitclri_w($dst$$FloatRegister, $src$$FloatRegister, 0x1f);  break;
        case T_DOUBLE: __ vbitclri_d($dst$$FloatRegister, $src$$FloatRegister, 0x3f);  break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

// --------------------------------- ABS DIFF ---------------------------------

instruct absdV(vReg dst, vReg src1, vReg src2) %{
  match(Set dst (AbsVB (SubVI src1 src2)));
  match(Set dst (AbsVS (SubVI src1 src2)));
  match(Set dst (AbsVI (SubVI src1 src2)));
  match(Set dst (AbsVL (SubVI src1 src2)));
  format %{ "(x)vabsd    $dst, $src1, $src2\t# @absdV" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_BYTE : __ xvabsd_b($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_SHORT: __ xvabsd_h($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_INT  : __ xvabsd_w($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_LONG : __ xvabsd_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_BYTE : __ vabsd_b($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_SHORT: __ vabsd_h($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_INT  : __ vabsd_w($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_LONG : __ vabsd_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

// --------------------------------- MAX --------------------------------------

instruct maxV(vReg dst, vReg src1, vReg src2) %{
  predicate(!(is_floating_point_type(Matcher::vector_element_basic_type(n))));
  match(Set dst (MaxV src1 src2));
  format %{ "(x)vmax    $dst, $src1, $src2\t# @maxV" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BYTE : __ xvmax_b($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_SHORT: __ xvmax_h($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_INT  : __ xvmax_w($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_LONG : __ xvmax_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BYTE : __ vmax_b($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_SHORT: __ vmax_h($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_INT  : __ vmax_w($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_LONG : __ vmax_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct maxVF(vReg dst, vReg src1, vReg src2, vReg tmp) %{
  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT);
  match(Set dst (MaxV src1 src2));
  effect(TEMP_DEF dst, TEMP tmp);
  format %{ "(x)vfmax    $dst, $src1, $src2\t# TEMP($tmp) @maxVF" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      __ xvfmax_s($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
      __ xvxor_v($tmp$$FloatRegister, $tmp$$FloatRegister, $tmp$$FloatRegister);
      __ xvfdiv_s($tmp$$FloatRegister, $tmp$$FloatRegister, $tmp$$FloatRegister);
      __ xvfcmp_cun_s(fscratch, $src1$$FloatRegister, $src2$$FloatRegister);
      __ xvbitsel_v($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister, fscratch);
    } else {
      __ vfmax_s($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
      __ vxor_v($tmp$$FloatRegister, $tmp$$FloatRegister, $tmp$$FloatRegister);
      __ vfdiv_s($tmp$$FloatRegister, $tmp$$FloatRegister, $tmp$$FloatRegister);
      __ vfcmp_cun_s(fscratch, $src1$$FloatRegister, $src2$$FloatRegister);
      __ vbitsel_v($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister, fscratch);
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct maxVD(vReg dst, vReg src1, vReg src2, vReg tmp) %{
  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE);
  match(Set dst (MaxV src1 src2));
  effect(TEMP_DEF dst, TEMP tmp);
  format %{ "(x)vfmax    $dst, $src1, $src2\t# TEMP($tmp) @maxVD" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      __ xvfmax_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
      __ xvxor_v($tmp$$FloatRegister, $tmp$$FloatRegister, $tmp$$FloatRegister);
      __ xvfdiv_d($tmp$$FloatRegister, $tmp$$FloatRegister, $tmp$$FloatRegister);
      __ xvfcmp_cun_d(fscratch, $src1$$FloatRegister, $src2$$FloatRegister);
      __ xvbitsel_v($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister, fscratch);
    } else {
      __ vfmax_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
      __ vxor_v($tmp$$FloatRegister, $tmp$$FloatRegister, $tmp$$FloatRegister);
      __ vfdiv_d($tmp$$FloatRegister, $tmp$$FloatRegister, $tmp$$FloatRegister);
      __ vfcmp_cun_d(fscratch, $src1$$FloatRegister, $src2$$FloatRegister);
      __ vbitsel_v($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister, fscratch);
    }
  %}
  ins_pipe( pipe_slow );
%}

// --------------------------------- MIN --------------------------------------

instruct minV(vReg dst, vReg src1, vReg src2) %{
  predicate(!(is_floating_point_type(Matcher::vector_element_basic_type(n))));
  match(Set dst (MinV src1 src2));
  format %{ "(x)vmin    $dst, $src1, $src2\t# @minV" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BYTE : __ xvmin_b($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_SHORT: __ xvmin_h($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_INT  : __ xvmin_w($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_LONG : __ xvmin_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BYTE : __ vmin_b($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_SHORT: __ vmin_h($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_INT  : __ vmin_w($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_LONG : __ vmin_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct minVF(vReg dst, vReg src1, vReg src2, vReg tmp) %{
  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT);
  match(Set dst (MinV src1 src2));
  effect(TEMP_DEF dst, TEMP tmp);
  format %{ "(x)vfmin    $dst, $src1, $src2\t# TEMP($tmp) @minVF" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      __ xvfmin_s($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
      __ xvxor_v($tmp$$FloatRegister, $tmp$$FloatRegister, $tmp$$FloatRegister);
      __ xvfdiv_s($tmp$$FloatRegister, $tmp$$FloatRegister, $tmp$$FloatRegister);
      __ xvfcmp_cun_s(fscratch, $src1$$FloatRegister, $src2$$FloatRegister);
      __ xvbitsel_v($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister, fscratch);
    } else {
      __ vfmin_s($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
      __ vxor_v($tmp$$FloatRegister, $tmp$$FloatRegister, $tmp$$FloatRegister);
      __ vfdiv_s($tmp$$FloatRegister, $tmp$$FloatRegister, $tmp$$FloatRegister);
      __ vfcmp_cun_s(fscratch, $src1$$FloatRegister, $src2$$FloatRegister);
      __ vbitsel_v($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister, fscratch);
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct minVD(vReg dst, vReg src1, vReg src2, vReg tmp) %{
  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE);
  match(Set dst (MinV src1 src2));
  effect(TEMP_DEF dst, TEMP tmp);
  format %{ "(x)vfmin    $dst, $src1, $src2\t# TEMP($tmp) @minVD" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      __ xvfmin_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
      __ xvxor_v($tmp$$FloatRegister, $tmp$$FloatRegister, $tmp$$FloatRegister);
      __ xvfdiv_d($tmp$$FloatRegister, $tmp$$FloatRegister, $tmp$$FloatRegister);
      __ xvfcmp_cun_d(fscratch, $src1$$FloatRegister, $src2$$FloatRegister);
      __ xvbitsel_v($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister, fscratch);
    } else {
      __ vfmin_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
      __ vxor_v($tmp$$FloatRegister, $tmp$$FloatRegister, $tmp$$FloatRegister);
      __ vfdiv_d($tmp$$FloatRegister, $tmp$$FloatRegister, $tmp$$FloatRegister);
      __ vfcmp_cun_d(fscratch, $src1$$FloatRegister, $src2$$FloatRegister);
      __ vbitsel_v($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister, fscratch);
    }
  %}
  ins_pipe( pipe_slow );
%}

// --------------------------------- NEG --------------------------------------

instruct negV(vReg dst, vReg src) %{
  match(Set dst (NegVI src));
  match(Set dst (NegVL src));
  match(Set dst (NegVF src));
  match(Set dst (NegVD src));
  format %{ "(x)vneg    $dst, $src\t# @negV" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BYTE  : __ xvneg_b($dst$$FloatRegister, $src$$FloatRegister); break;
        case T_SHORT : __ xvneg_h($dst$$FloatRegister, $src$$FloatRegister); break;
        case T_INT   : __ xvneg_w($dst$$FloatRegister, $src$$FloatRegister); break;
        case T_LONG  : __ xvneg_d($dst$$FloatRegister, $src$$FloatRegister); break;
        case T_FLOAT : __ xvbitrevi_w($dst$$FloatRegister, $src$$FloatRegister, 0x1f); break;
        case T_DOUBLE: __ xvbitrevi_d($dst$$FloatRegister, $src$$FloatRegister, 0x3f); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BYTE  : __ vneg_b($dst$$FloatRegister, $src$$FloatRegister); break;
        case T_SHORT : __ vneg_h($dst$$FloatRegister, $src$$FloatRegister); break;
        case T_INT   : __ vneg_w($dst$$FloatRegister, $src$$FloatRegister); break;
        case T_LONG  : __ vneg_d($dst$$FloatRegister, $src$$FloatRegister); break;
        case T_FLOAT : __ vbitrevi_w($dst$$FloatRegister, $src$$FloatRegister, 0x1f); break;
        case T_DOUBLE: __ vbitrevi_d($dst$$FloatRegister, $src$$FloatRegister, 0x3f); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

// --------------------------------- SQRT -------------------------------------

instruct sqrtVF(vReg dst, vReg src) %{
  match(Set dst (SqrtVF src));
  match(Set dst (SqrtVD src));
  format %{ "(x)vfsqrt.s    $dst, $src\t# @sqrtVF" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_FLOAT : __ xvfsqrt_s($dst$$FloatRegister, $src$$FloatRegister); break;
        case T_DOUBLE: __ xvfsqrt_d($dst$$FloatRegister, $src$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_FLOAT : __ vfsqrt_s($dst$$FloatRegister, $src$$FloatRegister); break;
        case T_DOUBLE: __ vfsqrt_d($dst$$FloatRegister, $src$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

// --------------------------------- MADD -------------------------------------

instruct maddV(vReg dst, vReg src1, vReg src2) %{
  match(Set dst (AddVB dst (MulVB src1 src2)));
  match(Set dst (AddVS dst (MulVS src1 src2)));
  match(Set dst (AddVI dst (MulVI src1 src2)));
  match(Set dst (AddVL dst (MulVL src1 src2)));
  format %{ "(x)vmadd    $dst, $src1, $src2\t# @maddV" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BYTE : __ xvmadd_b($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_SHORT: __ xvmadd_h($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_INT  : __ xvmadd_w($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_LONG : __ xvmadd_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BYTE : __ vmadd_b($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_SHORT: __ vmadd_h($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_INT  : __ vmadd_w($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_LONG : __ vmadd_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

// src1 * src2 + src3
instruct fmaddV(vReg dst, vReg src1, vReg src2, vReg src3) %{
  match(Set dst (FmaVF src3 (Binary src1 src2)));
  match(Set dst (FmaVD src3 (Binary src1 src2)));
  format %{ "(x)vfmadd    $dst, $src1, $src2, $src3\t# @fmaddV" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_FLOAT : __ xvfmadd_s($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister); break;
        case T_DOUBLE: __ xvfmadd_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_FLOAT : __ vfmadd_s($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister); break;
        case T_DOUBLE: __ vfmadd_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

// --------------------------------- MSUB -------------------------------------

instruct msubV(vReg dst, vReg src1, vReg src2) %{
  match(Set dst (SubVB dst (MulVB src1 src2)));
  match(Set dst (SubVS dst (MulVS src1 src2)));
  match(Set dst (SubVI dst (MulVI src1 src2)));
  match(Set dst (SubVL dst (MulVL src1 src2)));
  format %{ "(x)vmsub    $dst, $src1, $src2\t# @msubV" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BYTE : __ xvmsub_b($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_SHORT: __ xvmsub_h($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_INT  : __ xvmsub_w($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_LONG : __ xvmsub_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BYTE : __ vmsub_b($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_SHORT: __ vmsub_h($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_INT  : __ vmsub_w($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        case T_LONG : __ vmsub_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

// src1 * src2 - src3
instruct fmsubV(vReg dst, vReg src1, vReg src2, vReg src3) %{
  match(Set dst (FmaVF (NegVF src3) (Binary src1 src2)));
  format %{ "(x)vfmsub    $dst, $src1, $src2, $src3\t# @fmsubV" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_FLOAT : __ xvfmsub_s($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister); break;
        case T_DOUBLE: __ xvfmsub_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_FLOAT : __ vfmsub_s($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister); break;
        case T_DOUBLE: __ vfmsub_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

// --------------------------------- FNMADD -----------------------------------

// -src1 * src2 - src3
instruct fnmaddV(vReg dst, vReg src1, vReg src2, vReg src3) %{
  match(Set dst (FmaVF (NegVF src3) (Binary (NegVF src1) src2)));
  match(Set dst (FmaVF (NegVF src3) (Binary src1 (NegVF src2))));
  match(Set dst (FmaVD (NegVD src3) (Binary (NegVD src1) src2)));
  match(Set dst (FmaVD (NegVD src3) (Binary src1 (NegVD src2))));
  format %{ "(x)vfnmadd    $dst, $src1, $src2, $src3\t# @fnmaddV" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_FLOAT : __ xvfnmadd_s($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister); break;
        case T_DOUBLE: __ xvfnmadd_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_FLOAT : __ vfnmadd_s($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister); break;
        case T_DOUBLE: __ vfnmadd_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

// --------------------------------- FNMSUB -----------------------------------

// -src1 * src2 + src3
instruct fnmsubV(vReg dst, vReg src1, vReg src2, vReg src3) %{
  match(Set dst (FmaVF src3 (Binary (NegVF src1) src2)));
  match(Set dst (FmaVF src3 (Binary src1 (NegVF src2))));
  match(Set dst (FmaVD src3 (Binary (NegVD src1) src2)));
  match(Set dst (FmaVD src3 (Binary src1 (NegVD src2))));
  format %{ "(x)vfnmsub    $dst, $src1, $src2, $src3\t# @fnmsubV" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_FLOAT : __ xvfnmsub_s($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister); break;
        case T_DOUBLE: __ xvfnmsub_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch(Matcher::vector_element_basic_type(this)) {
        case T_FLOAT : __ vfnmsub_s($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister); break;
        case T_DOUBLE: __ vfnmsub_d($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

// --------------- Vector Multiply-Add Shorts into Integer --------------------

instruct muladd8Sto4I(vReg dst, vReg src1, vReg src2) %{
  predicate(Matcher::vector_length(n->in(1)) == 8 && Matcher::vector_element_basic_type(n->in(1)) == T_SHORT);
  match(Set dst (MulAddVS2VI src1 src2));
  format %{ "muladdvs2vi    $dst, $src1, $src2\t# @muladd8Sto4I" %}
  ins_encode %{
    DEBUG_ONLY(Unimplemented()); // unverified
    __ vmulwev_w_h(fscratch, $src1$$FloatRegister, $src2$$FloatRegister);
    __ vmulwod_w_h($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
    __ vadd_w($dst$$FloatRegister, fscratch, $dst$$FloatRegister);
  %}
  ins_pipe( pipe_slow );
%}

instruct muladd16Sto8I(vReg dst, vReg src1, vReg src2) %{
  predicate(Matcher::vector_length(n->in(1)) == 16 && Matcher::vector_element_basic_type(n->in(1)) == T_SHORT);
  match(Set dst (MulAddVS2VI src1 src2));
  format %{ "muladdvs2vi    $dst, $src1, $src2\t# @muladd16Sto8I" %}
  ins_encode %{
    DEBUG_ONLY(Unimplemented()); // unverified
    __ xvmulwev_w_h(fscratch, $src1$$FloatRegister, $src2$$FloatRegister);
    __ xvmulwod_w_h($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
    __ xvadd_w($dst$$FloatRegister, fscratch, $dst$$FloatRegister);
  %}
  ins_pipe( pipe_slow );
%}

// ------------------------------ Shift ---------------------------------------

instruct shiftcntV(vReg dst, mRegI cnt) %{
  match(Set dst (LShiftCntV cnt));
  match(Set dst (RShiftCntV cnt));
  format %{ "(x)vreplgr2vr.b    $dst, $cnt\t# @shiftcntV" %}
  ins_encode %{
    switch (Matcher::vector_length_in_bytes(this)) {
      case  4:
      case  8:
      case 16: __  vreplgr2vr_b($dst$$FloatRegister, $cnt$$Register); break;
      case 32: __ xvreplgr2vr_b($dst$$FloatRegister, $cnt$$Register); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// ------------------------------ LeftShift -----------------------------------

instruct sllV(vReg dst, vReg src, vReg shift) %{
  match(Set dst (LShiftVB src shift));
  match(Set dst (LShiftVS src shift));
  match(Set dst (LShiftVI src shift));
  match(Set dst (LShiftVL src shift));
  format %{ "(x)vsll    $dst, $src, $shift\t# @sllV" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BOOLEAN:
        case T_BYTE   : __ xvsll_b(fscratch,            $src$$FloatRegister, $shift$$FloatRegister); break;
        case T_CHAR   :
        case T_SHORT  : __ xvsll_h(fscratch,            $src$$FloatRegister, $shift$$FloatRegister); break;
        case T_INT    : __ xvsll_w($dst$$FloatRegister, $src$$FloatRegister, $shift$$FloatRegister); break;
        case T_LONG   : __ xvsll_d($dst$$FloatRegister, $src$$FloatRegister, $shift$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BOOLEAN:
        case T_BYTE   : __ xvslti_bu($dst$$FloatRegister, $shift$$FloatRegister,  8);
                        __ xvand_v($dst$$FloatRegister, $dst$$FloatRegister, fscratch); break;
        case T_CHAR   :
        case T_SHORT  : __ xvslti_bu($dst$$FloatRegister, $shift$$FloatRegister, 16);
                        __ xvand_v($dst$$FloatRegister, $dst$$FloatRegister, fscratch); break;
        default:
          break; // do nothing
      }
    } else {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BOOLEAN:
        case T_BYTE   : __ vsll_b(fscratch,            $src$$FloatRegister, $shift$$FloatRegister); break;
        case T_CHAR   :
        case T_SHORT  : __ vsll_h(fscratch,            $src$$FloatRegister, $shift$$FloatRegister); break;
        case T_INT    : __ vsll_w($dst$$FloatRegister, $src$$FloatRegister, $shift$$FloatRegister); break;
        case T_LONG   : __ vsll_d($dst$$FloatRegister, $src$$FloatRegister, $shift$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BOOLEAN:
        case T_BYTE   : __ vslti_bu($dst$$FloatRegister, $shift$$FloatRegister,  8);
                        __ vand_v($dst$$FloatRegister, $dst$$FloatRegister, fscratch); break;
        case T_CHAR   :
        case T_SHORT  : __ vslti_bu($dst$$FloatRegister, $shift$$FloatRegister, 16);
                        __ vand_v($dst$$FloatRegister, $dst$$FloatRegister, fscratch); break;
        default:
          break; // do nothing
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct sllV_imm(vReg dst, vReg src, immI shift) %{
  match(Set dst (LShiftVB src (LShiftCntV shift)));
  match(Set dst (LShiftVS src (LShiftCntV shift)));
  match(Set dst (LShiftVI src (LShiftCntV shift)));
  match(Set dst (LShiftVL src (LShiftCntV shift)));
  format %{ "(x)vslli    $dst, $src, $shift\t# @sllV_imm" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BOOLEAN:
        case T_BYTE   : $shift$$constant >= 8 ?
                        __ xvxor_v($dst$$FloatRegister, $dst$$FloatRegister, $dst$$FloatRegister) :
                        __ xvslli_b($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        case T_CHAR   :
        case T_SHORT  : $shift$$constant >= 16 ?
                        __ xvxor_v($dst$$FloatRegister, $dst$$FloatRegister, $dst$$FloatRegister) :
                        __ xvslli_h($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        case T_INT    : __ xvslli_w($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        case T_LONG   : __ xvslli_d($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BOOLEAN:
        case T_BYTE   : $shift$$constant >= 8 ?
                        __ vxor_v($dst$$FloatRegister, $dst$$FloatRegister, $dst$$FloatRegister) :
                        __ vslli_b($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        case T_CHAR   :
        case T_SHORT  : $shift$$constant >= 16 ?
                        __ vxor_v($dst$$FloatRegister, $dst$$FloatRegister, $dst$$FloatRegister) :
                        __ vslli_h($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        case T_INT    : __ vslli_w($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        case T_LONG   : __ vslli_d($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

// ----------------------- LogicalRightShift ----------------------------------

instruct srlV(vReg dst, vReg src, vReg shift) %{
  match(Set dst (URShiftVB src shift));
  match(Set dst (URShiftVS src shift));
  match(Set dst (URShiftVI src shift));
  match(Set dst (URShiftVL src shift));
  format %{ "(x)vsrl    $dst, $src, $shift\t# @srlV" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BOOLEAN:
        case T_BYTE   : __ xvsrl_b(fscratch,            $src$$FloatRegister, $shift$$FloatRegister); break;
        case T_CHAR   :
        case T_SHORT  : __ xvsrl_h(fscratch,            $src$$FloatRegister, $shift$$FloatRegister); break;
        case T_INT    : __ xvsrl_w($dst$$FloatRegister, $src$$FloatRegister, $shift$$FloatRegister); break;
        case T_LONG   : __ xvsrl_d($dst$$FloatRegister, $src$$FloatRegister, $shift$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BOOLEAN:
        case T_BYTE   : __ xvslti_bu($dst$$FloatRegister, $shift$$FloatRegister,  8);
                        __ xvand_v($dst$$FloatRegister, $dst$$FloatRegister, fscratch); break;
        case T_CHAR   :
        case T_SHORT  : __ xvslti_bu($dst$$FloatRegister, $shift$$FloatRegister, 16);
                        __ xvand_v($dst$$FloatRegister, $dst$$FloatRegister, fscratch); break;
        default:
          break; // do nothing
      }
    } else {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BOOLEAN:
        case T_BYTE   : __ vsrl_b(fscratch,            $src$$FloatRegister, $shift$$FloatRegister); break;
        case T_CHAR   :
        case T_SHORT  : __ vsrl_h(fscratch,            $src$$FloatRegister, $shift$$FloatRegister); break;
        case T_INT    : __ vsrl_w($dst$$FloatRegister, $src$$FloatRegister, $shift$$FloatRegister); break;
        case T_LONG   : __ vsrl_d($dst$$FloatRegister, $src$$FloatRegister, $shift$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BOOLEAN:
        case T_BYTE   : __ vslti_bu($dst$$FloatRegister, $shift$$FloatRegister,  8);
                        __ vand_v($dst$$FloatRegister, $dst$$FloatRegister, fscratch); break;
        case T_CHAR   :
        case T_SHORT  : __ vslti_bu($dst$$FloatRegister, $shift$$FloatRegister, 16);
                        __ vand_v($dst$$FloatRegister, $dst$$FloatRegister, fscratch); break;
        default:
          break; // do nothing
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct srlV_imm(vReg dst, vReg src, immI shift) %{
  match(Set dst (URShiftVB src (RShiftCntV shift)));
  match(Set dst (URShiftVS src (RShiftCntV shift)));
  match(Set dst (URShiftVI src (RShiftCntV shift)));
  match(Set dst (URShiftVL src (RShiftCntV shift)));
  format %{ "(x)vsrli    $dst, $src, $shift\t# @srlV_imm" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BOOLEAN:
        case T_BYTE   : $shift$$constant >= 8 ?
                        __ xvxor_v($dst$$FloatRegister, $dst$$FloatRegister, $dst$$FloatRegister) :
                        __ xvsrli_b($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        case T_CHAR   :
        case T_SHORT  : $shift$$constant >= 16 ?
                        __ xvxor_v($dst$$FloatRegister, $dst$$FloatRegister, $dst$$FloatRegister) :
                        __ xvsrli_h($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        case T_INT    : __ xvsrli_w($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        case T_LONG   : __ xvsrli_d($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BOOLEAN:
        case T_BYTE   : $shift$$constant >= 8 ?
                        __ vxor_v($dst$$FloatRegister, $dst$$FloatRegister, $dst$$FloatRegister) :
                        __ vsrli_b($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        case T_CHAR   :
        case T_SHORT  : $shift$$constant >= 16 ?
                        __ vxor_v($dst$$FloatRegister, $dst$$FloatRegister, $dst$$FloatRegister) :
                        __ vsrli_h($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        case T_INT    : __ vsrli_w($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        case T_LONG   : __ vsrli_d($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

// ------------------------- ArithmeticRightShift -----------------------------

instruct sraV(vReg dst, vReg src, vReg shift) %{
  match(Set dst (RShiftVB src shift));
  match(Set dst (RShiftVS src shift));
  match(Set dst (RShiftVI src shift));
  match(Set dst (RShiftVL src shift));
  format %{ "(x)vsra    $dst, $src, $shift\t# @sraV" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BOOLEAN:
        case T_BYTE   : __ xvslti_bu(fscratch, $shift$$FloatRegister,  8);
                        __ xvorn_v(fscratch, $shift$$FloatRegister, fscratch); break;
        case T_CHAR   :
        case T_SHORT  : __ xvslti_bu(fscratch, $shift$$FloatRegister, 16);
                        __ xvorn_v(fscratch, $shift$$FloatRegister, fscratch); break;
        default:
          break; // do nothing
      }
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BOOLEAN:
        case T_BYTE   : __ xvsra_b($dst$$FloatRegister, $src$$FloatRegister, fscratch);              break;
        case T_CHAR   :
        case T_SHORT  : __ xvsra_h($dst$$FloatRegister, $src$$FloatRegister, fscratch);              break;
        case T_INT    : __ xvsra_w($dst$$FloatRegister, $src$$FloatRegister, $shift$$FloatRegister); break;
        case T_LONG   : __ xvsra_d($dst$$FloatRegister, $src$$FloatRegister, $shift$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BOOLEAN:
        case T_BYTE   : __ vslti_bu(fscratch, $shift$$FloatRegister,  8);
                        __ vorn_v(fscratch, $shift$$FloatRegister, fscratch); break;
        case T_CHAR   :
        case T_SHORT  : __ vslti_bu(fscratch, $shift$$FloatRegister, 16);
                        __ vorn_v(fscratch, $shift$$FloatRegister, fscratch); break;
        default:
          break; // do nothing
      }
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BOOLEAN:
        case T_BYTE   : __ vsra_b($dst$$FloatRegister, $src$$FloatRegister, fscratch);              break;
        case T_CHAR   :
        case T_SHORT  : __ vsra_h($dst$$FloatRegister, $src$$FloatRegister, fscratch);              break;
        case T_INT    : __ vsra_w($dst$$FloatRegister, $src$$FloatRegister, $shift$$FloatRegister); break;
        case T_LONG   : __ vsra_d($dst$$FloatRegister, $src$$FloatRegister, $shift$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct sraV_imm(vReg dst, vReg src, immI shift) %{
  match(Set dst (RShiftVB src (RShiftCntV shift)));
  match(Set dst (RShiftVS src (RShiftCntV shift)));
  match(Set dst (RShiftVI src (RShiftCntV shift)));
  match(Set dst (RShiftVL src (RShiftCntV shift)));
  format %{ "(x)vsrai    $dst, $src, $shift\t# @sraV_imm" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BOOLEAN:
        case T_BYTE   : $shift$$constant >= 8 ?
                        __ xvsrai_b($dst$$FloatRegister, $src$$FloatRegister,  7) :
                        __ xvsrai_b($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        case T_CHAR   :
        case T_SHORT  : $shift$$constant >= 16 ?
                        __ xvsrai_h($dst$$FloatRegister, $src$$FloatRegister, 15) :
                        __ xvsrai_h($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        case T_INT    : __ xvsrai_w($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        case T_LONG   : __ xvsrai_d($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BOOLEAN:
        case T_BYTE   : $shift$$constant >= 8 ?
                        __ vsrai_b($dst$$FloatRegister, $src$$FloatRegister,  7) :
                        __ vsrai_b($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        case T_CHAR   :
        case T_SHORT  : $shift$$constant >= 16 ?
                        __ vsrai_h($dst$$FloatRegister, $src$$FloatRegister, 15) :
                        __ vsrai_h($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        case T_INT    : __ vsrai_w($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        case T_LONG   : __ vsrai_d($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

// ----------------------------- RotateRightV ---------------------------------

instruct rotrV(vReg dst, vReg src, vReg shift) %{
  match(Set dst (RotateRightV src shift));
  format %{ "(x)vrotr    $dst, $src, $shift\t# @rotrV" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_INT : __ xvrotr_w($dst$$FloatRegister, $src$$FloatRegister, $shift$$FloatRegister); break;
        case T_LONG: __ xvrotr_d($dst$$FloatRegister, $src$$FloatRegister, $shift$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_INT : __ vrotr_w($dst$$FloatRegister, $src$$FloatRegister, $shift$$FloatRegister); break;
        case T_LONG: __ vrotr_d($dst$$FloatRegister, $src$$FloatRegister, $shift$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct rotrV_imm(vReg dst, vReg src, immI shift) %{
  match(Set dst (RotateRightV src shift));
  format %{ "(x)vrotri    $dst, $src, $shift\t# @rotrV_imm" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_INT : __ xvrotri_w($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        case T_LONG: __ xvrotri_d($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_INT : __ vrotri_w($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        case T_LONG: __ vrotri_d($dst$$FloatRegister, $src$$FloatRegister, $shift$$constant); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

// ------------------------------ RotateLeftV ---------------------------------

instruct rotlV(vReg dst, vReg src, vReg shift) %{
  match(Set dst (RotateLeftV src shift));
  format %{ "(x)vrotl    $dst, $src, $shift\t# @rotlV" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_INT : __ xvneg_w(fscratch, $shift$$FloatRegister); break;
        case T_LONG: __ xvneg_d(fscratch, $shift$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
      switch (Matcher::vector_element_basic_type(this)) {
        case T_INT : __ xvrotr_w($dst$$FloatRegister, $src$$FloatRegister, fscratch); break;
        case T_LONG: __ xvrotr_d($dst$$FloatRegister, $src$$FloatRegister, fscratch); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_INT : __ vneg_w(fscratch, $shift$$FloatRegister); break;
        case T_LONG: __ vneg_d(fscratch, $shift$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
      switch (Matcher::vector_element_basic_type(this)) {
        case T_INT : __ vrotr_w($dst$$FloatRegister, $src$$FloatRegister, fscratch); break;
        case T_LONG: __ vrotr_d($dst$$FloatRegister, $src$$FloatRegister, fscratch); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct rotlV_imm(vReg dst, vReg src, immI shift) %{
  match(Set dst (RotateLeftV src shift));
  format %{ "(x)vrotli    $dst, $src, $shift\t# @rotlV_imm" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_INT : __ xvrotri_w($dst$$FloatRegister, $src$$FloatRegister, (-$shift$$constant) & 0x1f); break;
        case T_LONG: __ xvrotri_d($dst$$FloatRegister, $src$$FloatRegister, (-$shift$$constant) & 0x3f); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_INT : __ vrotri_w($dst$$FloatRegister, $src$$FloatRegister, (-$shift$$constant) & 0x1f); break;
        case T_LONG: __ vrotri_d($dst$$FloatRegister, $src$$FloatRegister, (-$shift$$constant) & 0x3f); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

// --------------------------------- AND --------------------------------------

instruct andV(vReg dst, vReg src1, vReg src2) %{
  match(Set dst (AndV src1 src2));
  format %{ "(x)vand.v    $dst, $src1, $src2\t# @andV" %}
  ins_encode %{
    switch (Matcher::vector_length_in_bytes(this)) {
      case  4:
      case  8:
      case 16: __  vand_v($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
      case 32: __ xvand_v($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct andVB_imm(vReg dst, vReg src, immIU8 imm) %{
  match(Set dst (AndV src (ReplicateB imm)));
  format %{ "(x)vandi.b    $dst, $src, $imm\t# @andVB_imm" %}
  ins_encode %{
    switch (Matcher::vector_length(this)) {
      case  4:
      case  8:
      case 16: __  vandi_b($dst$$FloatRegister, $src$$FloatRegister, $imm$$constant); break;
      case 32: __ xvandi_b($dst$$FloatRegister, $src$$FloatRegister, $imm$$constant); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// --------------------------------- OR ---------------------------------------

instruct orV(vReg dst, vReg src1, vReg src2) %{
  match(Set dst (OrV src1 src2));
  format %{ "(x)vor.v    $dst, $src1, $src2\t# @orV" %}
  ins_encode %{
    switch (Matcher::vector_length_in_bytes(this)) {
      case  4:
      case  8:
      case 16: __  vor_v($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
      case 32: __ xvor_v($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct orVB_imm(vReg dst, vReg src, immIU8 imm) %{
  match(Set dst (OrV src (ReplicateB imm)));
  format %{ "(x)vori.b    $dst, $src, $imm\t# @orVB_imm" %}
  ins_encode %{
    switch (Matcher::vector_length(this)) {
      case  4:
      case  8:
      case 16: __  vori_b($dst$$FloatRegister, $src$$FloatRegister, $imm$$constant); break;
      case 32: __ xvori_b($dst$$FloatRegister, $src$$FloatRegister, $imm$$constant); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// --------------------------------- XOR --------------------------------------

instruct xorV(vReg dst, vReg src1, vReg src2) %{
  match(Set dst (XorV src1 src2));
  format %{ "(x)vxor.v    $dst, $src1, $src2\t# @xorV" %}
  ins_encode %{
    switch (Matcher::vector_length_in_bytes(this)) {
      case  4:
      case  8:
      case 16: __  vxor_v($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
      case 32: __ xvxor_v($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct xor16B_imm(vReg dst, vReg src, immIU8 imm) %{
  match(Set dst (XorV src (ReplicateB imm)));
  format %{ "(x)vxori.b    $dst, $src, $imm\t# @xor16B_imm" %}
  ins_encode %{
    switch (Matcher::vector_length(this)) {
      case  4:
      case  8:
      case 16: __  vxori_b($dst$$FloatRegister, $src$$FloatRegister, $imm$$constant); break;
      case 32: __ xvxori_b($dst$$FloatRegister, $src$$FloatRegister, $imm$$constant); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// --------------------------------- NOR --------------------------------------

instruct norV(vReg dst, vReg src1, vReg src2, immI_M1 m1) %{
  match(Set dst (XorV (OrV src1 src2) (ReplicateB m1)));
  match(Set dst (XorV (OrV src1 src2) (ReplicateS m1)));
  match(Set dst (XorV (OrV src1 src2) (ReplicateI m1)));
  format %{ "(x)vnor.v    $dst, $src1, $src2\t# @norV" %}
  ins_encode %{
    switch (Matcher::vector_length_in_bytes(this)) {
      case  4:
      case  8:
      case 16: __  vnor_v($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
      case 32: __ xvnor_v($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct norVB_imm(vReg dst, vReg src, immIU8 imm, immI_M1 m1) %{
  match(Set dst (XorV (OrV src (ReplicateB imm)) (ReplicateB m1)));
  format %{ "(x)vnori.b    $dst, $src, $imm\t# @norVB_imm" %}
  ins_encode %{
    switch (Matcher::vector_length(this)) {
      case  4:
      case  8:
      case 16: __  vnori_b($dst$$FloatRegister, $src$$FloatRegister, $imm$$constant); break;
      case 32: __ xvnori_b($dst$$FloatRegister, $src$$FloatRegister, $imm$$constant); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// --------------------------------- ANDN -------------------------------------

instruct andnV(vReg dst, vReg src1, vReg src2, immI_M1 m1) %{
  match(Set dst (AndV src2 (XorV src1 (ReplicateB m1))));
  match(Set dst (AndV src2 (XorV src1 (ReplicateS m1))));
  match(Set dst (AndV src2 (XorV src1 (ReplicateI m1))));
  format %{ "(x)vandn.v    $dst, $src1, $src2\t# @andnV" %}
  ins_encode %{
    switch (Matcher::vector_length_in_bytes(this)) {
      case  4:
      case  8:
      case 16: __  vandn_v($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
      case 32: __ xvandn_v($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// --------------------------------- ORN --------------------------------------

instruct ornV(vReg dst, vReg src1, vReg src2, immI_M1 m1) %{
  match(Set dst (OrV src1 (XorV src2 (ReplicateB m1))));
  match(Set dst (OrV src1 (XorV src2 (ReplicateS m1))));
  match(Set dst (OrV src1 (XorV src2 (ReplicateI m1))));
  format %{ "(x)vorn.v    $dst, $src1, $src2\t# @ornV" %}
  ins_encode %{
    switch (Matcher::vector_length_in_bytes(this)) {
      case  4:
      case  8:
      case 16: __  vorn_v($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
      case 32: __ xvorn_v($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// ----------------------------- Reduction Add --------------------------------

instruct reduceV(mRegI dst, mRegI src, vReg vsrc, vReg tmp1, vReg tmp2) %{
  match(Set dst (AddReductionVI src vsrc));
  match(Set dst (MulReductionVI src vsrc));
  match(Set dst (MaxReductionV  src vsrc));
  match(Set dst (MinReductionV  src vsrc));
  match(Set dst (AndReductionV  src vsrc));
  match(Set dst (OrReductionV   src vsrc));
  match(Set dst (XorReductionV  src vsrc));
  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);
  format %{ "(x)vreduce    $dst, $src, $vsrc\t# TEMP($tmp1, $tmp2) @reduceV" %}
  ins_encode %{
    __ reduce($dst$$Register, $src$$Register, $vsrc$$FloatRegister, $tmp1$$FloatRegister, $tmp2$$FloatRegister,
              Matcher::vector_element_basic_type(this, $vsrc), this->ideal_Opcode(), Matcher::vector_length_in_bytes(this, $vsrc));
  %}
  ins_pipe( pipe_slow );
%}

instruct reduceVL(mRegL dst, mRegL src, vReg vsrc, vReg tmp1, vReg tmp2) %{
  match(Set dst (AddReductionVL src vsrc));
  match(Set dst (MulReductionVL src vsrc));
  match(Set dst (MaxReductionV  src vsrc));
  match(Set dst (MinReductionV  src vsrc));
  match(Set dst (AndReductionV  src vsrc));
  match(Set dst (OrReductionV   src vsrc));
  match(Set dst (XorReductionV  src vsrc));
  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);
  format %{ "(x)vreduce    $dst, $src, $vsrc\t# TEMP($tmp1, $tmp2) @reduceVL" %}
  ins_encode %{
    __ reduce($dst$$Register, $src$$Register, $vsrc$$FloatRegister, $tmp1$$FloatRegister, $tmp2$$FloatRegister,
              T_LONG, this->ideal_Opcode(), Matcher::vector_length_in_bytes(this, $vsrc));
  %}
  ins_pipe( pipe_slow );
%}

instruct reduceVF(regF dst, regF src, vReg vsrc, vReg tmp) %{
  match(Set dst (AddReductionVF src vsrc));
  match(Set dst (MulReductionVF src vsrc));
  effect(TEMP_DEF dst, TEMP tmp);
  format %{ "(x)vreduce    $dst, $src, $vsrc\t# TEMP($tmp) @reduceVF" %}
  ins_encode %{
    __ reduce($dst$$FloatRegister, $src$$FloatRegister, $vsrc$$FloatRegister, $tmp$$FloatRegister,
              T_FLOAT, this->ideal_Opcode(), Matcher::vector_length_in_bytes(this, $vsrc));
  %}
  ins_pipe( pipe_slow );
%}

instruct reduceVD(regD dst, regD src, vReg vsrc, vReg tmp) %{
  match(Set dst (AddReductionVD src vsrc));
  match(Set dst (MulReductionVD src vsrc));
  effect(TEMP_DEF dst, TEMP tmp);
  format %{ "(x)vreduce    $dst, $src, $vsrc\t# TEMP($tmp) @reduceVD" %}
  ins_encode %{
    __ reduce($dst$$FloatRegister, $src$$FloatRegister, $vsrc$$FloatRegister, $tmp$$FloatRegister,
              T_DOUBLE, this->ideal_Opcode(), Matcher::vector_length_in_bytes(this, $vsrc));
  %}
  ins_pipe( pipe_slow );
%}

// ------------------------------ Vector Round ---------------------------------

instruct round_float_lsx(vReg dst, vReg src, vReg vtemp1, vReg vtemp2) %{
  predicate(Matcher::vector_length_in_bytes(n) <= 16);
  match(Set dst (RoundVF src));
  effect(TEMP_DEF dst, TEMP vtemp1, TEMP vtemp2);
  format %{ "round_float_lsx    $dst, $src\t# "
            "TEMP($vtemp1, $vtemp2) @round_float_lsx" %}
  ins_encode %{
    __ java_round_float_lsx($dst$$FloatRegister,
                            $src$$FloatRegister,
                            $vtemp1$$FloatRegister,
                            $vtemp2$$FloatRegister);
  %}
  ins_pipe( pipe_slow );
%}

instruct round_float_lasx(vReg dst, vReg src, vReg vtemp1, vReg vtemp2) %{
  predicate(Matcher::vector_length_in_bytes(n) > 16);
  match(Set dst (RoundVF src));
  effect(TEMP_DEF dst, TEMP vtemp1, TEMP vtemp2);
  format %{ "round_float_lasx    $dst, $src\t# "
            "TEMP($vtemp1, $vtemp2) @round_float_lasx" %}
  ins_encode %{
    __ java_round_float_lasx($dst$$FloatRegister,
                             $src$$FloatRegister,
                             $vtemp1$$FloatRegister,
                             $vtemp2$$FloatRegister);
  %}
  ins_pipe( pipe_slow );
%}

instruct round_double_lsx(vReg dst, vReg src, vReg vtemp1, vReg vtemp2) %{
  predicate(Matcher::vector_length_in_bytes(n) <= 16);
  match(Set dst (RoundVD src));
  effect(TEMP_DEF dst, TEMP vtemp1, TEMP vtemp2);
  format %{ "round_double_lsx $dst, $src\t# "
            "TEMP($vtemp1, $vtemp2) @round_double_lsx" %}
  ins_encode %{
    __ java_round_double_lsx($dst$$FloatRegister,
                             $src$$FloatRegister,
                             $vtemp1$$FloatRegister,
                             $vtemp2$$FloatRegister);
  %}
  ins_pipe( pipe_slow );
%}

instruct round_double_lasx(vReg dst, vReg src, vReg vtemp1, vReg vtemp2) %{
  predicate(Matcher::vector_length_in_bytes(n) > 16);
  match(Set dst (RoundVD src));
  effect(TEMP_DEF dst, TEMP vtemp1, TEMP vtemp2);
  format %{ "round_double_lasx $dst, $src\t# "
            "TEMP($vtemp1, $vtemp2) @round_double_lasx" %}
  ins_encode %{
    __ java_round_double_lasx($dst$$FloatRegister,
                              $src$$FloatRegister,
                              $vtemp1$$FloatRegister,
                              $vtemp2$$FloatRegister);
  %}
  ins_pipe( pipe_slow );
%}

// ------------------------------ RoundDoubleModeV ----------------------------

instruct roundVD(vReg dst, vReg src, immI rmode) %{
  match(Set dst (RoundDoubleModeV src rmode));
  format %{ "(x)vfrint    $dst, $src, $rmode\t# @roundVD" %}
  ins_encode %{
    if (Matcher::vector_length(this) == 4) {
      switch ($rmode$$constant) {
        case RoundDoubleModeNode::rmode_rint:  __ xvfrintrne_d($dst$$FloatRegister, $src$$FloatRegister); break;
        case RoundDoubleModeNode::rmode_floor: __ xvfrintrm_d($dst$$FloatRegister, $src$$FloatRegister);  break;
        case RoundDoubleModeNode::rmode_ceil:  __ xvfrintrp_d($dst$$FloatRegister, $src$$FloatRegister);  break;
      }
    } else if (Matcher::vector_length(this) == 2) {
      switch ($rmode$$constant) {
        case RoundDoubleModeNode::rmode_rint:  __ vfrintrne_d($dst$$FloatRegister, $src$$FloatRegister); break;
        case RoundDoubleModeNode::rmode_floor: __ vfrintrm_d($dst$$FloatRegister, $src$$FloatRegister);  break;
        case RoundDoubleModeNode::rmode_ceil:  __ vfrintrp_d($dst$$FloatRegister, $src$$FloatRegister);  break;
      }
    } else {
      ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// ---------------------------- Vector Cast B2X -------------------------------

instruct cvtVB(vReg dst, vReg src) %{
  match(Set dst (VectorCastB2X src));
  format %{ "(x)vconvert    $dst, $src\t# @cvtVB" %}
  ins_encode %{
    switch (Matcher::vector_element_basic_type(this)) {
      case T_SHORT : __ vext2xv_h_b($dst$$FloatRegister, $src$$FloatRegister); break;
      case T_INT   : __ vext2xv_w_b($dst$$FloatRegister, $src$$FloatRegister); break;
      case T_LONG  : __ vext2xv_d_b($dst$$FloatRegister, $src$$FloatRegister); break;
      case T_FLOAT : __ vext2xv_w_b($dst$$FloatRegister, $src$$FloatRegister);
                     Matcher::vector_length_in_bytes(this) > 16 ?
                     __ xvffint_s_w($dst$$FloatRegister, $dst$$FloatRegister) :
                     __  vffint_s_w($dst$$FloatRegister, $dst$$FloatRegister); break;
      case T_DOUBLE: __ vext2xv_d_b($dst$$FloatRegister, $src$$FloatRegister);
                     assert(Matcher::vector_length_in_bytes(this) > 16, "only support 4Bto4D");
                     __ xvffint_d_l($dst$$FloatRegister, $dst$$FloatRegister); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// --------------------------- Vector Cast S2X --------------------------------

instruct cvtVS(vReg dst, vReg src) %{
  match(Set dst (VectorCastS2X src));
  format %{ "(x)vconvert    $dst, $src\t# @cvtVS" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this, $src) > 16 && Matcher::vector_element_basic_type(this) == T_BYTE) {
      __ xvpermi_q(fscratch, $src$$FloatRegister, 0x00);
      __ xvpermi_q($dst$$FloatRegister, $src$$FloatRegister, 0x11);
    }
    switch (Matcher::vector_element_basic_type(this)) {
      case T_BYTE  : Matcher::vector_length_in_bytes(this, $src) > 16 ?
                     __ vsrlni_b_h($dst$$FloatRegister, fscratch, 0) :
                     __ vsrlni_b_h($dst$$FloatRegister, $src$$FloatRegister, 0); break;
      case T_INT   : __ vext2xv_w_h($dst$$FloatRegister, $src$$FloatRegister); break;
      case T_LONG  : __ vext2xv_d_h($dst$$FloatRegister, $src$$FloatRegister); break;
      case T_FLOAT : __ vext2xv_w_h($dst$$FloatRegister, $src$$FloatRegister);
                     Matcher::vector_length_in_bytes(this) > 16 ?
                     __ xvffint_s_w($dst$$FloatRegister, $dst$$FloatRegister) :
                     __  vffint_s_w($dst$$FloatRegister, $dst$$FloatRegister); break;
      case T_DOUBLE: __ vext2xv_d_h($dst$$FloatRegister, $src$$FloatRegister);
                     Matcher::vector_length_in_bytes(this) > 16 ?
                     __ xvffint_d_l($dst$$FloatRegister, $dst$$FloatRegister) :
                     __  vffint_d_l($dst$$FloatRegister, $dst$$FloatRegister); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// --------------------------- Vector Cast I2X --------------------------------

instruct cvtVI(vReg dst, vReg src) %{
  match(Set dst (VectorCastI2X src));
  format %{ "(x)vconvert    $dst, $src\t# @cvtVI" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this, $src) > 16 && type2aelembytes(Matcher::vector_element_basic_type(this)) < 4) {
      __ xvpermi_q(fscratch, $src$$FloatRegister, 0x00);
      __ xvpermi_q($dst$$FloatRegister, $src$$FloatRegister, 0x11);
    }
    switch (Matcher::vector_element_basic_type(this)) {
      case T_BYTE  : if (Matcher::vector_length_in_bytes(this, $src) > 16) {
                       __ vsrlni_h_w($dst$$FloatRegister, fscratch, 0);
                       __ vsrlni_b_h($dst$$FloatRegister, $dst$$FloatRegister, 0);
                     } else {
                       __ vsrlni_h_w($dst$$FloatRegister, $src$$FloatRegister, 0);
                       __ vsrlni_b_h($dst$$FloatRegister, $dst$$FloatRegister, 0);
                     }
                     break;
      case T_SHORT : Matcher::vector_length_in_bytes(this, $src) > 16 ?
                     __ vsrlni_h_w($dst$$FloatRegister, fscratch, 0) :
                     __ vsrlni_h_w($dst$$FloatRegister, $src$$FloatRegister, 0); break;
      case T_LONG  : __ vext2xv_d_w($dst$$FloatRegister, $src$$FloatRegister); break;
      case T_FLOAT : Matcher::vector_length_in_bytes(this) > 16 ?
                     __ xvffint_s_w($dst$$FloatRegister, $src$$FloatRegister) :
                     __  vffint_s_w($dst$$FloatRegister, $src$$FloatRegister); break;
      case T_DOUBLE: __ vext2xv_d_w($dst$$FloatRegister, $src$$FloatRegister);
                     Matcher::vector_length_in_bytes(this) > 16 ?
                     __ xvffint_d_l($dst$$FloatRegister, $dst$$FloatRegister) :
                     __  vffint_d_l($dst$$FloatRegister, $dst$$FloatRegister); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// ----------------------------- Vector Cast L2X ------------------------------

instruct cvtVL(vReg dst, vReg src) %{
  match(Set dst (VectorCastL2X src));
  format %{ "(x)vconvert    $dst, $src\t# @cvtVL" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this, $src) > 16 && type2aelembytes(Matcher::vector_element_basic_type(this)) < 8) {
      __ xvpermi_q(fscratch, $src$$FloatRegister, 0x00);
      __ xvpermi_q($dst$$FloatRegister, $src$$FloatRegister, 0x11);
    }
    switch (Matcher::vector_element_basic_type(this)) {
      case T_BYTE  : assert(Matcher::vector_length_in_bytes(this, $src) > 16, "only support 4Lto4B");
                     __ vsrlni_w_d($dst$$FloatRegister, fscratch, 0);
                     __ vsrlni_h_w($dst$$FloatRegister, $dst$$FloatRegister, 0);
                     __ vsrlni_b_h($dst$$FloatRegister, $dst$$FloatRegister, 0); break;
      case T_SHORT : if (Matcher::vector_length_in_bytes(this, $src) > 16) {
                       __ vsrlni_w_d($dst$$FloatRegister, fscratch, 0);
                       __ vsrlni_h_w($dst$$FloatRegister, $dst$$FloatRegister, 0);
                     } else {
                       __ vsrlni_w_d($dst$$FloatRegister, $src$$FloatRegister, 0);
                       __ vsrlni_h_w($dst$$FloatRegister, $dst$$FloatRegister, 0);
                     }
                     break;
      case T_INT   : Matcher::vector_length_in_bytes(this, $src) > 16 ?
                     __ vsrlni_w_d($dst$$FloatRegister, fscratch, 0) :
                     __ vsrlni_w_d($dst$$FloatRegister, $src$$FloatRegister, 0); break;
      case T_FLOAT : Matcher::vector_length_in_bytes(this, $src) > 16 ?
                     __ vffint_s_l($dst$$FloatRegister, $dst$$FloatRegister, fscratch) :
                     __ vffint_s_l($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister); break;
      case T_DOUBLE: Matcher::vector_length_in_bytes(this) > 16 ?
                     __ xvffint_d_l($dst$$FloatRegister, $src$$FloatRegister) :
                     __  vffint_d_l($dst$$FloatRegister, $src$$FloatRegister); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// ----------------------------- Vector Cast F2X ------------------------------

instruct cvtVF(vReg dst, vReg src) %{
  match(Set dst (VectorCastF2X src));
  format %{ "(x)vconvert    $dst, $src\t# @cvtVF" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this, $src) > 16 && type2aelembytes(Matcher::vector_element_basic_type(this)) < 4) {
      __ xvftintrz_w_s(fscratch, $src$$FloatRegister);
      __ xvpermi_q($dst$$FloatRegister, fscratch, 0x11);
    } else if (Matcher::vector_length_in_bytes(this) > 16 && type2aelembytes(Matcher::vector_element_basic_type(this)) > 4) {
      __ xvpermi_d($dst$$FloatRegister, $src$$FloatRegister, 0b01010000);
    } else if (Matcher::vector_length_in_bytes(this, $src) <= 16 && type2aelembytes(Matcher::vector_element_basic_type(this)) < 4) {
      __ vftintrz_w_s($dst$$FloatRegister, $src$$FloatRegister);
    }
    switch (Matcher::vector_element_basic_type(this)) {
      case T_BYTE  : if (Matcher::vector_length_in_bytes(this, $src) > 16) {
                       __ vsrlni_h_w($dst$$FloatRegister, fscratch, 0);
                       __ vsrlni_b_h($dst$$FloatRegister, $dst$$FloatRegister, 0);
                     } else {
                       __ vsrlni_h_w($dst$$FloatRegister, $dst$$FloatRegister, 0);
                       __ vsrlni_b_h($dst$$FloatRegister, $dst$$FloatRegister, 0);
                     }
                     break;
      case T_SHORT : Matcher::vector_length_in_bytes(this, $src) > 16 ?
                     __ vsrlni_h_w($dst$$FloatRegister, fscratch, 0) :
                     __ vsrlni_h_w($dst$$FloatRegister, $dst$$FloatRegister, 0); break;
      case T_INT   : Matcher::vector_length_in_bytes(this, $src) > 16 ?
                     __ xvftintrz_w_s($dst$$FloatRegister, $src$$FloatRegister) :
                     __  vftintrz_w_s($dst$$FloatRegister, $src$$FloatRegister); break;
      case T_LONG  : Matcher::vector_length_in_bytes(this) > 16 ?
                     __ xvftintrzl_l_s($dst$$FloatRegister, $dst$$FloatRegister) :
                     __  vftintrzl_l_s($dst$$FloatRegister, $src$$FloatRegister); break;
      case T_DOUBLE: Matcher::vector_length_in_bytes(this) > 16 ?
                     __ xvfcvtl_d_s($dst$$FloatRegister, $dst$$FloatRegister) :
                     __  vfcvtl_d_s($dst$$FloatRegister, $src$$FloatRegister); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// ---------------------------- Vector Cast D2X -------------------------------

instruct cvtVD(vReg dst, vReg src) %{
  match(Set dst (VectorCastD2X src));
  format %{ "(x)vconvert    $dst, $src\t# @cvtVD" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this, $src) > 16 && type2aelembytes(Matcher::vector_element_basic_type(this)) < 8) {
      __ xvpermi_q(fscratch, $src$$FloatRegister, 0x11);
      if (Matcher::vector_element_basic_type(this) != T_FLOAT)
        __ vftintrz_w_d($dst$$FloatRegister, fscratch, $src$$FloatRegister);
    } else if (Matcher::vector_length_in_bytes(this, $src) <= 16 && type2aelembytes(Matcher::vector_element_basic_type(this)) < 8) {
      if (Matcher::vector_element_basic_type(this) != T_FLOAT)
        __ vftintrz_w_d($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);
    }
    switch (Matcher::vector_element_basic_type(this)) {
      case T_BYTE : assert(Matcher::vector_length_in_bytes(this, $src) > 16, "only support 4Dto4B");
                    __ vsrlni_h_w($dst$$FloatRegister, $dst$$FloatRegister, 0);
                    __ vsrlni_b_h($dst$$FloatRegister, $dst$$FloatRegister, 0); break;
      case T_SHORT: __ vsrlni_h_w($dst$$FloatRegister, $dst$$FloatRegister, 0); break;
      case T_INT  : break;
      case T_LONG : Matcher::vector_length_in_bytes(this) > 16 ?
                    __ xvftintrz_l_d($dst$$FloatRegister, $src$$FloatRegister) :
                    __  vftintrz_l_d($dst$$FloatRegister, $src$$FloatRegister); break;
      case T_FLOAT: Matcher::vector_length_in_bytes(this, $src) > 16 ?
                    __ vfcvt_s_d($dst$$FloatRegister, fscratch, $src$$FloatRegister) :
                    __ vfcvt_s_d($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// ---------------------------- Vector Cast HF2F -------------------------------

instruct cvtHFtoF(vReg dst, vReg src) %{
  match(Set dst (VectorCastHF2F src));
  format %{ "(x)vconvert    $dst, $src\t# @cvtHFtoF" %}
  ins_encode %{
    switch(Matcher::vector_length(this)) {
      case 2:
      case 4: __  vfcvtl_s_h($dst$$FloatRegister, $src$$FloatRegister); break;
      case 8: __ xvpermi_d($dst$$FloatRegister, $src$$FloatRegister, 0b01010000);
              __ xvfcvtl_s_h($dst$$FloatRegister, $dst$$FloatRegister); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// ---------------------------- Vector Cast F2HF -------------------------------

instruct cvtFtoHF(vReg dst, vReg src) %{
  match(Set dst (VectorCastF2HF src));
  format %{ "(x)vconvert    $dst, $src\t# @cvtFtoHF" %}
  ins_encode %{
    switch(Matcher::vector_length(this)) {
      case 2:
      case 4: __  vfcvt_h_s($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister); break;
      case 8: __ xvfcvt_h_s($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);
              __ xvpermi_d($dst$$FloatRegister, $dst$$FloatRegister, 0b11011000); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// ------------------------------ VectorReinterpret ---------------------------

instruct reinterpretV(vReg dst, vReg src) %{
  match(Set dst (VectorReinterpret src));
  format %{ "(x)vreinterpret    $dst, $src\t# @reinterpretV" %}
  ins_encode %{
    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);
    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);
    if ($dst$$FloatRegister != $src$$FloatRegister) {
      if (length_in_bytes_dst > 16)
        __ xvori_b($dst$$FloatRegister, $src$$FloatRegister, 0);
      else
        __ vori_b($dst$$FloatRegister, $src$$FloatRegister, 0);
    }
    if (length_in_bytes_dst > length_in_bytes_src) {
      if (length_in_bytes_dst == 32) {
        switch (length_in_bytes_src) {
          case  4: __ xvinsgr2vr_w($dst$$FloatRegister, R0, 1);
          case  8: __ xvinsgr2vr_d($dst$$FloatRegister, R0, 1);
          case 16: __ xvinsgr2vr_d($dst$$FloatRegister, R0, 2);
                   __ xvinsgr2vr_d($dst$$FloatRegister, R0, 3);
                   break;
          default:
            ShouldNotReachHere();
        }
      } else if (length_in_bytes_dst == 16) {
        switch (length_in_bytes_src) {
          case 4: __ vinsgr2vr_w($dst$$FloatRegister, R0, 1);
          case 8: __ vinsgr2vr_d($dst$$FloatRegister, R0, 1); break;
          default:
            ShouldNotReachHere();
        }
      } else if (length_in_bytes_dst == 8) {
        assert(length_in_bytes_src == 4, "invalid vector length");
        __ vinsgr2vr_w($dst$$FloatRegister, R0, 1);
      } else {
        ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( empty );
%}

// ------------------------------ VectorInsert --------------------------------

instruct insertV(vReg dst, mRegI val, immIU4 idx) %{
  predicate(Matcher::vector_length_in_bytes(n) <= 16);
  match(Set dst (VectorInsert (Binary dst val) idx));
  format %{ "(x)vinsgr2vr    $dst, $val, $idx\t# @insertV" %}
  ins_encode %{
    switch (Matcher::vector_element_basic_type(this)) {
      case T_BYTE : __ vinsgr2vr_b($dst$$FloatRegister, $val$$Register, $idx$$constant); break;
      case T_SHORT: __ vinsgr2vr_h($dst$$FloatRegister, $val$$Register, $idx$$constant); break;
      case T_INT  : __ vinsgr2vr_w($dst$$FloatRegister, $val$$Register, $idx$$constant); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct insertVL(vReg dst, mRegL val, immIU2 idx) %{
  match(Set dst (VectorInsert (Binary dst val) idx));
  format %{ "(x)vinsgr2vr.d    $dst, $val, $idx\t# @insertVL" %}
  ins_encode %{
    switch (Matcher::vector_length(this)) {
      case 2: __  vinsgr2vr_d($dst$$FloatRegister, $val$$Register, $idx$$constant); break;
      case 4: __ xvinsgr2vr_d($dst$$FloatRegister, $val$$Register, $idx$$constant); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct insertVF(vReg dst, regF val, immIU3 idx) %{
  match(Set dst (VectorInsert (Binary dst val) idx));
  format %{ "(x)vinsert    $dst, $val, $idx\t# @insertVF" %}
  ins_encode %{
    switch (Matcher::vector_length(this)) {
      case 2:
      case 4: __ movfr2gr_s(AT, $val$$FloatRegister);
              __ vinsgr2vr_w($dst$$FloatRegister, AT, $idx$$constant); break;
      case 8: __ xvinsve0_w($dst$$FloatRegister, $val$$FloatRegister, $idx$$constant); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct insertVD(vReg dst, regD val, immIU2 idx) %{
  match(Set dst (VectorInsert (Binary dst val) idx));
  format %{ "(x)vinsert    $dst, $val, $idx\t# @insertVD" %}
  ins_encode %{
    switch (Matcher::vector_length(this)) {
      case 2: __ movfr2gr_d(AT, $val$$FloatRegister);
              __ vinsgr2vr_d($dst$$FloatRegister, AT, $idx$$constant); break;
      case 4: __ xvinsve0_d($dst$$FloatRegister, $val$$FloatRegister, $idx$$constant); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct insert32B(vReg dst, mRegI val, immIU5 idx) %{
  predicate(Matcher::vector_length(n) == 32 && Matcher::vector_element_basic_type(n) == T_BYTE);
  match(Set dst (VectorInsert (Binary dst val) idx));
  format %{ "(x)vinsert    $dst, $val, $idx\t# @insert32B" %}
  ins_encode %{
    int idx = $idx$$constant;
    int msbw, lsbw;
    switch (idx % 4) {
      case 0: msbw =  7, lsbw =  0; break;
      case 1: msbw = 15, lsbw =  8; break;
      case 2: msbw = 23, lsbw = 16; break;
      case 3: msbw = 31, lsbw = 24; break;
      default:
        ShouldNotReachHere();
    }
    __ xvpickve2gr_w(SCR1, $dst$$FloatRegister, idx >> 2);
    __ bstrins_w(SCR1, $val$$Register, msbw, lsbw);
    __ xvinsgr2vr_w($dst$$FloatRegister, SCR1, idx >> 2);
  %}
  ins_pipe( pipe_slow );
%}

instruct insert16S(vReg dst, mRegI val, immIU4 idx) %{
  predicate(Matcher::vector_length(n) == 16 && Matcher::vector_element_basic_type(n) == T_SHORT);
  match(Set dst (VectorInsert (Binary dst val) idx));
  format %{ "(x)vinsert    $dst, $val, $idx\t# @insert16S" %}
  ins_encode %{
    int idx = $idx$$constant;
    int msbw = (idx % 2) ? 31 : 15;
    int lsbw = (idx % 2) ? 16 :  0;
    __ xvpickve2gr_w(SCR1, $dst$$FloatRegister, idx >> 1);
    __ bstrins_w(SCR1, $val$$Register, msbw, lsbw);
    __ xvinsgr2vr_w($dst$$FloatRegister, SCR1, idx >> 1);
  %}
  ins_pipe( pipe_slow );
%}

instruct insert8I(vReg dst, mRegI val, immIU3 idx) %{
  predicate(Matcher::vector_length(n) == 8 && Matcher::vector_element_basic_type(n) == T_INT);
  match(Set dst (VectorInsert (Binary dst val) idx));
  format %{ "(x)vinsgr2vr.w    $dst, $val, $idx\t# @insert8I" %}
  ins_encode %{
    __ xvinsgr2vr_w($dst$$FloatRegister, $val$$Register, $idx$$constant);
  %}
  ins_pipe( pipe_slow );
%}

// -------------------------------- Vector Blend ------------------------------

instruct blendV(vReg dst, vReg src1, vReg src2, vReg mask)
%{
  match(Set dst (VectorBlend (Binary src1 src2) mask));
  format %{ "(x)vbitsel.v    $dst, $src1, $src2, $mask\t# @blendV" %}
  ins_encode %{
    switch (Matcher::vector_length_in_bytes(this)) {
      case  4:
      case  8:
      case 16: __  vbitsel_v($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $mask$$FloatRegister); break;
      case 32: __ xvbitsel_v($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $mask$$FloatRegister); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// -------------------------------- LoadMask ----------------------------------

instruct loadmaskV(vReg dst, vReg src) %{
  match(Set dst (VectorLoadMask src));
  format %{ "(x)vloadmask    $dst, $src\t# @loadmaskV" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BYTE  : __ xvneg_b($dst$$FloatRegister, $src$$FloatRegister); break;
        case T_SHORT : __ vext2xv_h_b($dst$$FloatRegister, $src$$FloatRegister);
                       __ xvneg_h($dst$$FloatRegister, $dst$$FloatRegister); break;
        case T_FLOAT :
        case T_INT   : __ vext2xv_w_b($dst$$FloatRegister, $src$$FloatRegister);
                       __ xvneg_w($dst$$FloatRegister, $dst$$FloatRegister); break;
        case T_DOUBLE:
        case T_LONG  : __ vext2xv_d_b($dst$$FloatRegister, $src$$FloatRegister);
                       __ xvneg_d($dst$$FloatRegister, $dst$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BYTE : __ vneg_b($dst$$FloatRegister, $src$$FloatRegister); break;
        case T_SHORT: __ vext2xv_h_b($dst$$FloatRegister, $src$$FloatRegister);
                      __ vneg_h($dst$$FloatRegister, $dst$$FloatRegister); break;
        case T_FLOAT:
        case T_INT  : __ vext2xv_w_b($dst$$FloatRegister, $src$$FloatRegister);
                      __ vneg_w($dst$$FloatRegister, $dst$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

//-------------------------------- StoreMask ----------------------------------

instruct storemaskV(vReg dst, vReg src, immIU4 size) %{
  match(Set dst (VectorStoreMask src size));
  format %{ "(x)vstoremask    $dst, $src\t# @storemaskV" %}
  ins_encode %{
    uint size = $size$$constant;
    if (Matcher::vector_length_in_bytes(this, $src) > 16 && size != 1 /* byte */)
      __ xvpermi_d(fscratch, $src$$FloatRegister, 0b00001110);

    switch (size) {
      case 8: /* long or double */
        __ vsrlni_w_d(fscratch, $src$$FloatRegister, 0);
        __ vsrlni_h_w(fscratch, fscratch, 0);
        __ vsrlni_b_h(fscratch, fscratch, 0);
        __ vneg_b($dst$$FloatRegister, fscratch);
        break;
      case 4: /* int or float */
        __ vsrlni_h_w(fscratch, $src$$FloatRegister, 0);
        __ vsrlni_b_h(fscratch, fscratch, 0);
        __ vneg_b($dst$$FloatRegister, fscratch);
        break;
      case 2: /* short */
        __ vsrlni_b_h(fscratch, $src$$FloatRegister, 0);
        __ vneg_b($dst$$FloatRegister, fscratch);
        break;
      case 1: /* byte */
        if (Matcher::vector_length_in_bytes(this, $src) > 16)
          __ xvneg_b($dst$$FloatRegister, $src$$FloatRegister);
        else
          __ vneg_b($dst$$FloatRegister, $src$$FloatRegister);
        break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// ----------------------------- VectorMaskCast -----------------------------------

instruct vmaskcast_eq(vReg dst) %{
  predicate(Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)));
  match(Set dst (VectorMaskCast dst));
  format %{ "(x)vmaskcast    $dst\t# @vmaskcast_eq" %}
  ins_encode(/* empty encoding */);
  ins_pipe( pipe_slow );
%}

instruct vmaskcast_gt(vReg dst, vReg src) %{
  predicate(Matcher::vector_length_in_bytes(n) > Matcher::vector_length_in_bytes(n->in(1)));
  match(Set dst (VectorMaskCast src));
  format %{ "(x)vmaskcast    $dst\t# @vmaskcast_gt" %}
  ins_encode %{
    if (Matcher::vector_element_basic_type(this, $src) == T_BYTE) {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_SHORT : __ vext2xv_h_b($dst$$FloatRegister, $src$$FloatRegister); break;
        case T_FLOAT :
        case T_INT   : __ vext2xv_w_b($dst$$FloatRegister, $src$$FloatRegister); break;
        case T_DOUBLE:
        case T_LONG  : __ vext2xv_d_b($dst$$FloatRegister, $src$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    } else if (Matcher::vector_element_basic_type(this, $src) == T_SHORT) {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_FLOAT :
        case T_INT   : __ vext2xv_w_h($dst$$FloatRegister, $src$$FloatRegister); break;
        case T_DOUBLE:
        case T_LONG  : __ vext2xv_d_h($dst$$FloatRegister, $src$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    } else if (type2aelembytes(Matcher::vector_element_basic_type(this, $src)) == 4 /* int or float */) {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_DOUBLE:
        case T_LONG  : __ vext2xv_d_w($dst$$FloatRegister, $src$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

instruct vmaskcast_lt(vReg dst, vReg src) %{
  predicate(Matcher::vector_length_in_bytes(n) < Matcher::vector_length_in_bytes(n->in(1)));
  match(Set dst (VectorMaskCast src));
  effect(TEMP_DEF dst);
  format %{ "(x)vmaskcast    $dst\t# @vmaskcast_lt" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this, $src) > 16)
      __ xvpermi_d($dst$$FloatRegister, $src$$FloatRegister, 0b00001110);

    if (type2aelembytes(Matcher::vector_element_basic_type(this, $src)) == 8 /* long or double */) {
      if (type2aelembytes(Matcher::vector_element_basic_type(this)) <= 4) {
        __ vsrlni_w_d($dst$$FloatRegister, $src$$FloatRegister, 0);
        if (type2aelembytes(Matcher::vector_element_basic_type(this)) <= 2) {
          __ vsrlni_h_w($dst$$FloatRegister, $dst$$FloatRegister, 0);
          if (type2aelembytes(Matcher::vector_element_basic_type(this)) == 1) {
            __ vsrlni_b_h($dst$$FloatRegister, $dst$$FloatRegister, 0);
          }
        }
      }
    } else if (type2aelembytes(Matcher::vector_element_basic_type(this, $src)) == 4 /* int or float */) {
      if (type2aelembytes(Matcher::vector_element_basic_type(this)) <= 2) {
        __ vsrlni_h_w($dst$$FloatRegister, $src$$FloatRegister, 0);
        if (type2aelembytes(Matcher::vector_element_basic_type(this)) == 1) {
          __ vsrlni_b_h($dst$$FloatRegister, $dst$$FloatRegister, 0);
        }
      }
    } else if (Matcher::vector_element_basic_type(this, $src) == T_SHORT) {
      __ vsrlni_b_h($dst$$FloatRegister, $src$$FloatRegister, 0);
    } else {
      ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// ----------------------------- VectorTest -----------------------------------

instruct anytrue_in_maskV16_branch(cmpOp cop, vReg op1, vReg op2, label labl) %{
  predicate(Matcher::vector_length_in_bytes(n->in(2)->in(1)) == 16 && static_cast<const VectorTestNode*>(n->in(2))->get_predicate() == BoolTest::ne);
  match(If cop (VectorTest op1 op2));
  effect(USE labl);
  format %{ "b$cop   $op1, $op2(not used), $labl\t# @anytrue_in_maskV16_branch" %}

  ins_encode %{
    Label    &L  = *($labl$$label);
    // No need to use op2, op2 is all ones.
    __ vseteqz_v(FCC0, $op1$$FloatRegister);
    switch($cop$$cmpcode) {
      case 0x01: // EQ
        __ bcnez(FCC0, L);
        break;
      case 0x02: // NE
        __ bceqz(FCC0, L);
        break;
      default:
        Unimplemented();
    }
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_slow );
%}

instruct alltrue_in_maskV16_branch(cmpOp cop, vReg op1, vReg op2, label labl) %{
  predicate(Matcher::vector_length_in_bytes(n->in(2)->in(1)) == 16 && static_cast<const VectorTestNode*>(n->in(2))->get_predicate() == BoolTest::overflow);
  match(If cop (VectorTest op1 op2));
  effect(USE labl);
  format %{ "b$cop   $op1, $op2(not used), $labl\t# @alltrue_in_maskV16__branch" %}

  ins_encode %{
    Label    &L  = *($labl$$label);
    // No need to use op2, op2 is all ones.
    __ vsetallnez_b(FCC0, $op1$$FloatRegister);
    switch($cop$$cmpcode) {
      case 0x01: // EQ
        __ bcnez(FCC0, L);
        break;
      case 0x02: // NE
        __ bceqz(FCC0, L);
        break;
      default:
        Unimplemented();
    }
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_slow );
%}

instruct CMoveI_anytrue_in_maskV16(mRegI dst, mRegIorL2I src1, mRegIorL2I src2, vReg op1, vReg op2, cmpOp cop, regF tmp1, regF tmp2)
%{
  predicate(Matcher::vector_length_in_bytes(n->in(1)->in(2)->in(1)) == 16 && static_cast<const VectorTestNode*>(n->in(1)->in(2))->get_predicate() == BoolTest::ne);
  match(Set dst (CMoveI (Binary cop (VectorTest op1 op2)) (Binary src1 src2)));
  effect(TEMP tmp1, TEMP tmp2);
  format %{ "cmovei_vtest($cop)    $dst, $src1, $src2, $op1, $op2(not used)\t# TEMP($tmp1, $tmp2) @CMoveI_anytrue_in_maskV16" %}
  ins_encode %{
    // No need to use op2, op2 is all ones.
    __ vseteqz_v(FCC0, $op1$$FloatRegister);
    __ movgr2fr_w($tmp1$$FloatRegister, $src1$$Register);
    __ movgr2fr_w($tmp2$$FloatRegister, $src2$$Register);
    switch($cop$$cmpcode) {
      case 0x01: // EQ
        __ fsel($tmp1$$FloatRegister, $tmp1$$FloatRegister, $tmp2$$FloatRegister, FCC0);
        break;
      case 0x02: // NE
        __ fsel($tmp1$$FloatRegister, $tmp2$$FloatRegister, $tmp1$$FloatRegister, FCC0);
        break;
      default:
        Unimplemented();
    }
    __ movfr2gr_s($dst$$Register, $tmp1$$FloatRegister);
  %}
  ins_pipe( pipe_slow );
%}

instruct CMoveI_alltrue_in_maskV16(mRegI dst, mRegIorL2I src1, mRegIorL2I src2, vReg op1, vReg op2, cmpOp cop, regF tmp1, regF tmp2)
%{
  predicate(Matcher::vector_length_in_bytes(n->in(1)->in(2)->in(1)) == 16 && static_cast<const VectorTestNode*>(n->in(1)->in(2))->get_predicate() == BoolTest::overflow);
  match(Set dst (CMoveI (Binary cop (VectorTest op1 op2)) (Binary src1 src2)));
  effect(TEMP tmp1, TEMP tmp2);
  format %{ "cmovei_vtest($cop)    $dst, $src1, $src2, $op1, $op2(not used)\t# TEMP($tmp1, $tmp2) @CMoveI_alltrue_in_maskV16" %}
  ins_encode %{
    // No need to use op2, op2 is all ones.
    __ vsetallnez_b(FCC0, $op1$$FloatRegister);
    __ movgr2fr_w($tmp1$$FloatRegister, $src1$$Register);
    __ movgr2fr_w($tmp2$$FloatRegister, $src2$$Register);
    switch($cop$$cmpcode) {
      case 0x01: // EQ
        __ fsel($tmp1$$FloatRegister, $tmp1$$FloatRegister, $tmp2$$FloatRegister, FCC0);
        break;
      case 0x02: // NE
        __ fsel($tmp1$$FloatRegister, $tmp2$$FloatRegister, $tmp1$$FloatRegister, FCC0);
        break;
      default:
        Unimplemented();
    }
    __ movfr2gr_s($dst$$Register, $tmp1$$FloatRegister);
  %}
  ins_pipe( pipe_slow );
%}

instruct anytrue_in_maskV32_branch(cmpOp cop, vReg op1, vReg op2, label labl) %{
  predicate(Matcher::vector_length_in_bytes(n->in(2)->in(1)) == 32 && static_cast<const VectorTestNode*>(n->in(2))->get_predicate() == BoolTest::ne);
  match(If cop (VectorTest op1 op2));
  effect(USE labl);
  format %{ "b$cop   $op1, $op2(not used), $labl\t# @anytrue_in_maskV32__branch" %}

  ins_encode %{
    Label &L  = *($labl$$label);
    // No need to use op2, op2 is all ones.
    __ xvseteqz_v(FCC0, $op1$$FloatRegister);
    switch($cop$$cmpcode) {
      case 0x01: // EQ
        __ bcnez(FCC0, L);
        break;
      case 0x02: // NE
        __ bceqz(FCC0, L);
        break;
      default:
        Unimplemented();
    }
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_slow );
%}

instruct alltrue_in_maskV32_branch(cmpOp cop, vReg op1, vReg op2, label labl) %{
  predicate(Matcher::vector_length_in_bytes(n->in(2)->in(1)) == 32 && static_cast<const VectorTestNode*>(n->in(2))->get_predicate() == BoolTest::overflow);
  match(If cop (VectorTest op1 op2));
  effect(USE labl);
  format %{ "b$cop   $op1, $op2(not used), $labl\t# @alltrue_in_maskV32__branch" %}

  ins_encode %{
    Label &L  = *($labl$$label);
    // No need to use op2, op2 is all ones.
    __ xvsetallnez_b(FCC0, $op1$$FloatRegister);
    switch($cop$$cmpcode) {
      case 0x01: // EQ
        __ bcnez(FCC0, L);
        break;
      case 0x02: // NE
        __ bceqz(FCC0, L);
        break;
      default:
        Unimplemented();
    }
  %}

  ins_pc_relative(1);
  ins_pipe( pipe_slow );
%}

instruct CMoveI_anytrue_in_maskV32(mRegI dst, mRegIorL2I src1, mRegIorL2I src2, vReg op1, vReg op2, cmpOp cop, regF tmp1, regF tmp2)
%{
  predicate(Matcher::vector_length_in_bytes(n->in(1)->in(2)->in(1)) == 32 && static_cast<const VectorTestNode*>(n->in(1)->in(2))->get_predicate() == BoolTest::ne);
  match(Set dst (CMoveI (Binary cop (VectorTest op1 op2)) (Binary src1 src2)));
  effect(TEMP tmp1, TEMP tmp2);
  format %{ "cmovei_xvtest($cop)    $dst, $src1, $src2, $op1, $op2(not used)\t# TEMP($tmp1, $tmp2) @CMoveI_anytrue_in_maskV32" %}
  ins_encode %{
    // No need to use op2, op2 is all ones.
    __ xvseteqz_v(FCC0, $op1$$FloatRegister);
    __ movgr2fr_w($tmp1$$FloatRegister, $src1$$Register);
    __ movgr2fr_w($tmp2$$FloatRegister, $src2$$Register);
    switch($cop$$cmpcode) {
      case 0x01: // EQ
        __ fsel($tmp1$$FloatRegister, $tmp1$$FloatRegister, $tmp2$$FloatRegister, FCC0);
        break;
      case 0x02: // NE
        __ fsel($tmp1$$FloatRegister, $tmp2$$FloatRegister, $tmp1$$FloatRegister, FCC0);
        break;
      default:
        Unimplemented();
    }
    __ movfr2gr_s($dst$$Register, $tmp1$$FloatRegister);
  %}
  ins_pipe( pipe_slow );
%}

instruct CMoveI_alltrue_in_maskV32(mRegI dst, mRegIorL2I src1, mRegIorL2I src2, vReg op1, vReg op2, cmpOp cop, regF tmp1, regF tmp2)
%{
  predicate(Matcher::vector_length_in_bytes(n->in(1)->in(2)->in(1)) == 32 && static_cast<const VectorTestNode*>(n->in(1)->in(2))->get_predicate() == BoolTest::overflow);
  match(Set dst (CMoveI (Binary cop (VectorTest op1 op2)) (Binary src1 src2)));
  effect(TEMP tmp1, TEMP tmp2);
  format %{ "cmovei_xvtest($cop)    $dst, $src1, $src2, $op1, $op2(not used)\t# TEMP($tmp1, $tmp2) @CMoveI_alltrue_in_maskV32" %}
  ins_encode %{
    // No need to use op2, op2 is all ones.
    __ xvsetallnez_b(FCC0, $op1$$FloatRegister);
    __ movgr2fr_w($tmp1$$FloatRegister, $src1$$Register);
    __ movgr2fr_w($tmp2$$FloatRegister, $src2$$Register);
    switch($cop$$cmpcode) {
      case 0x01: // EQ
        __ fsel($tmp1$$FloatRegister, $tmp1$$FloatRegister, $tmp2$$FloatRegister, FCC0);
        break;
      case 0x02: // NE
        __ fsel($tmp1$$FloatRegister, $tmp2$$FloatRegister, $tmp1$$FloatRegister, FCC0);
        break;
      default:
        Unimplemented();
    }
    __ movfr2gr_s($dst$$Register, $tmp1$$FloatRegister);
  %}
  ins_pipe( pipe_slow );
%}

// ----------------------------- VectorMaskTrueCount ----------------------------

instruct mask_truecountV(mRegI dst, vReg src, vReg tmp) %{
  match(Set dst (VectorMaskTrueCount src));
  effect(TEMP tmp);
  format %{ "(x)vmask_truecount   $dst, $src\t# TEMP($tmp) @mask_truecountV" %}
  ins_encode %{
    // Input "src" is a vector of boolean represented as bytes with
    // 0x00/0x01 as element values.
    if (Matcher::vector_length(this, $src) == 4) {
      __ vpcnt_w(fscratch, $src$$FloatRegister);
      __ vpickve2gr_b($dst$$Register, fscratch, 0);
    } else if (Matcher::vector_length(this, $src) == 8) {
      __ vpcnt_d(fscratch, $src$$FloatRegister);
      __ vpickve2gr_b($dst$$Register, fscratch, 0);
    } else if (Matcher::vector_length(this, $src) == 16) {
      __ vpcnt_d(fscratch, $src$$FloatRegister);
      __ vhaddw_q_d(fscratch, fscratch, fscratch);
      __ vpickve2gr_b($dst$$Register, fscratch, 0);
    } else if (Matcher::vector_length(this, $src) == 32) {
      __ xvpcnt_d($tmp$$FloatRegister, $src$$FloatRegister);
      __ xvhaddw_q_d($tmp$$FloatRegister, $tmp$$FloatRegister, $tmp$$FloatRegister);
      __ xvpermi_d(fscratch, $tmp$$FloatRegister, 0b00001110);
      __ vadd_b($tmp$$FloatRegister, $tmp$$FloatRegister, fscratch);
      __ vpickve2gr_b($dst$$Register, $tmp$$FloatRegister, 0);
    } else {
      ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// ----------------------------- VectorMaskFirstTrue ----------------------------

instruct mask_first_trueV(mRegI dst, vReg src, vReg tmp) %{
  match(Set dst (VectorMaskFirstTrue src));
  effect(TEMP tmp);
  format %{ "(x)vmask_first_true    $dst, $src\t# TEMP($tmp) @mask_first_trueV" %}
  ins_encode %{
    // Returns the index of the first active lane of the
    // vector mask, or 4/8/16/32 (VLENGTH) if no lane is active.
    //
    // Input "src" is a vector of boolean represented as
    // bytes with 0x00/0x01 as element values.

    if (Matcher::vector_length(this, $src) == 4) {
      __ movfr2gr_s($dst$$Register, $src$$FloatRegister);
      __ ctz_w($dst$$Register, $dst$$Register);
      __ srli_w($dst$$Register, $dst$$Register, 3);
    } else if (Matcher::vector_length(this, $src) == 8) {
      __ movfr2gr_d($dst$$Register, $src$$FloatRegister);
      __ ctz_d($dst$$Register, $dst$$Register);
      __ srli_w($dst$$Register, $dst$$Register, 3);
    } else if (Matcher::vector_length(this, $src) == 16) {
      __ vneg_b(fscratch, $src$$FloatRegister);
      __ vfrstpi_b(fscratch, fscratch, 0);
      __ vpickve2gr_b($dst$$Register, fscratch, 0);
    } else if (Matcher::vector_length(this, $src) == 32) {
      Label DONE;
      __ xvneg_b($tmp$$FloatRegister, $src$$FloatRegister);
      __ xvfrstpi_b($tmp$$FloatRegister, $tmp$$FloatRegister, 0);
      __ xvpermi_q(fscratch, $tmp$$FloatRegister, 0x01);
      __ vpickve2gr_b($dst$$Register, $tmp$$FloatRegister, 0);
      __ li(AT, (long)16);
      __ blt($dst$$Register, AT, DONE);
      __ vpickve2gr_b($dst$$Register, fscratch, 0);
      __ add_w($dst$$Register, $dst$$Register, AT);
      __ bind(DONE);
    } else {
      ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// ----------------------------- VectorMaskLastTrue ----------------------------

instruct mask_last_trueV(mRegI dst, vReg src) %{
  match(Set dst (VectorMaskLastTrue src));
  format %{ "(x)vmask_last_true    $dst, $src\t# @mask_last_trueV" %}
  ins_encode %{
    // Returns the index of the last active lane of the
    // vector mask, or -1 if no lane is active.
    //
    // Input "src" is a vector of boolean represented as
    // bytes with 0x00/0x01 as element values.

    if (Matcher::vector_length(this, $src) == 4) {
      __ movfr2gr_s($dst$$Register, $src$$FloatRegister);
      __ clz_w($dst$$Register, $dst$$Register);
      __ srli_w($dst$$Register, $dst$$Register, 3);
      __ addi_w($dst$$Register, $dst$$Register, -3);
      __ sub_w($dst$$Register, R0, $dst$$Register);
    } else if (Matcher::vector_length(this, $src) == 8) {
      __ movfr2gr_d($dst$$Register, $src$$FloatRegister);
      __ clz_d($dst$$Register, $dst$$Register);
      __ srli_w($dst$$Register, $dst$$Register, 3);
      __ addi_w($dst$$Register, $dst$$Register, -7);
      __ sub_w($dst$$Register, R0, $dst$$Register);
    } else if (Matcher::vector_length(this, $src) == 16) {
      Label FIRST_TRUE_INDEX;
      __ vpickve2gr_d($dst$$Register, $src$$FloatRegister, 1);
      __ li(AT, (long)15);
      __ bnez($dst$$Register, FIRST_TRUE_INDEX);

      __ vpickve2gr_d($dst$$Register, $src$$FloatRegister, 0);
      __ li(AT, (long)7);
      __ bind(FIRST_TRUE_INDEX);
      __ clz_d($dst$$Register, $dst$$Register);
      __ srli_w($dst$$Register, $dst$$Register, 3);
      __ sub_w($dst$$Register, AT, $dst$$Register);
    } else if (Matcher::vector_length(this, $src) == 32) {
    Label FIRST_TRUE_INDEX;
    __ xvpickve2gr_d($dst$$Register, $src$$FloatRegister, 3);
    __ li(AT, (long)31);
    __ bnez($dst$$Register, FIRST_TRUE_INDEX);

    __ xvpickve2gr_d($dst$$Register, $src$$FloatRegister, 2);
    __ li(AT, (long)23);
    __ bnez($dst$$Register, FIRST_TRUE_INDEX);

    __ xvpickve2gr_d($dst$$Register, $src$$FloatRegister, 1);
    __ li(AT, (long)15);
    __ bnez($dst$$Register, FIRST_TRUE_INDEX);

    __ xvpickve2gr_d($dst$$Register, $src$$FloatRegister, 0);
    __ li(AT, (long)7);
    __ bind(FIRST_TRUE_INDEX);
    __ clz_d($dst$$Register, $dst$$Register);
    __ srli_w($dst$$Register, $dst$$Register, 3);
    __ sub_w($dst$$Register, AT, $dst$$Register);
    } else {
      ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// ----------------------------- Vector comparison ----------------------------

instruct cmpV(vReg dst, vReg src1, vReg src2, immI cond)
%{
  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));
  format %{ "(x)vcompare    $dst, $src1, $src2, $cond\t# @cmpV" %}
  ins_encode %{
    BasicType bt = Matcher::vector_element_basic_type(this);
    __ vector_compare($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
                      bt, $cond$$constant, Matcher::vector_length_in_bytes(this));
  %}
  ins_pipe( pipe_slow );
%}

// ---------------------------- LOAD_IOTA_INDICES -----------------------------

instruct loadconV(vReg dst, immI_0 src) %{
  match(Set dst (VectorLoadConst src));
  format %{ "(x)vld_con    $dst, CONSTANT_MEMORY\t# @loadconV" %}
  ins_encode %{
    // The iota indices are ordered by type B/S/I/L/F/D, and the offset between two types is 32.
    BasicType bt = Matcher::vector_element_basic_type(this);
    int offset = exact_log2(type2aelembytes(bt)) << 5;
    if (is_floating_point_type(bt)) {
      offset += 64;
    }
    __ li(AT, (long)(StubRoutines::la::vector_iota_indices() + offset));
    switch (Matcher::vector_length_in_bytes(this)) {
      case  4:
      case  8:
      case 16: __  vld($dst$$FloatRegister, AT, (int)0); break;
      case 32: __ xvld($dst$$FloatRegister, AT, (int)0); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// ------------------------------ Populate Index to a Vector ------------------

instruct populateIndexV(vReg dst, mRegI src1, immI_1 src2) %{
  match(Set dst (PopulateIndex src1 src2));
  format %{ "(x)vpopulate_index    $dst, $src1, $src2\t# @populateIndexV" %}
  ins_encode %{
    assert($src2$$constant == 1, "required");
    BasicType bt = Matcher::vector_element_basic_type(this);
    int offset = exact_log2(type2aelembytes(bt)) << 5;
    __ li(AT, (long)(StubRoutines::la::vector_iota_indices() + offset));
    if (Matcher::vector_length_in_bytes(this) > 16) {
      __ xvld(fscratch, AT, (int)0);
      switch (bt) {
        case T_BYTE  : __ xvreplgr2vr_b($dst$$FloatRegister, $src1$$Register);
                       __ xvadd_b($dst$$FloatRegister, $dst$$FloatRegister, fscratch); break;
        case T_SHORT : __ xvreplgr2vr_h($dst$$FloatRegister, $src1$$Register);
                       __ xvadd_h($dst$$FloatRegister, $dst$$FloatRegister, fscratch); break;
        case T_INT   : __ xvreplgr2vr_w($dst$$FloatRegister, $src1$$Register);
                       __ xvadd_w($dst$$FloatRegister, $dst$$FloatRegister, fscratch); break;
        case T_LONG  : __ xvreplgr2vr_d($dst$$FloatRegister, $src1$$Register);
                       __ xvadd_d($dst$$FloatRegister, $dst$$FloatRegister, fscratch); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      __ vld(fscratch, AT, (int)0);
      switch (bt) {
        case T_BYTE  : __ vreplgr2vr_b($dst$$FloatRegister, $src1$$Register);
                       __ vadd_b($dst$$FloatRegister, $dst$$FloatRegister, fscratch); break;
        case T_SHORT : __ vreplgr2vr_h($dst$$FloatRegister, $src1$$Register);
                       __ vadd_h($dst$$FloatRegister, $dst$$FloatRegister, fscratch); break;
        case T_INT   : __ vreplgr2vr_w($dst$$FloatRegister, $src1$$Register);
                       __ vadd_w($dst$$FloatRegister, $dst$$FloatRegister, fscratch); break;
        case T_LONG  : __ vreplgr2vr_d($dst$$FloatRegister, $src1$$Register);
                       __ vadd_d($dst$$FloatRegister, $dst$$FloatRegister, fscratch); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

// ---------------------------- LOAD_SHUFFLE ----------------------------------

instruct loadShuffleVB(vReg dst) %{
  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);
  match(Set dst (VectorLoadShuffle dst));
  format %{ "(x)vld_shuffle    $dst\t# @loadShuffleVB" %}
  ins_encode %{
    // empty
  %}
  ins_pipe( pipe_slow );
%}

instruct loadShuffleV(vReg dst, vReg src) %{
  predicate(Matcher::vector_element_basic_type(n) != T_BYTE);
  match(Set dst (VectorLoadShuffle src));
  format %{ "(x)vld_shuffle    $dst, $src\t# @loadShuffleV" %}
  ins_encode %{
    switch (Matcher::vector_element_basic_type(this)) {
      case T_SHORT : __ vext2xv_hu_bu($dst$$FloatRegister, $src$$FloatRegister); break;
      case T_FLOAT :
      case T_INT   : __ vext2xv_wu_bu($dst$$FloatRegister, $src$$FloatRegister); break;
      case T_DOUBLE:
      case T_LONG  : __ vext2xv_du_bu($dst$$FloatRegister, $src$$FloatRegister); break;
      default:
        ShouldNotReachHere();
    }
  %}
  ins_pipe( pipe_slow );
%}

// ---------------------------- Rearrange -------------------------------------

instruct rearrangeV(vReg dst, vReg src, vReg tmp) %{
  match(Set dst (VectorRearrange src dst));
  effect(TEMP tmp);
  format %{ "(x)vrearrange    $dst, $src, $dst\t# TEMP($tmp) @rearrangeV" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      __ xvpermi_q($tmp$$FloatRegister, $src$$FloatRegister, 0x00);
      __ xvpermi_q(fscratch, $src$$FloatRegister, 0x11);
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BYTE  : __ xvshuf_b($dst$$FloatRegister, fscratch, $tmp$$FloatRegister, $dst$$FloatRegister); break;
        case T_SHORT : __ xvshuf_h($dst$$FloatRegister, fscratch, $tmp$$FloatRegister); break;
        case T_FLOAT :
        case T_INT   : __ xvshuf_w($dst$$FloatRegister, fscratch, $tmp$$FloatRegister); break;
        case T_DOUBLE:
        case T_LONG  : __ xvshuf_d($dst$$FloatRegister, fscratch, $tmp$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BYTE  : __ vshuf_b($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister, $dst$$FloatRegister); break;
        case T_SHORT : __ vshuf_h($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister); break;
        case T_FLOAT :
        case T_INT   : __ vshuf_w($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister); break;
        case T_DOUBLE:
        case T_LONG  : __ vshuf_d($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

// ---------------------------- PopCount --------------------------------------

instruct popcountV(vReg dst, vReg src) %{
  match(Set dst (PopCountVI src));
  match(Set dst (PopCountVL src));
  format %{ "(x)vpcnt    $dst, $src\t# @popcountV" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BYTE  : __ xvpcnt_b($dst$$FloatRegister, $src$$FloatRegister); break;
        case T_SHORT : __ xvpcnt_h($dst$$FloatRegister, $src$$FloatRegister); break;
        case T_INT   : __ xvpcnt_w($dst$$FloatRegister, $src$$FloatRegister); break;
        case T_LONG  : __ xvpcnt_d($dst$$FloatRegister, $src$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BYTE  : __ vpcnt_b($dst$$FloatRegister, $src$$FloatRegister); break;
        case T_SHORT : __ vpcnt_h($dst$$FloatRegister, $src$$FloatRegister); break;
        case T_INT   : __ vpcnt_w($dst$$FloatRegister, $src$$FloatRegister); break;
        case T_LONG  : __ vpcnt_d($dst$$FloatRegister, $src$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

// ---------------------------- CountLeadingZerosV --------------------------------------

instruct clzV(vReg dst, vReg src) %{
  match(Set dst (CountLeadingZerosV src));
  format %{ "(x)vclz    $dst, $src\t# @clzV" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BYTE  : __ xvclz_b($dst$$FloatRegister, $src$$FloatRegister); break;
        case T_SHORT : __ xvclz_h($dst$$FloatRegister, $src$$FloatRegister); break;
        case T_INT   : __ xvclz_w($dst$$FloatRegister, $src$$FloatRegister); break;
        case T_LONG  : __ xvclz_d($dst$$FloatRegister, $src$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    } else {
      switch (Matcher::vector_element_basic_type(this)) {
        case T_BYTE  : __ vclz_b($dst$$FloatRegister, $src$$FloatRegister); break;
        case T_SHORT : __ vclz_h($dst$$FloatRegister, $src$$FloatRegister); break;
        case T_INT   : __ vclz_w($dst$$FloatRegister, $src$$FloatRegister); break;
        case T_LONG  : __ vclz_d($dst$$FloatRegister, $src$$FloatRegister); break;
        default:
          ShouldNotReachHere();
      }
    }
  %}
  ins_pipe( pipe_slow );
%}

// ------------------------------ Vector signum --------------------------------

instruct signumV(vReg dst, vReg src, vReg zero, vReg one, vReg tmp) %{
  match(Set dst (SignumVF src (Binary zero one)));
  match(Set dst (SignumVD src (Binary zero one)));
  effect(TEMP_DEF dst, TEMP tmp);
  format %{ "(x)vsignum    $dst, $src, $zero, $one\t# TEMP($tmp) @signumV" %}
  ins_encode %{
    if (Matcher::vector_length_in_bytes(this) > 16) {
      switch (Matcher::vector_element_basic_type(this, $src)) {
        case T_FLOAT:  __ xvfcmp_clt_s($dst$$FloatRegister, $zero$$FloatRegister, $src$$FloatRegister);
                       __ xvfcmp_clt_s($tmp$$FloatRegister, $src$$FloatRegister, $zero$$FloatRegister);
                       __ xvor_v($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister);
                       __ xvsrli_w($dst$$FloatRegister, $dst$$FloatRegister, 1);
                       break;
        case T_DOUBLE: __ xvfcmp_clt_d($dst$$FloatRegister, $zero$$FloatRegister, $src$$FloatRegister);
                       __ xvfcmp_clt_d($tmp$$FloatRegister, $src$$FloatRegister, $zero$$FloatRegister);
                       __ xvor_v($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister);
                       __ xvsrli_d($dst$$FloatRegister, $dst$$FloatRegister, 1);
                       break;
        default:
          ShouldNotReachHere();
      }
      __ xvbitsel_v($dst$$FloatRegister, $src$$FloatRegister, $one$$FloatRegister, $dst$$FloatRegister);
    } else {
      switch (Matcher::vector_element_basic_type(this, $src)) {
        case T_FLOAT:  __ vfcmp_clt_s($dst$$FloatRegister, $zero$$FloatRegister, $src$$FloatRegister);
                       __ vfcmp_clt_s($tmp$$FloatRegister, $src$$FloatRegister, $zero$$FloatRegister);
                       __ vor_v($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister);
                       __ vsrli_w($dst$$FloatRegister, $dst$$FloatRegister, 1);
                       break;
        case T_DOUBLE: __ vfcmp_clt_d($dst$$FloatRegister, $zero$$FloatRegister, $src$$FloatRegister);
                       __ vfcmp_clt_d($tmp$$FloatRegister, $src$$FloatRegister, $zero$$FloatRegister);
                       __ vor_v($dst$$FloatRegister, $dst$$FloatRegister, $tmp$$FloatRegister);
                       __ vsrli_d($dst$$FloatRegister, $dst$$FloatRegister, 1);
                       break;
        default:
          ShouldNotReachHere();
      }
      __ vbitsel_v($dst$$FloatRegister, $src$$FloatRegister, $one$$FloatRegister, $dst$$FloatRegister);
    }
  %}
  ins_pipe(pipe_slow);
%}


//----------PEEPHOLE RULES-----------------------------------------------------
// These must follow all instruction definitions as they use the names
// defined in the instructions definitions.
//
// peepmatch ( root_instr_name [preceeding_instruction]* );
//
// peepconstraint %{
// (instruction_number.operand_name relational_op instruction_number.operand_name
//  [, ...] );
// // instruction numbers are zero-based using left to right order in peepmatch
//
// peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
// // provide an instruction_number.operand_name for each operand that appears
// // in the replacement instruction's match rule
//
// ---------VM FLAGS---------------------------------------------------------
//
// All peephole optimizations can be turned off using -XX:-OptoPeephole
//
// Each peephole rule is given an identifying number starting with zero and
// increasing by one in the order seen by the parser.  An individual peephole
// can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
// on the command-line.
//
// ---------CURRENT LIMITATIONS----------------------------------------------
//
// Only match adjacent instructions in same basic block
// Only equality constraints
// Only constraints between operands, not (0.dest_reg == EAX_enc)
// Only one replacement instruction
//
// ---------EXAMPLE----------------------------------------------------------
//
// // pertinent parts of existing instructions in architecture description
// instruct movI(eRegI dst, eRegI src) %{
//   match(Set dst (CopyI src));
// %}
//
// instruct incI_eReg(eRegI dst, immI_1 src, eFlagsReg cr) %{
//   match(Set dst (AddI dst src));
//   effect(KILL cr);
// %}
//
// // Change (inc mov) to lea
// peephole %{
//   // increment preceded by register-register move
//   peepmatch ( incI_eReg movI );
//   // require that the destination register of the increment
//   // match the destination register of the move
//   peepconstraint ( 0.dst == 1.dst );
//   // construct a replacement instruction that sets
//   // the destination to ( move's source register + one )
//   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
// %}
//
// Implementation no longer uses movX instructions since
// machine-independent system no longer uses CopyX nodes.
//
// peephole %{
//   peepmatch ( incI_eReg movI );
//   peepconstraint ( 0.dst == 1.dst );
//   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
// %}
//
// peephole %{
//   peepmatch ( decI_eReg movI );
//   peepconstraint ( 0.dst == 1.dst );
//   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
// %}
//
// peephole %{
//   peepmatch ( addI_eReg_imm movI );
//   peepconstraint ( 0.dst == 1.dst );
//   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
// %}
//
// peephole %{
//   peepmatch ( addP_eReg_imm movP );
//   peepconstraint ( 0.dst == 1.dst );
//   peepreplace ( leaP_eReg_immI( 0.dst 1.src 0.src ) );
// %}

// // Change load of spilled value to only a spill
// instruct storeI(memory mem, eRegI src) %{
//   match(Set mem (StoreI mem src));
// %}
//
// instruct loadI(eRegI dst, memory mem) %{
//   match(Set dst (LoadI mem));
// %}
//
//peephole %{
//  peepmatch ( loadI storeI );
//  peepconstraint ( 1.src == 0.dst, 1.mem == 0.mem );
//  peepreplace ( storeI( 1.mem 1.mem 1.src ) );
//%}

//----------SMARTSPILL RULES---------------------------------------------------
// These must follow all instruction definitions as they use the names
// defined in the instructions definitions.

